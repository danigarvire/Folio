/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/constants/index.js
var VIEW_TYPE, WRITER_TOOLS_VIEW_TYPE, PROJECT_TYPES, DEFAULT_SETTINGS, DEFAULT_BOOK_CONFIG;
var init_constants = __esm({
  "src/constants/index.js"() {
    VIEW_TYPE = "folio-view";
    WRITER_TOOLS_VIEW_TYPE = "folio-writer-tools";
    PROJECT_TYPES = {
      BOOK: "book",
      SCRIPT: "script",
      FILM: "film",
      ESSAY: "essay"
    };
    DEFAULT_SETTINGS = {
      booksPath: "projects",
      basePath: "projects",
      // Legacy compatibility
      lastActiveBookPath: null,
      verboseLogs: false,
      defaultAuthor: "",
      defaultProjectType: "book",
      projectTemplates: [
        {
          id: "book",
          name: "Book",
          icon: "book",
          order: 1,
          description: "Novel or written work",
          structure: [
            { title: "Moodboard", type: "canvas", icon: "layout-dashboard" },
            { title: "Preface", type: "file", icon: "file" },
            { title: "Outline", type: "file", icon: "list" },
            { title: "Volume 1", type: "folder", icon: "folder-open", children: [
              { title: "Chapter 1", type: "file", icon: "file" }
            ] },
            { title: "Afterword", type: "file", icon: "file" }
          ]
        },
        {
          id: "script",
          name: "TV Show",
          icon: "tv",
          order: 2,
          description: "Series with episodes and sequences",
          structure: [
            {
              title: "Show Dossier",
              type: "folder",
              icon: "folder-open",
              children: [
                { title: "Concept", type: "folder", icon: "lightbulb", children: [
                  { title: "Logline", type: "file", icon: "file" },
                  { title: "Synopsis", type: "file", icon: "file" }
                ] },
                { title: "Structure", type: "folder", icon: "list-tree", children: [
                  { title: "Beat Sheet", type: "file", icon: "file" }
                ] },
                { title: "Faces", type: "folder", icon: "users", children: [
                  { title: "Character 1", type: "file", icon: "file" }
                ] },
                { title: "Places", type: "folder", icon: "map-pin", children: [
                  { title: "Location 1", type: "file", icon: "file" }
                ] },
                { title: "Objects", type: "folder", icon: "box", children: [
                  { title: "Prop 1", type: "file", icon: "file" }
                ] },
                { title: "Documentation", type: "folder", icon: "archive", children: [
                  { title: "Research", type: "file", icon: "file" }
                ] }
              ]
            },
            { title: "Episode 1", type: "folder", icon: "clapperboard", children: [
              { title: "Scene 1", type: "file", icon: "file" }
            ] }
          ]
        },
        {
          id: "film",
          name: "Film",
          icon: "clapperboard",
          order: 3,
          description: "Feature film or short",
          structure: [
            { title: "Moodboard", type: "canvas", icon: "layout-dashboard" },
            { title: "Outline", type: "file", icon: "list" },
            { title: "Sequence 1", type: "folder", icon: "film", children: [
              { title: "Scene 1", type: "file", icon: "file" }
            ] }
          ]
        },
        {
          id: "essay",
          name: "Essay",
          icon: "newspaper",
          order: 4,
          description: "Essay or short nonfiction piece",
          structure: [
            {
              title: "Research",
              type: "folder",
              icon: "archive",
              children: [
                { title: "Document 1", type: "file", icon: "file" }
              ]
            },
            { title: "Outline", type: "file", icon: "list" },
            { title: "Manuscript", type: "file", icon: "scroll-text" }
          ]
        }
      ]
    };
    DEFAULT_BOOK_CONFIG = {
      basic: {
        title: "",
        author: [],
        subtitle: "",
        desc: "",
        uuid: "",
        created_at: new Date().toISOString(),
        projectType: "book"
        // Default project type
      },
      structure: {
        tree: []
      },
      stats: {
        total_words: 0,
        target_total_words: 1e4,
        progress_by_words: 0,
        progress_by_chapter: 0,
        daily_words: {},
        writing_days: 0,
        average_daily_words: 0,
        last_writing_date: new Date().toISOString(),
        last_modified: new Date().toISOString(),
        per_chapter: {}
      },
      export: {
        default_format: "pdf",
        template: "default",
        include_cover: true
      }
    };
  }
});

// src/modals/projectTypeSelectorModal.js
var import_obsidian3, ProjectTypeSelectorModal;
var init_projectTypeSelectorModal = __esm({
  "src/modals/projectTypeSelectorModal.js"() {
    import_obsidian3 = require("obsidian");
    ProjectTypeSelectorModal = class extends import_obsidian3.Modal {
      constructor(app, onSelect, templates = null) {
        super(app);
        this.onSelect = onSelect;
        this.templates = templates;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("folio-project-type-selector-modal");
        contentEl.createEl("h2", { text: "Select Project Type" });
        const optionsContainer = contentEl.createDiv({ cls: "folio-project-type-options" });
        const templates = this.templates || [
          { id: "book", name: "Book", icon: "book", order: 1, description: "Novel or written work" },
          { id: "script", name: "TV Show", icon: "tv", order: 2, description: "Series with episodes and sequences" },
          { id: "film", name: "Film", icon: "clapperboard", order: 3, description: "Feature film or short" },
          { id: "essay", name: "Essay", icon: "newspaper", order: 4, description: "Essay or short nonfiction piece" }
        ];
        templates.sort((a, b) => a.order - b.order).forEach((template) => {
          this.createProjectOption(optionsContainer, {
            title: template.name,
            description: template.description || "",
            icon: template.icon || "file",
            value: template.id
          });
        });
      }
      createProjectOption(container, { title, description, icon, value }) {
        const option = container.createDiv({ cls: "folio-project-type-option" });
        const iconEl = option.createDiv({ cls: "folio-project-type-icon" });
        (0, import_obsidian3.setIcon)(iconEl, icon);
        const content = option.createDiv({ cls: "folio-project-type-content" });
        content.createEl("div", { text: title, cls: "folio-project-type-title" });
        content.createEl("div", { text: description, cls: "folio-project-type-description" });
        option.addEventListener("click", () => {
          this.onSelect(value);
          this.close();
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/modals/newBookModal.js
var newBookModal_exports = {};
__export(newBookModal_exports, {
  NewBookModal: () => NewBookModal
});
var Modal2, TFile3, NewBookModal;
var init_newBookModal = __esm({
  "src/modals/newBookModal.js"() {
    init_constants();
    init_projectTypeSelectorModal();
    ({ Modal: Modal2, TFile: TFile3 } = require("obsidian"));
    NewBookModal = class extends Modal2 {
      constructor(plugin) {
        var _a;
        super(plugin.app);
        this.plugin = plugin;
        const defaultType = (_a = plugin.settings) == null ? void 0 : _a.defaultProjectType;
        this.selectedProjectType = defaultType || null;
      }
      async onOpen() {
        var _a, _b;
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Create new project" });
        const makeDivider = () => contentEl.createDiv({ cls: "folio-modal-divider" });
        makeDivider();
        const typeRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const typeLeft = typeRow.createDiv({ cls: "folio-modal-left" });
        typeLeft.createEl("div", { text: "Project Type", cls: "folio-modal-row-title" });
        typeLeft.createEl("div", { text: "Select the type of project", cls: "folio-modal-row-sub" });
        const typeRight = typeRow.createDiv({ cls: "folio-modal-right" });
        const templates = ((_a = this.plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
        const typeNames = {};
        templates.forEach((t) => {
          const emoji = { book: "\u{1F4D8}", script: "\u{1F4FA}", film: "\u{1F3AC}", essay: "\u{1F4F0}" }[t.id] || "\u{1F4C4}";
          typeNames[t.id] = `${emoji} ${t.name}`;
        });
        if (!typeNames[PROJECT_TYPES.BOOK])
          typeNames[PROJECT_TYPES.BOOK] = "\u{1F4D8} Book";
        if (!typeNames[PROJECT_TYPES.SCRIPT])
          typeNames[PROJECT_TYPES.SCRIPT] = "\u{1F4FA} TV Show";
        if (!typeNames[PROJECT_TYPES.FILM])
          typeNames[PROJECT_TYPES.FILM] = "\u{1F3AC} Film";
        if (!typeNames[PROJECT_TYPES.ESSAY])
          typeNames[PROJECT_TYPES.ESSAY] = "\u{1F4F0} Essay";
        const typeButton = typeRight.createEl("button", { text: "Select", cls: "folio-project-type-button" });
        const updateButtonText = () => {
          typeButton.textContent = typeNames[this.selectedProjectType] || "Select type";
        };
        typeButton.onclick = () => {
          const modal = new ProjectTypeSelectorModal(this.app, (projectType) => {
            this.selectedProjectType = projectType;
            updateButtonText();
          }, templates.length > 0 ? templates : null);
          modal.open();
        };
        updateButtonText();
        makeDivider();
        const coverRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const coverLeft = coverRow.createDiv({ cls: "folio-modal-left" });
        coverLeft.createEl("div", { text: "Cover", cls: "folio-modal-row-title" });
        coverLeft.createEl("div", { text: "Select cover image (optional)", cls: "folio-modal-row-sub" });
        const coverRight = coverRow.createDiv({ cls: "folio-modal-right" });
        const coverBtn = coverRight.createEl("button", { text: "Select Image" });
        this._selectedCover = null;
        coverBtn.onclick = () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.style.display = "none";
          input.onchange = async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file)
              return;
            try {
              const reader = new FileReader();
              reader.onload = (ev) => {
                const ab = ev.target.result;
                this._selectedCover = { name: file.name, data: ab };
                coverBtn.textContent = "Select Image";
              };
              reader.readAsArrayBuffer(file);
            } catch (err) {
              console.warn("cover selection failed", err);
            }
          };
          document.body.appendChild(input);
          input.click();
          document.body.removeChild(input);
        };
        makeDivider();
        const titleRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const titleLeft = titleRow.createDiv({ cls: "folio-modal-left" });
        titleLeft.createEl("div", { text: "Title", cls: "folio-modal-row-title" });
        titleLeft.createEl("div", { text: "Please enter project title", cls: "folio-modal-row-sub" });
        const titleRight = titleRow.createDiv({ cls: "folio-modal-right" });
        const fieldWidth = "min(320px, 60%)";
        const titleInput = titleRight.createEl("input", { type: "text", placeholder: "Project title", cls: "folio-modal-input" });
        try {
          titleInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const subRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const subLeft = subRow.createDiv({ cls: "folio-modal-left" });
        subLeft.createEl("div", { text: "Subtitle", cls: "folio-modal-row-title" });
        subLeft.createEl("div", { text: "Optional", cls: "folio-modal-row-sub" });
        const subRight = subRow.createDiv({ cls: "folio-modal-right" });
        const subtitleInput = subRight.createEl("input", { type: "text", placeholder: "Subtitle", cls: "folio-modal-input" });
        try {
          subtitleInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const targetRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const targetLeft = targetRow.createDiv({ cls: "folio-modal-left" });
        targetLeft.createEl("div", { text: "Target word count", cls: "folio-modal-row-title" });
        targetLeft.createEl("div", { text: "Set estimated total word count (in 1k)", cls: "folio-modal-row-sub" });
        const targetRight = targetRow.createDiv({ cls: "folio-modal-right" });
        const targetInput = targetRight.createEl("input", { type: "text", placeholder: "e.g., 20 (20k) or 20000", cls: "folio-modal-input" });
        try {
          targetInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const authorRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const authorLeft = authorRow.createDiv({ cls: "folio-modal-left" });
        authorLeft.createEl("div", { text: "Author", cls: "folio-modal-row-title" });
        authorLeft.createEl("div", { text: "Enter author names, separate multiple authors with commas", cls: "folio-modal-row-sub" });
        const authorRight = authorRow.createDiv({ cls: "folio-modal-right" });
        const authorInput = authorRight.createEl("input", { type: "text", placeholder: "Author", cls: "folio-modal-input" });
        const defaultAuthor = ((_b = this.plugin.settings) == null ? void 0 : _b.defaultAuthor) || "";
        if (defaultAuthor) {
          authorInput.value = defaultAuthor;
        }
        try {
          authorInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const descRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const descLeft = descRow.createDiv({ cls: "folio-modal-left" });
        descLeft.createEl("div", { text: "Description", cls: "folio-modal-row-title" });
        descLeft.createEl("div", { text: "Please enter book description", cls: "folio-modal-row-sub" });
        const descRight = descRow.createDiv({ cls: "folio-modal-right" });
        const descInput = descRight.createEl("textarea", { placeholder: "Book description", cls: "folio-modal-textarea" });
        try {
          descInput.style.width = fieldWidth;
          descInput.style.minHeight = "120px";
        } catch (e) {
        }
        makeDivider();
        const actions = contentEl.createDiv({ cls: "folio-modal-actions" });
        const createBtn = actions.createEl("button", { text: "Create", cls: "mod-cta folio-modal-create" });
        createBtn.onclick = async () => {
          const title = titleInput.value.trim();
          if (!title)
            return;
          let projectType = this.selectedProjectType;
          if (!projectType) {
            const btnText = typeButton.textContent || "";
            if (btnText.includes("Essay"))
              projectType = PROJECT_TYPES.ESSAY;
            else if (btnText.includes("TV Show") || btnText.includes("TV"))
              projectType = PROJECT_TYPES.SCRIPT;
            else if (btnText.includes("Film"))
              projectType = PROJECT_TYPES.FILM;
            else
              projectType = PROJECT_TYPES.BOOK;
          }
          console.debug && console.debug("Creating project with type:", projectType);
          const selectedTemplate = templates.find((t) => t.id === projectType);
          const templateStructure = (selectedTemplate == null ? void 0 : selectedTemplate.structure) || null;
          const subtitleVal = subtitleInput.value.trim();
          const authorVal = authorInput.value.trim();
          const descVal = descInput.value.trim();
          const targetValRaw = targetInput.value;
          const targetValNum = parseFloat(targetValRaw) || 0;
          this.close();
          await this.plugin.createBook(title, projectType, templateStructure);
          const basePath = this.plugin.settings && this.plugin.settings.basePath ? String(this.plugin.settings.basePath).replace(/\/+/g, "/") : "projects";
          const bookPath = `${basePath}/${title}`.replace(/\/+/g, "/");
          try {
            if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
              console.debug("NewBookModal.create captured", { title, projectType, subtitleVal, authorVal, descVal, targetValNum, bookPath });
          } catch (e) {
          }
          await this.plugin.waitForFolderSync(bookPath);
          await this.plugin.refresh();
          const book = this.plugin.booksIndex.find((b) => b.path === bookPath) || this.plugin.booksIndex.find((b) => b.name === title);
          if (book) {
            try {
              let cfg = {};
              if (this.plugin.loadBookConfig)
                cfg = await this.plugin.loadBookConfig(book) || {};
              cfg.basic = cfg.basic || {};
              cfg.basic.title = title;
              cfg.basic.subtitle = subtitleVal || "";
              cfg.basic.author = authorVal ? authorVal.split(",").map((s) => s.trim()).filter(Boolean) : cfg.basic.author || [];
              cfg.basic.desc = descVal || "";
              cfg.basic.created_at = cfg.basic.created_at || new Date().toISOString();
              cfg.stats = cfg.stats || {};
              const targ = targetValNum || 0;
              if (targ > 0) {
                cfg.stats.target_total_words = targ >= 1e3 ? Math.round(targ) : Math.round(targ * 1e3);
              } else {
                cfg.stats.target_total_words = cfg.stats.target_total_words || 0;
              }
              if (this._selectedCover && this._selectedCover.name && this._selectedCover.data) {
                try {
                  const destName = `${Date.now()}-${this._selectedCover.name}`.replace(/[^a-zA-Z0-9._-]/g, "_");
                  const destPath = `${book.path}/misc/cover/${destName}`;
                  if (this.plugin.app.vault.adapter && typeof this.plugin.app.vault.adapter.writeBinary === "function") {
                    const uint8 = new Uint8Array(this._selectedCover.data);
                    await this.plugin.app.vault.adapter.writeBinary(destPath, uint8);
                  } else {
                    const blob = new Blob([this._selectedCover.data]);
                    const arrayBuf = await blob.arrayBuffer();
                    const uint8 = new Uint8Array(arrayBuf);
                    try {
                      await this.plugin.app.vault.create(destPath, uint8);
                    } catch (e) {
                      console.warn("fallback cover write failed", e);
                    }
                  }
                  cfg.basic.cover = `misc/cover/${destName}`;
                } catch (e) {
                  console.warn("saving selected cover failed", e);
                }
              }
              if (this.plugin.saveBookConfig) {
                await this.plugin.saveBookConfig(book, cfg);
                try {
                  if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
                    console.debug("NewBookModal saved initial config for", book.path, { basic: cfg.basic });
                } catch (e) {
                }
              }
            } catch (e) {
              console.warn(e);
            }
            if (!templateStructure || templateStructure.length === 0) {
              if (projectType === PROJECT_TYPES.SCRIPT) {
                const episodeName = "Episode 1";
                const sequenceName = "Sequence 1";
                const sceneName = "Scene 1";
                await this.plugin.createVolume(book, episodeName);
                await this.plugin.createVolume({ path: `${book.path}/${episodeName}` }, sequenceName);
                await this.plugin.createChapter({ path: `${book.path}/${episodeName}/${sequenceName}` }, sceneName, projectType);
              } else if (projectType === PROJECT_TYPES.FILM) {
              } else if (projectType === PROJECT_TYPES.ESSAY) {
              } else {
                const volumeName = "Volume 1";
                const chapterName = "Chapter 1";
                await this.plugin.createVolume(book, volumeName);
                await this.plugin.createChapter({ path: `${book.path}/${volumeName}` }, chapterName, projectType);
              }
            }
            await this.plugin.refresh();
            const updatedBook = this.plugin.booksIndex.find((b) => b.path === book.path);
            if (updatedBook) {
              this.plugin.activeBook = updatedBook;
              try {
                this.plugin.settings = this.plugin.settings || {};
                this.plugin.settings.lastActiveBookPath = updatedBook.path;
                await this.plugin.saveSettings();
              } catch (e) {
                console.warn("failed to persist lastActiveBookPath", e);
              }
            }
          }
          this.plugin.rerenderViews();
        };
        titleInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            createBtn.click();
          } else if (e.key === "Escape") {
            this.close();
          }
        });
        titleInput.focus();
      }
    };
  }
});

// src/modals/switchBookModal.js
var switchBookModal_exports = {};
__export(switchBookModal_exports, {
  SwitchBookModal: () => SwitchBookModal
});
function getProjectTypeIcon(plugin, projectType) {
  var _a;
  const templates = ((_a = plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
  const template = templates.find((t) => t.id === projectType);
  if (template == null ? void 0 : template.icon)
    return template.icon;
  if (projectType === PROJECT_TYPES.BOOK)
    return "book";
  if (projectType === PROJECT_TYPES.SCRIPT)
    return "tv";
  if (projectType === PROJECT_TYPES.FILM)
    return "clapperboard";
  if (projectType === PROJECT_TYPES.ESSAY)
    return "newspaper";
  return "book";
}
var Modal3, setIcon2, SwitchBookModal;
var init_switchBookModal = __esm({
  "src/modals/switchBookModal.js"() {
    init_constants();
    ({ Modal: Modal3, setIcon: setIcon2 } = require("obsidian"));
    SwitchBookModal = class extends Modal3 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Switch project" });
        const search = contentEl.createEl("input", {
          type: "text",
          placeholder: "Search books...",
          cls: "folio-manage-search"
        });
        const list = contentEl.createDiv({ cls: "folio-manage-list" });
        const formatTarget = (n) => {
          if (!n)
            return "\u2014";
          const num = Number(n) || 0;
          if (num >= 1e3) {
            const k = num / 1e3;
            return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
          }
          return String(num);
        };
        const renderList = async (filter) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
          list.empty();
          const seen = /* @__PURE__ */ new Set();
          for (const book of this.plugin.booksIndex) {
            if (!book || !book.path)
              continue;
            if (seen.has(book.path))
              continue;
            seen.add(book.path);
            let cfg = {};
            try {
              cfg = await this.plugin.loadBookConfig(book) || {};
            } catch (e) {
            }
            const subtitle = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.subtitle) || "";
            const authors = Array.isArray((_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.author) ? cfg.basic.author.join(", ") : ((_c = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _c.author) || "";
            const desc = ((_d = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _d.desc) || ((_e = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _e.description) || "";
            const totalWords = ((_f = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _f.total_words) || 0;
            const targetWords = Number(((_g = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _g.target_total_words) || ((_h = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _h.targetWordCount) || 0) || 0;
            let displayTitle = cfg && cfg.basic && cfg.basic.title ? cfg.basic.title : book.name || "";
            const q = filter ? String(filter).trim().toLowerCase() : "";
            if (q) {
              const fields = [displayTitle || book.name || "", subtitle || "", authors || "", desc || ""];
              const matches = fields.some((f) => {
                const s = String(f).toLowerCase();
                if (s.startsWith(q))
                  return true;
                return s.split(/\s+/).some((w) => w.startsWith(q));
              });
              if (!matches)
                continue;
            }
            const row = list.createDiv({ cls: "folio-switch-book-row" });
            const leftCol = row.createDiv({ cls: "folio-switch-left" });
            const rightCol = row.createDiv({ cls: "folio-switch-right" });
            const titleRow = leftCol.createDiv({ cls: "folio-switch-title-row" });
            const iconEl = titleRow.createSpan({ cls: "folio-switch-icon" });
            const projectType = ((_i = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _i.projectType) || PROJECT_TYPES.BOOK;
            const iconName = getProjectTypeIcon(this.plugin, projectType);
            setIcon2(iconEl, iconName);
            titleRow.createSpan({ text: displayTitle || book.name || "Untitled", cls: "folio-switch-title" });
            if (subtitle) {
              titleRow.createSpan({ text: " - ", cls: "folio-switch-dash" });
              titleRow.createSpan({ text: subtitle, cls: "folio-switch-subtitle" });
            }
            const progressPct = targetWords > 0 ? Math.round(Number(totalWords) / Number(targetWords) * 100) : "\u2014";
            let createdDate = "\u2014";
            let lastMod = "\u2014";
            try {
              const created = ((_j = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _j.created_at) || ((_k = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _k.created_at) || "";
              if (created)
                createdDate = new Date(created).toLocaleString();
            } catch (e) {
            }
            try {
              const lm = ((_l = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _l.last_modified) || ((_m = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _m.lastModified) || "";
              if (lm)
                lastMod = new Date(lm).toLocaleString();
            } catch (e) {
            }
            leftCol.createDiv({ text: `Author: ${authors || "\u2014"} | Progress: ${progressPct}% | Words: ${formatTarget(totalWords)}`, cls: "folio-switch-meta" });
            leftCol.createDiv({ text: `Created: ${createdDate}`, cls: "folio-switch-meta-second" });
            leftCol.createDiv({ text: `Last modified: ${lastMod}`, cls: "folio-switch-meta-second" });
            const selectBtn = rightCol.createEl("button", { text: "Select", cls: "mod-cta" });
            selectBtn.onclick = async () => {
              this.plugin.activeBook = book;
              try {
                this.plugin.settings.lastActiveBookPath = book.path;
                await this.plugin.saveSettings();
              } catch (e) {
                console.warn("Failed to persist lastActiveBookPath", e);
              }
              this.plugin.rerenderViews();
              this.close();
            };
            row.onclick = () => selectBtn.click();
          }
        };
        search.addEventListener("input", (e) => {
          renderList(e.target.value);
        });
        await renderList("");
      }
    };
  }
});

// src/modals/confirmModal.js
var Modal4, ConfirmModal;
var init_confirmModal = __esm({
  "src/modals/confirmModal.js"() {
    ({ Modal: Modal4 } = require("obsidian"));
    ConfirmModal = class extends Modal4 {
      constructor(app, { title, message, confirmText, onConfirm }) {
        super(app);
        this.title = title;
        this.message = message;
        this.confirmText = confirmText || "Confirm";
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: this.title });
        contentEl.createEl("p", { text: this.message });
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", { text: "Cancel" });
        const confirmBtn = actions.createEl("button", {
          text: this.confirmText,
          cls: "mod-warning"
        });
        cancelBtn.onclick = () => this.close();
        confirmBtn.onclick = async () => {
          await this.onConfirm();
          this.close();
        };
      }
    };
  }
});

// src/modals/editBookModal.js
var Modal5, TFile4, EditBookModal;
var init_editBookModal = __esm({
  "src/modals/editBookModal.js"() {
    ({ Modal: Modal5, TFile: TFile4 } = require("obsidian"));
    EditBookModal = class extends Modal5 {
      constructor(plugin, book) {
        super(plugin.app);
        this.plugin = plugin;
        this.book = book;
      }
      async onOpen() {
        var _a, _b, _c, _d, _e, _f, _g;
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Edit book" });
        let meta = {};
        let cfg = {};
        try {
          if (this.plugin.loadBookConfig)
            cfg = await this.plugin.loadBookConfig(this.book) || {};
        } catch (e) {
        }
        if (cfg && cfg.basic) {
          meta.title = cfg.basic.title || this.book.name || "";
          meta.subtitle = cfg.basic.subtitle || "";
          meta.author = Array.isArray(cfg.basic.author) ? cfg.basic.author.join(", ") : cfg.basic.author || "";
          meta.description = cfg.basic.desc || cfg.basic.description || "";
        } else {
          try {
            if (this.plugin.loadBookMeta)
              meta = await this.plugin.loadBookMeta(this.book) || {};
          } catch (e) {
          }
          try {
            if (!meta || Object.keys(meta).length === 0) {
              const fm = await this.plugin.readBookMetadata(this.book);
              if (fm)
                meta = Object.assign({}, meta, fm);
            }
          } catch (e) {
          }
        }
        const fieldWidth = "min(320px, 60%)";
        let selectedCover = null;
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const coverRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const coverLeft = coverRow.createDiv({ cls: "folio-modal-left" });
        coverLeft.createEl("div", { text: "Cover", cls: "folio-modal-row-title" });
        coverLeft.createEl("div", { text: "Select image (optional)", cls: "folio-modal-row-sub" });
        const coverRight = coverRow.createDiv({ cls: "folio-modal-right" });
        const coverBtn = coverRight.createEl("button", { text: "Select Image" });
        try {
          const existingCover = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.cover) || "";
          if (existingCover) {
            const baseName = existingCover.split("/").pop();
            selectedCover = { name: baseName, data: null };
          }
        } catch (e) {
        }
        coverBtn.onclick = () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.style.display = "none";
          input.onchange = async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file)
              return;
            try {
              const reader = new FileReader();
              reader.onload = (ev) => {
                const ab = ev.target.result;
                selectedCover = { name: file.name, data: ab };
                coverBtn.textContent = "Select Image";
              };
              reader.readAsArrayBuffer(file);
            } catch (err) {
              console.warn("cover selection failed", err);
            }
          };
          document.body.appendChild(input);
          input.click();
          document.body.removeChild(input);
        };
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const titleRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const titleLeft = titleRow.createDiv({ cls: "folio-modal-left" });
        titleLeft.createEl("div", { text: "Title", cls: "folio-modal-row-title" });
        titleLeft.createEl("div", { text: "Please enter book title", cls: "folio-modal-row-sub" });
        const titleRight = titleRow.createDiv({ cls: "folio-modal-right" });
        const titleInput = titleRight.createEl("input", { type: "text", cls: "folio-modal-input" });
        try {
          titleInput.style.width = fieldWidth;
        } catch (e) {
        }
        titleInput.value = meta.title || this.book.name || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const subRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const subLeft = subRow.createDiv({ cls: "folio-modal-left" });
        subLeft.createEl("div", { text: "Subtitle", cls: "folio-modal-row-title" });
        subLeft.createEl("div", { text: "Optional", cls: "folio-modal-row-sub" });
        const subRight = subRow.createDiv({ cls: "folio-modal-right" });
        const subtitleInput = subRight.createEl("input", { type: "text", cls: "folio-modal-input" });
        try {
          subtitleInput.style.width = fieldWidth;
        } catch (e) {
        }
        subtitleInput.value = meta.subtitle || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const authorRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const authorLeft = authorRow.createDiv({ cls: "folio-modal-left" });
        authorLeft.createEl("div", { text: "Author", cls: "folio-modal-row-title" });
        authorLeft.createEl("div", { text: "Enter author names, separate multiple authors with commas", cls: "folio-modal-row-sub" });
        const authorRight = authorRow.createDiv({ cls: "folio-modal-right" });
        const authorInput = authorRight.createEl("input", { type: "text", cls: "folio-modal-input" });
        try {
          authorInput.style.width = fieldWidth;
        } catch (e) {
        }
        authorInput.value = meta.author || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const descRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const descLeft = descRow.createDiv({ cls: "folio-modal-left" });
        descLeft.createEl("div", { text: "Description", cls: "folio-modal-row-title" });
        descLeft.createEl("div", { text: "Please enter book description", cls: "folio-modal-row-sub" });
        const descRight = descRow.createDiv({ cls: "folio-modal-right" });
        const descInput = descRight.createEl("textarea", { cls: "folio-modal-textarea" });
        try {
          descInput.style.width = fieldWidth;
          descInput.style.minHeight = "120px";
          descInput.style.maxWidth = "100%";
        } catch (e) {
        }
        descInput.value = meta.description || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const targetRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const targetLeft = targetRow.createDiv({ cls: "folio-modal-left" });
        targetLeft.createEl("div", { text: "Target word count", cls: "folio-modal-row-title" });
        targetLeft.createEl("div", { text: "Set estimated total word count (in 1k)", cls: "folio-modal-row-sub" });
        const targetRight = targetRow.createDiv({ cls: "folio-modal-right" });
        const targetInput = targetRight.createEl("input", { type: "text", cls: "folio-modal-input", placeholder: "e.g., 20 (20k) or 20000" });
        const existingTarget = (_g = (_f = (_d = (_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.targetWordCount) != null ? _d : (_c = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _c.target_total_words) != null ? _f : (_e = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _e.targetWordCount) != null ? _g : "";
        try {
          const num = Number(existingTarget) || 0;
          if (num >= 1e3) {
            targetInput.value = String(num / 1e3);
          } else {
            targetInput.value = existingTarget || "";
          }
        } catch (e) {
          targetInput.value = existingTarget || "";
        }
        try {
          targetInput.style.width = fieldWidth;
        } catch (e) {
        }
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", { text: "Cancel" });
        const saveBtn = actions.createEl("button", { text: "Save", cls: "mod-cta" });
        cancelBtn.onclick = () => this.close();
        saveBtn.onclick = async () => {
          const out = Object.assign({}, meta || {});
          out.title = titleInput.value.trim();
          out.subtitle = typeof subtitleInput !== "undefined" ? subtitleInput.value.trim() : "";
          out.author = authorInput.value.trim();
          out.description = descInput.value.trim();
          const targetRaw = targetInput.value.trim();
          const targNum = parseFloat(targetRaw) || 0;
          try {
            if (this.plugin.saveBookMeta) {
              const metaToSave = {
                title: out.title,
                subtitle: out.subtitle || "",
                author: out.author || "",
                description: out.description || "",
                targetWordCount: targNum
              };
              await this.plugin.saveBookMeta(this.book, metaToSave);
            }
          } catch (e) {
            console.warn("saveBookMeta failed", e);
          }
          let cfg2 = {};
          try {
            if (this.plugin.loadBookConfig)
              cfg2 = await this.plugin.loadBookConfig(this.book) || {};
            cfg2.basic = cfg2.basic || {};
            cfg2.stats = cfg2.stats || {};
            cfg2.basic.title = out.title || cfg2.basic.title || this.book.name;
            cfg2.basic.subtitle = out.subtitle || cfg2.basic.subtitle || "";
            cfg2.basic.author = out.author ? out.author.split(",").map((s) => s.trim()).filter(Boolean) : cfg2.basic.author || [];
            cfg2.basic.desc = out.description || cfg2.basic.desc || "";
            let normalizedTarget = 0;
            if (targNum > 0) {
              if (targNum >= 1e3)
                normalizedTarget = Math.round(targNum);
              else
                normalizedTarget = Math.round(targNum * 1e3);
            }
            cfg2.stats = cfg2.stats || {};
            cfg2.stats.target_total_words = normalizedTarget;
            cfg2.stats.last_modified = new Date().toISOString();
            if (selectedCover && selectedCover.name && selectedCover.data) {
              try {
                const destName = `${Date.now()}-${selectedCover.name}`.replace(/[^a-zA-Z0-9._-]/g, "_");
                const destPath = `${this.book.path}/misc/cover/${destName}`;
                if (this.plugin.app.vault.adapter && typeof this.plugin.app.vault.adapter.writeBinary === "function") {
                  const uint8 = new Uint8Array(selectedCover.data);
                  await this.plugin.app.vault.adapter.writeBinary(destPath, uint8);
                } else {
                  const blob = new Blob([selectedCover.data]);
                  const arrayBuf = await blob.arrayBuffer();
                  const uint8 = new Uint8Array(arrayBuf);
                  try {
                    await this.plugin.app.vault.create(destPath, uint8);
                  } catch (e) {
                    console.warn("fallback cover write failed", e);
                  }
                }
                cfg2.basic = cfg2.basic || {};
                cfg2.basic.cover = `misc/cover/${destName}`;
              } catch (e) {
                console.warn("saving selected cover failed", e);
              }
            }
            if (this.plugin.saveBookConfig)
              await this.plugin.saveBookConfig(this.book, cfg2);
          } catch (e) {
            console.warn(e);
          }
          let newTitle;
          try {
            newTitle = cfg2 && cfg2.basic && cfg2.basic.title ? cfg2.basic.title : out.title || this.book.name;
            try {
              this.book.name = newTitle;
            } catch (e) {
            }
            if (Array.isArray(this.plugin.booksIndex)) {
              const idx = this.plugin.booksIndex.findIndex((b) => b && b.path === this.book.path);
              if (idx !== -1)
                this.plugin.booksIndex[idx].name = newTitle;
            }
            try {
              if (this.plugin.activeBook && this.plugin.activeBook.path === this.book.path)
                this.plugin.activeBook.name = newTitle;
            } catch (e) {
            }
          } catch (err) {
            console.warn("updating in-memory book title failed", err);
          }
          try {
            const oldPath = this.book.path;
            const parentParts = String(oldPath).split("/").slice(0, -1);
            const parent = parentParts.join("/");
            const safeName = String(newTitle || "").replace(/[\\/\:\*\?"<>\|]/g, "_").trim();
            const newPath = parent ? `${parent}/${safeName}` : safeName;
            if (safeName && newPath !== oldPath) {
              const existing = this.plugin.app.vault.getAbstractFileByPath(newPath);
              if (!existing) {
                const folderAf = this.plugin.app.vault.getAbstractFileByPath(oldPath);
                if (folderAf) {
                  const onUnhandledRej = (ev) => {
                    try {
                      const r = ev && ev.reason;
                      if (!r)
                        return;
                      if (r && r.code === "ENOENT" && typeof r.message === "string" && r.message.includes(oldPath)) {
                        try {
                          ev.preventDefault && ev.preventDefault();
                        } catch (e) {
                        }
                      }
                    } catch (e) {
                    }
                  };
                  try {
                    if (typeof window !== "undefined" && window && window.addEventListener) {
                      window.addEventListener("unhandledrejection", onUnhandledRej);
                    }
                    try {
                      if (this.plugin.app.fileManager && typeof this.plugin.app.fileManager.renameFile === "function") {
                        await this.plugin.app.fileManager.renameFile(folderAf, newPath);
                      } else {
                        await this.plugin.app.vault.rename(folderAf, newPath);
                      }
                    } finally {
                      try {
                        await new Promise((r) => setTimeout(r, 250));
                      } catch (e) {
                      }
                    }
                    try {
                      await this.plugin.waitForFolderSync(newPath, 40);
                    } catch (e) {
                    }
                    const checkAf = this.plugin.app.vault.getAbstractFileByPath(newPath);
                    if (checkAf) {
                      try {
                        this.book.path = newPath;
                      } catch (e) {
                      }
                      if (Array.isArray(this.plugin.booksIndex)) {
                        const idx2 = this.plugin.booksIndex.findIndex((b) => b && b.path === oldPath);
                        if (idx2 !== -1) {
                          this.plugin.booksIndex[idx2].path = newPath;
                          this.plugin.booksIndex[idx2].name = newTitle;
                        }
                      }
                      if (this.plugin.activeBook && this.plugin.activeBook.path === oldPath) {
                        this.plugin.activeBook.path = newPath;
                        this.plugin.activeBook.name = newTitle;
                        try {
                          this.plugin.settings = this.plugin.settings || {};
                          this.plugin.settings.lastActiveBookPath = newPath;
                          await this.plugin.saveSettings();
                        } catch (e) {
                        }
                      }
                    } else {
                      console.warn("rename succeeded but new folder not visible yet", newPath);
                    }
                  } catch (e) {
                    console.warn("folder rename failed", e);
                  } finally {
                    try {
                      if (typeof window !== "undefined" && window && window.removeEventListener)
                        window.removeEventListener("unhandledrejection", onUnhandledRej);
                    } catch (e) {
                    }
                  }
                }
              } else {
                console.warn("target folder already exists, skipping rename", newPath);
              }
            }
          } catch (e) {
            console.warn("rename attempt failed", e);
          }
          try {
            document.dispatchEvent(new CustomEvent("novelist:book-updated", { detail: { path: this.book.path } }));
          } catch (e) {
          }
          await this.plugin.refresh();
          this.plugin.rerenderViews();
          this.close();
        };
      }
    };
  }
});

// src/modals/manageBooksModal.js
var manageBooksModal_exports = {};
__export(manageBooksModal_exports, {
  ManageBooksModal: () => ManageBooksModal
});
function getProjectTypeIcon2(plugin, projectType) {
  var _a;
  const templates = ((_a = plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
  const template = templates.find((t) => t.id === projectType);
  if (template == null ? void 0 : template.icon)
    return template.icon;
  if (projectType === PROJECT_TYPES.BOOK)
    return "book";
  if (projectType === PROJECT_TYPES.SCRIPT)
    return "tv";
  if (projectType === PROJECT_TYPES.FILM)
    return "clapperboard";
  if (projectType === PROJECT_TYPES.ESSAY)
    return "newspaper";
  return "book";
}
var Modal6, TFile5, setIcon3, ManageBooksModal;
var init_manageBooksModal = __esm({
  "src/modals/manageBooksModal.js"() {
    init_constants();
    init_confirmModal();
    init_editBookModal();
    ({ Modal: Modal6, TFile: TFile5, setIcon: setIcon3 } = require("obsidian"));
    ManageBooksModal = class extends Modal6 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        this.modalEl.style.width = "750px";
        this.modalEl.style.maxWidth = "90vw";
        contentEl.createEl("h2", { text: "Manage projects" });
        const search = contentEl.createEl("input", {
          type: "text",
          placeholder: "Search books...",
          cls: "folio-manage-search"
        });
        const list = contentEl.createDiv({ cls: "folio-manage-list" });
        const formatTarget = (n) => {
          if (!n)
            return "\u2014";
          const num = Number(n) || 0;
          if (num >= 1e3) {
            const k = num / 1e3;
            return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
          }
          return String(num);
        };
        const renderList = async (filter) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
          list.empty();
          const seen = /* @__PURE__ */ new Set();
          for (const book of this.plugin.booksIndex) {
            if (!book || !book.path)
              continue;
            if (seen.has(book.path))
              continue;
            seen.add(book.path);
            let cfg = {};
            try {
              cfg = await this.plugin.loadBookConfig(book) || {};
            } catch (e) {
            }
            const subtitle = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.subtitle) || "";
            const authors = Array.isArray((_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.author) ? cfg.basic.author.join(", ") : ((_c = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _c.author) || "";
            const desc = ((_d = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _d.desc) || ((_e = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _e.description) || "";
            const totalWords = ((_f = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _f.total_words) || 0;
            const targetWords = Number(((_g = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _g.target_total_words) || ((_h = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _h.targetWordCount) || 0) || 0;
            const displayTitle = cfg && cfg.basic && cfg.basic.title ? cfg.basic.title : book.name || "";
            const q = filter ? String(filter).trim().toLowerCase() : "";
            if (q) {
              const fields = [displayTitle || book.name || "", subtitle || "", authors || "", desc || ""];
              const matches = fields.some((f) => {
                const s = String(f).toLowerCase();
                if (s.startsWith(q))
                  return true;
                return s.split(/\s+/).some((w) => w.startsWith(q));
              });
              if (!matches)
                continue;
            }
            const card = list.createDiv({ cls: "folio-manage-card" });
            const left = card.createDiv({ cls: "folio-manage-left" });
            const right = card.createDiv({ cls: "folio-manage-right" });
            const coverWrap = left.createDiv({ cls: "folio-manage-cover" });
            try {
              const coverFile = book.cover instanceof TFile5 ? book.cover : book.cover ? this.plugin.app.vault.getAbstractFileByPath(book.cover) : null;
              if (coverFile instanceof TFile5) {
                const url = this.plugin.app.vault.getResourcePath(coverFile);
                coverWrap.style.backgroundImage = `url("${url}")`;
              }
            } catch (e) {
            }
            try {
              const coverFile = book.cover instanceof TFile5 ? book.cover : book.cover ? this.plugin.app.vault.getAbstractFileByPath(book.cover) : null;
              if (!(coverFile instanceof TFile5)) {
                coverWrap.addClass("folio-manage-cover-placeholder");
                const iconEl = coverWrap.createDiv({ cls: "folio-manage-cover-icon" });
                const projectType2 = ((_i = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _i.projectType) || PROJECT_TYPES.BOOK;
                const iconName = getProjectTypeIcon2(this.plugin, projectType2);
                setIcon3(iconEl, iconName);
              }
            } catch (e) {
            }
            const titleRow = right.createDiv({ cls: "folio-manage-title-row" });
            titleRow.createDiv({ text: displayTitle || book.name || "Untitled", cls: "folio-manage-title" });
            const actions = titleRow.createDiv({ cls: "folio-manage-actions" });
            const deleteBtn = actions.createEl("button", { text: "Delete", cls: "mod-danger" });
            const editBtn = actions.createEl("button", { text: "Edit" });
            const metaGrid = right.createDiv({ cls: "folio-manage-meta-grid" });
            const labelsCol = metaGrid.createDiv({ cls: "folio-manage-labels" });
            const valuesCol = metaGrid.createDiv({ cls: "folio-manage-values" });
            const projectType = ((_j = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _j.projectType) || PROJECT_TYPES.BOOK;
            const typeLabel = projectType === PROJECT_TYPES.BOOK ? "Book" : projectType === PROJECT_TYPES.SCRIPT ? "TV Show" : projectType === PROJECT_TYPES.FILM ? "Film" : projectType === PROJECT_TYPES.ESSAY ? "Essay" : "Book";
            labelsCol.createEl("div", { text: "Type", cls: "folio-manage-label" });
            valuesCol.createEl("div", { text: typeLabel, cls: "folio-manage-author" });
            labelsCol.createEl("div", { text: "Author", cls: "folio-manage-label" });
            valuesCol.createEl("div", { text: authors || "\u2014", cls: "folio-manage-author" });
            labelsCol.createEl("div", { text: "Description", cls: "folio-manage-label" });
            const truncateToWords = (text, wordLimit) => {
              if (!text)
                return "\u2014";
              const words = text.trim().split(/\s+/);
              if (words.length <= wordLimit)
                return text;
              return words.slice(0, wordLimit).join(" ") + "...";
            };
            const short = truncateToWords(desc, 5);
            valuesCol.createEl("div", { text: short, cls: "folio-manage-desc" });
            labelsCol.createEl("div", { text: "Progress", cls: "folio-manage-label" });
            valuesCol.createEl("div", { text: `${totalWords} / ${formatTarget(targetWords)}`, cls: "folio-manage-progress" });
            deleteBtn.onclick = async () => {
              const self = this;
              const modal = new ConfirmModal(this.plugin.app, {
                title: `Delete ${book.name}`,
                message: `Delete book "${book.name}" and all its files? This cannot be undone.`,
                confirmText: "Delete",
                onConfirm: async () => {
                  try {
                    await self.plugin.deleteFolderRecursive(book.path);
                  } catch (e) {
                    console.warn("delete book failed", e);
                  }
                  await self.plugin.refresh();
                  self.close();
                }
              });
              modal.open();
            };
            editBtn.onclick = () => {
              new EditBookModal(this.plugin, book).open();
            };
          }
          if (!list.children || list.children.length === 0) {
            const empty = list.createDiv({ cls: "folio-manage-empty" });
            empty.createEl("div", { text: "No books found" });
          }
        };
        search.addEventListener("input", (e) => {
          renderList(e.target.value);
        });
        this._onBookUpdated = (ev) => {
          try {
            renderList(search.value);
          } catch (e) {
          }
        };
        document.addEventListener("novelist:book-updated", this._onBookUpdated);
        await renderList("");
      }
      onClose() {
        try {
          document.removeEventListener("novelist:book-updated", this._onBookUpdated);
        } catch (e) {
        }
      }
    };
  }
});

// src/modals/helpModal.js
var helpModal_exports = {};
__export(helpModal_exports, {
  HelpModal: () => HelpModal
});
var Modal7, HelpModal;
var init_helpModal = __esm({
  "src/modals/helpModal.js"() {
    ({ Modal: Modal7 } = require("obsidian"));
    HelpModal = class extends Modal7 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Help" });
        contentEl.createEl("p", { text: "TBD" });
      }
    };
  }
});

// src/modals/textInputModal.js
var textInputModal_exports = {};
__export(textInputModal_exports, {
  TextInputModal: () => TextInputModal
});
var Modal8, TextInputModal;
var init_textInputModal = __esm({
  "src/modals/textInputModal.js"() {
    ({ Modal: Modal8 } = require("obsidian"));
    TextInputModal = class extends Modal8 {
      constructor(app, { title, placeholder, cta, onSubmit }) {
        super(app);
        this.title = title;
        this.placeholder = placeholder;
        this.cta = cta;
        this.onSubmit = onSubmit;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: this.title });
        const input = contentEl.createEl("input", {
          type: "text",
          placeholder: this.placeholder
        });
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", {
          text: "Cancel"
        });
        const confirmBtn = actions.createEl("button", {
          text: this.cta,
          cls: "mod-cta"
        });
        cancelBtn.onclick = () => this.close();
        confirmBtn.onclick = () => {
          const value = input.value.trim();
          if (!value)
            return;
          this.onSubmit(value);
          this.close();
        };
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            confirmBtn.click();
          } else if (e.key === "Escape") {
            this.close();
          }
        });
        input.focus();
      }
    };
  }
});

// src/services/configService.js
init_constants();
var ConfigService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Load full project config from book-config.json inside misc folder
   */
  async loadProjectConfig(project) {
    try {
      let filePath = `${project.path}/misc/project-config.json`;
      let f = this.app.vault.getAbstractFileByPath(filePath);
      if (!f) {
        filePath = `${project.path}/misc/book-config.json`;
        f = this.app.vault.getAbstractFileByPath(filePath);
      }
      if (!f)
        return null;
      const content = await this.app.vault.read(f);
      return JSON.parse(content);
    } catch (e) {
      if (!e || e.code === "ENOENT")
        return null;
      console.warn("loadProjectConfig failed", e);
      return null;
    }
  }
  // Alias for backwards compatibility
  async loadBookConfig(book) {
    return this.loadProjectConfig(book);
  }
  /**
   * Save full project config to book-config.json inside misc folder
   * Performs intelligent merge with existing config to avoid data loss
   */
  async saveProjectConfig(project, config) {
    try {
      const filePath = `${project.path}/misc/project-config.json`;
      const miscDir = `${project.path}/misc`;
      const legacyPath = `${project.path}/misc/book-config.json`;
      const legacyFile = this.app.vault.getAbstractFileByPath(legacyPath);
      if (legacyFile) {
        const newFile = this.app.vault.getAbstractFileByPath(filePath);
        if (!newFile) {
          await this.app.vault.rename(legacyFile, filePath);
        }
      }
      try {
        const existingMisc = this.app.vault.getAbstractFileByPath(miscDir);
        if (!existingMisc) {
          await this.app.vault.createFolder(miscDir);
        }
      } catch (e) {
      }
      const f = this.app.vault.getAbstractFileByPath(filePath);
      let finalCfg = config || {};
      if (f) {
        try {
          const existingRaw = await this.app.vault.read(f);
          const existing = JSON.parse(existingRaw || "{}");
          const mergeObjects = (base, incoming) => {
            const out = Object.assign({}, base || {});
            if (!incoming)
              return out;
            for (const k of Object.keys(incoming)) {
              const v = incoming[k];
              if (v === void 0 || v === null)
                continue;
              if (Array.isArray(v)) {
                if (v.length > 0)
                  out[k] = v;
              } else if (typeof v === "object") {
                out[k] = mergeObjects(base ? base[k] : void 0, v);
              } else {
                if (typeof v === "string") {
                  if (v === "" && base && typeof base[k] === "string" && base[k].trim() !== "") {
                    out[k] = base[k];
                  } else {
                    out[k] = v;
                  }
                } else {
                  out[k] = v;
                }
              }
            }
            return out;
          };
          const merged = Object.assign({}, existing || {});
          merged.basic = mergeObjects(existing.basic, finalCfg.basic);
          merged.stats = mergeObjects(existing.stats, finalCfg.stats);
          for (const k of Object.keys(finalCfg)) {
            if (k !== "basic" && k !== "stats")
              merged[k] = finalCfg[k];
          }
          finalCfg = merged;
        } catch (e) {
          finalCfg = config || {};
        }
        const content = JSON.stringify(finalCfg || {}, null, 2);
        await this.app.vault.modify(f, content);
      } else {
        const content = JSON.stringify(finalCfg || {}, null, 2);
        await this.app.vault.create(filePath, content);
      }
      return true;
    } catch (e) {
      console.warn("saveProjectConfig failed", e);
      return false;
    }
  }
  // Alias for backwards compatibility
  async saveBookConfig(book, config) {
    return this.saveProjectConfig(book, config);
  }
  /**
   * Load project metadata (simplified view of config)
   */
  async loadProjectMeta(project) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    try {
      const cfg = await this.loadProjectConfig(project);
      if (!cfg)
        return null;
      return {
        title: ((_a = cfg.basic) == null ? void 0 : _a.title) || "",
        author: ((_b = cfg.basic) == null ? void 0 : _b.author) || [],
        subtitle: ((_c = cfg.basic) == null ? void 0 : _c.subtitle) || "",
        description: ((_d = cfg.basic) == null ? void 0 : _d.desc) || "",
        uuid: ((_e = cfg.basic) == null ? void 0 : _e.uuid) || "",
        created_at: ((_f = cfg.basic) == null ? void 0 : _f.created_at) || new Date().toISOString(),
        target_words: ((_g = cfg.stats) == null ? void 0 : _g.target_total_words) || 0,
        projectType: ((_h = cfg.basic) == null ? void 0 : _h.projectType) || "book"
      };
    } catch (e) {
      console.warn("loadBookMeta failed", e);
      return null;
    }
  }
  /**
   * Create a new book config with default structure
   */
  createDefaultConfig(title, author) {
    const uuid = this.generateUUID();
    const now = new Date().toISOString();
    return {
      basic: {
        title: title || "",
        author: author ? [author] : [],
        subtitle: "",
        desc: "",
        uuid,
        created_at: now
      },
      structure: {
        tree: []
      },
      stats: {
        total_words: 0,
        target_total_words: 1e4,
        progress_by_words: 0,
        progress_by_chapter: 0,
        daily_words: {},
        writing_days: 0,
        average_daily_words: 0,
        last_writing_date: now,
        last_modified: now,
        per_chapter: {}
      },
      export: {
        default_format: "pdf",
        template: "default",
        include_cover: true
      }
    };
  }
  /**
   * Generate a simple UUID
   */
  generateUUID() {
    const timestamp = Date.now().toString(16);
    const random = Math.random().toString(36).substr(2, 9);
    return `${timestamp}-${random}`;
  }
};

// src/services/treeService.js
var import_obsidian = require("obsidian");
var TreeService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Generate unique node ID
   */
  generateNodeId() {
    return `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Build tree from filesystem (sync tree structure with actual files/folders)
   * Merges with existing config to preserve order, IDs, and metadata
   */
  async buildTreeFromFilesystem(bookFolder) {
    var _a;
    try {
      const cfg = await this.configService.loadBookConfig({ path: bookFolder.path }) || {};
      const existingTree = ((_a = cfg == null ? void 0 : cfg.structure) == null ? void 0 : _a.tree) || [];
      const existingMap = /* @__PURE__ */ new Map();
      const mapNodes = (nodes2) => {
        for (const node of nodes2) {
          existingMap.set(node.path, node);
          if (node.children)
            mapNodes(node.children);
        }
      };
      mapNodes(existingTree);
      const buildNode = (item, order) => {
        var _a2, _b, _c;
        const relativePath = item.path.replace(bookFolder.path + "/", "");
        const existing = existingMap.get(relativePath);
        if (item instanceof import_obsidian.TFile) {
          const node = {
            id: (existing == null ? void 0 : existing.id) || this.generateNodeId(),
            title: (existing == null ? void 0 : existing.title) || item.basename,
            type: item.extension === "canvas" ? "canvas" : "file",
            path: relativePath,
            order: (_a2 = existing == null ? void 0 : existing.order) != null ? _a2 : order,
            exclude: (existing == null ? void 0 : existing.exclude) || false,
            include: (existing == null ? void 0 : existing.include) || false,
            completed: (existing == null ? void 0 : existing.completed) || false,
            created_at: (existing == null ? void 0 : existing.created_at) || new Date().toISOString(),
            last_modified: new Date().toISOString()
          };
          if (existing == null ? void 0 : existing.icon)
            node.icon = existing.icon;
          return node;
        } else if (item instanceof import_obsidian.TFolder) {
          const folderChildren = (item.children || []).filter((child) => !(child instanceof import_obsidian.TFolder && child.name === "misc"));
          const childNodes = folderChildren.map((child) => buildNode(child, 0));
          const knownFolderOrder = {
            "concept": 1,
            "structure": 2,
            "faces": 3,
            "places": 4,
            "objects": 5,
            "documentation": 6,
            "research": 1,
            "show dossier": 1,
            "episode 1": 2
          };
          childNodes.sort((a, b) => {
            if (a.order && b.order)
              return a.order - b.order;
            const aKnown = knownFolderOrder[a.title.toLowerCase()];
            const bKnown = knownFolderOrder[b.title.toLowerCase()];
            if (aKnown && bKnown)
              return aKnown - bKnown;
            if (aKnown)
              return -1;
            if (bKnown)
              return 1;
            return a.title.localeCompare(b.title);
          });
          childNodes.forEach((node2, idx) => node2.order = idx + 1);
          const children = childNodes;
          const node = {
            id: (existing == null ? void 0 : existing.id) || this.generateNodeId(),
            title: (existing == null ? void 0 : existing.title) || item.name,
            type: "group",
            path: relativePath,
            order: (_b = existing == null ? void 0 : existing.order) != null ? _b : order,
            is_expanded: (_c = existing == null ? void 0 : existing.is_expanded) != null ? _c : false,
            created_at: (existing == null ? void 0 : existing.created_at) || new Date().toISOString(),
            last_modified: new Date().toISOString(),
            children
          };
          if (existing == null ? void 0 : existing.icon)
            node.icon = existing.icon;
          return node;
        }
      };
      const tree = [];
      const fsChildren = (bookFolder.children || []).filter((child) => !(child instanceof import_obsidian.TFolder && child.name === "misc"));
      const nodes = fsChildren.map((child) => buildNode(child, 0));
      const knownRootOrder = {
        "show dossier": 1,
        "episode 1": 2,
        "moodboard": 1,
        "preface": 2,
        "outline": 3,
        "volume 1": 4,
        "afterword": 5,
        "sequence 1": 3,
        "research": 1,
        "manuscript": 3
      };
      nodes.sort((a, b) => {
        if (a.order && b.order)
          return a.order - b.order;
        const aKnown = knownRootOrder[a.title.toLowerCase()];
        const bKnown = knownRootOrder[b.title.toLowerCase()];
        if (aKnown && bKnown)
          return aKnown - bKnown;
        if (aKnown)
          return -1;
        if (bKnown)
          return 1;
        return a.title.localeCompare(b.title);
      });
      let nextOrder = Math.max(0, ...nodes.map((n) => n.order || 0)) + 1;
      nodes.forEach((node) => {
        if (!node.order || node.order === 0) {
          node.order = nextOrder++;
        }
        tree.push(node);
      });
      console.log("Built tree from filesystem:", tree);
      return tree;
    } catch (e) {
      console.warn("buildTreeFromFilesystem failed", e);
      return [];
    }
  }
  /**
   * Reorder tree nodes after drag and drop
   * Handles physical file movement in vault when parent changes
   */
  async reorderTreeNodes(book, draggedNodeId, targetNodeId, position) {
    try {
      const cfg = await this.configService.loadBookConfig(book) || {};
      if (!cfg.structure)
        cfg.structure = {};
      if (!cfg.structure.tree)
        cfg.structure.tree = [];
      const tree = cfg.structure.tree;
      const findNode = (nodes, id, parent = null) => {
        for (let i = 0; i < nodes.length; i++) {
          if (nodes[i].id === id) {
            return { node: nodes[i], parent, index: i, siblings: nodes };
          }
          if (nodes[i].children) {
            const result = findNode(nodes[i].children, id, nodes[i]);
            if (result)
              return result;
          }
        }
        return null;
      };
      const draggedInfo = findNode(tree, draggedNodeId);
      const targetInfo = findNode(tree, targetNodeId);
      if (!draggedInfo || !targetInfo) {
        console.warn("Could not find nodes for reorder", { draggedNodeId, targetNodeId });
        return false;
      }
      draggedInfo.siblings.splice(draggedInfo.index, 1);
      if (position === "inside" && targetInfo.node.type === "group") {
        const oldPath = `${book.path}/${draggedInfo.node.path}`;
        const fileName = draggedInfo.node.path.split("/").pop();
        const newPath = `${targetInfo.node.path}/${fileName}`;
        try {
          const fileToMove = this.app.vault.getAbstractFileByPath(oldPath);
          if (fileToMove) {
            await this.app.fileManager.renameFile(fileToMove, `${book.path}/${newPath}`);
            draggedInfo.node.path = newPath;
          }
        } catch (e) {
          console.warn("Failed to move file in vault:", e);
          return false;
        }
        if (!targetInfo.node.children)
          targetInfo.node.children = [];
        targetInfo.node.children.push(draggedInfo.node);
      } else {
        const draggedParentPath = draggedInfo.node.path.split("/").slice(0, -1).join("/");
        const targetParentPath = targetInfo.node.path.split("/").slice(0, -1).join("/");
        if (draggedParentPath !== targetParentPath) {
          const oldPath = `${book.path}/${draggedInfo.node.path}`;
          const fileName = draggedInfo.node.path.split("/").pop();
          const newPath = targetParentPath ? `${targetParentPath}/${fileName}` : fileName;
          try {
            const fileToMove = this.app.vault.getAbstractFileByPath(oldPath);
            if (fileToMove) {
              await this.app.fileManager.renameFile(fileToMove, `${book.path}/${newPath}`);
              draggedInfo.node.path = newPath;
            }
          } catch (e) {
            console.warn("Failed to move file to new level:", e);
            return false;
          }
        }
        const newTargetIndex = targetInfo.siblings.findIndex((n) => n.id === targetNodeId);
        if (newTargetIndex === -1)
          return false;
        const insertIndex = position === "before" ? newTargetIndex : newTargetIndex + 1;
        targetInfo.siblings.splice(insertIndex, 0, draggedInfo.node);
      }
      const reorderNodes = (nodes) => {
        nodes.forEach((node, idx) => {
          node.order = idx + 1;
          node.last_modified = new Date().toISOString();
          if (node.children)
            reorderNodes(node.children);
        });
      };
      reorderNodes(tree);
      await this.configService.saveBookConfig(book, cfg);
      return true;
    } catch (e) {
      console.warn("reorderTreeNodes failed", e);
      return false;
    }
  }
  /**
   * Toggle exclude/include from stats for a file or folder
   * Updates both frontmatter and config tree
   * For folders, recursively updates all children
   */
  async toggleExcludeFromStats(book, file, exclude) {
    return this.setStatsOverride(book, file, { exclude });
  }
  /**
   * Set explicit include/exclude overrides for stats
   * include/exclude are explicit overrides (exclude wins at compute time)
   */
  async setStatsOverride(book, file, { include, exclude } = {}) {
    var _a;
    try {
      const isFolder = file.children !== void 0;
      if (isFolder) {
        if (typeof exclude === "boolean") {
          await this.excludeFolderFromStats(book, file, exclude);
        }
      } else {
        if (typeof exclude === "boolean") {
          await this.app.fileManager.processFrontMatter(file, (fm) => {
            fm.exclude_from_stats = exclude;
          });
        }
      }
      const cfg = await this.configService.loadBookConfig(book) || {};
      if (!((_a = cfg.structure) == null ? void 0 : _a.tree))
        return;
      const relativePath = file.path.replace(book.path + "/", "");
      const updateNode = (nodes) => {
        for (const node of nodes) {
          if (node.path === relativePath) {
            if (typeof exclude === "boolean") {
              node.exclude = exclude;
              if (exclude)
                node.include = false;
            }
            if (typeof include === "boolean") {
              node.include = include;
              if (include)
                node.exclude = false;
            }
            node.last_modified = new Date().toISOString();
            if (isFolder && node.children) {
              if (typeof exclude === "boolean") {
                this.markAllChildrenExcluded(node.children, exclude);
              }
            }
            return true;
          }
          if (node.children && updateNode(node.children)) {
            return true;
          }
        }
        return false;
      };
      if (updateNode(cfg.structure.tree)) {
        await this.configService.saveBookConfig(book, cfg);
      }
    } catch (e) {
      console.warn("setStatsOverride failed", e);
    }
  }
  /**
   * Helper: Mark all children nodes as excluded/included in config
   */
  markAllChildrenExcluded(children, exclude) {
    for (const node of children) {
      node.exclude = exclude;
      node.last_modified = new Date().toISOString();
      if (node.children) {
        this.markAllChildrenExcluded(node.children, exclude);
      }
    }
  }
  /**
   * Helper: Recursively exclude all files in a folder from stats
   */
  async excludeFolderFromStats(book, folder, exclude) {
    for (const child of folder.children || []) {
      if (child.children !== void 0) {
        await this.excludeFolderFromStats(book, child, exclude);
      } else if (child.extension === "md") {
        try {
          await this.app.fileManager.processFrontMatter(child, (fm) => {
            fm.exclude_from_stats = exclude;
          });
        } catch (e) {
          console.warn("Failed to update frontmatter for", child.path, e);
        }
      }
    }
  }
};

// src/services/statsService.js
init_constants();
var StatsService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Count words in text
   */
  countWords(text) {
    if (!text)
      return 0;
    let content = text;
    const frontmatterRegex = /^---\s*\n[\s\S]*?\n---\s*\n/;
    content = content.replace(frontmatterRegex, "");
    content = content.replace(/^#{1,6}\s+/gm, "").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/\*([^*]+)\*/g, "$1").replace(/\_\_([^_]+)\_\_/g, "$1").replace(/\_([^_]+)\_/g, "$1").replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/^>\s+/gm, "");
    const parts = content.replace(/\n/g, " ").split(/\s+/).filter(Boolean);
    return parts.length;
  }
  /**
   * Get today's date key (YYYY-MM-DD)
   */
  getTodayKey() {
    return new Date().toISOString().slice(0, 10);
  }
  /**
   * Build sets of explicit include/exclude paths from the config tree
   * Includes children when a parent folder is included/excluded
   */
  buildStatsOverrideSets(configTree) {
    const excludedPaths = /* @__PURE__ */ new Set();
    const includedPaths = /* @__PURE__ */ new Set();
    const traverse = (nodes, parentExcluded = false, parentIncluded = false) => {
      for (const node of nodes) {
        const isExcluded = parentExcluded || node.exclude;
        const isIncluded = parentIncluded || node.include;
        if (node.type !== "group") {
          if (isExcluded) {
            excludedPaths.add(node.path);
          }
          if (isIncluded) {
            includedPaths.add(node.path);
          }
        }
        if (node.children) {
          traverse(node.children, isExcluded, isIncluded);
        }
      }
    };
    traverse(configTree || []);
    return { excludedPaths, includedPaths };
  }
  /**
   * Collect all markdown files recursively from a folder
   */
  collectMarkdownFiles(folder) {
    const files = [];
    const collect = (item) => {
      if (item.children) {
        for (const child of item.children) {
          collect(child);
        }
      } else if (item.extension === "md") {
        files.push(item);
      }
    };
    collect(folder);
    return files;
  }
  /**
   * Stats rules for built-in project types
   * Custom project types default to include-all
   * @param {string} projectType
   */
  getStatsRulesForProjectType(projectType) {
    const builtInTypes = new Set(Object.values(PROJECT_TYPES));
    if (!builtInTypes.has(projectType)) {
      return { includeAllByDefault: true, includePrefixes: [] };
    }
    switch (projectType) {
      case PROJECT_TYPES.SCRIPT:
      case PROJECT_TYPES.FILM:
        return { includeAllByDefault: true, includePrefixes: ["scene"] };
      case PROJECT_TYPES.ESSAY:
        return { includeAllByDefault: true, includePrefixes: ["manuscript"] };
      case PROJECT_TYPES.BOOK:
      default:
        return { includeAllByDefault: false, includePrefixes: ["chapter"] };
    }
  }
  /**
   * Decide if a file should count toward stats
   * Explicit exclude overrides explicit include; default rules apply last.
   * @param {TFile} file
   * @param {string} bookPath
   * @param {string} projectType
   * @param {{ includeAllByDefault: boolean, includePrefixes: string[] }} rules
   * @param {{ excludedPaths: Set<string>, includedPaths: Set<string> }} overrides
   */
  shouldCountFileForStats(file, bookPath, projectType, rules, overrides) {
    var _a, _b;
    const rel = file.path.replace(bookPath + "/", "");
    if (rel.startsWith("misc/"))
      return false;
    if ((_a = overrides == null ? void 0 : overrides.excludedPaths) == null ? void 0 : _a.has(rel))
      return false;
    if ((_b = overrides == null ? void 0 : overrides.includedPaths) == null ? void 0 : _b.has(rel))
      return true;
    if (rules == null ? void 0 : rules.includeAllByDefault)
      return true;
    const name = (file.basename || "").toLowerCase();
    const prefixes = (rules == null ? void 0 : rules.includePrefixes) || [];
    return prefixes.some((prefix) => name.startsWith(prefix));
  }
  /**
   * Filter files based on project type rules and overrides
   * 
   * @param {Array} files - Array of TFile objects
   * @param {string} bookPath - The book's root path
   * @param {string} projectType - The project type
   * @param {{ excludedPaths: Set<string>, includedPaths: Set<string> }} overrides
   */
  filterFilesByProjectType(files, bookPath, projectType, overrides) {
    const rules = this.getStatsRulesForProjectType(projectType);
    return files.filter((f) => {
      return this.shouldCountFileForStats(f, bookPath, projectType, rules, overrides);
    });
  }
  /**
   * Compute basic stats for a book and persist into book-config.json.stats
   */
  async computeAndSaveStatsForBook(book) {
    var _a, _b;
    try {
      const folder = this.app.vault.getAbstractFileByPath(book.path);
      if (!folder)
        return;
      let cfg = await this.configService.loadBookConfig(book) || {};
      const projectType = ((_a = cfg.basic) == null ? void 0 : _a.projectType) || PROJECT_TYPES.BOOK;
      const overrides = this.buildStatsOverrideSets(((_b = cfg.structure) == null ? void 0 : _b.tree) || []);
      const allMdFiles = this.collectMarkdownFiles(folder);
      const mdFiles = this.filterFilesByProjectType(allMdFiles, book.path, projectType, overrides);
      const perChapter = {};
      let total = 0;
      for (const f of mdFiles) {
        try {
          const content = await this.app.vault.read(f);
          const wc = this.countWords(content);
          perChapter[f.path.replace(book.path + "/", "")] = wc;
          total += wc;
        } catch (e) {
        }
      }
      cfg.basic = cfg.basic || { title: book.name };
      cfg.stats = cfg.stats || {};
      const today = this.getTodayKey();
      cfg.stats.daily_words = cfg.stats.daily_words || {};
      const previousTotal = Number(cfg.stats.total_words || 0);
      const delta = Math.max(0, total - previousTotal);
      if (delta > 0) {
        cfg.stats.daily_words[today] = (cfg.stats.daily_words[today] || 0) + delta;
      }
      cfg.stats.writing_days = Object.keys(cfg.stats.daily_words).length;
      const sumDaily = Object.values(cfg.stats.daily_words).reduce((a, b) => a + b, 0);
      cfg.stats.average_daily_words = cfg.stats.writing_days > 0 ? Math.round(sumDaily / cfg.stats.writing_days) : 0;
      cfg.stats.total_words = total;
      cfg.stats.per_chapter = perChapter;
      cfg.stats.last_writing_date = today;
      cfg.stats.last_modified = new Date().toISOString();
      const target = cfg.stats.target_total_words && Number(cfg.stats.target_total_words) || 0;
      cfg.stats.progress_by_words = target > 0 ? Math.round(total / target * 1e4) / 100 : 0;
      const totalCh = Object.keys(perChapter).length;
      const doneCh = Object.values(perChapter).filter((n) => n > 0).length;
      cfg.stats.progress_by_chapter = {
        completed: doneCh,
        total: totalCh,
        percent: totalCh > 0 ? Math.round(doneCh / totalCh * 1e4) / 100 : 0
      };
      await this.configService.saveBookConfig(book, { stats: cfg.stats });
      return cfg.stats;
    } catch (e) {
      console.warn("computeAndSaveStatsForBook failed", e);
      return null;
    }
  }
  /**
   * Sync chapter structure into stats baseline.
   * - Adds missing chapters with 0 words
   * - Removes deleted chapters from stats
   * - Removes excluded chapters from stats
   * DOES NOT recompute stats.
   */
  async syncChapterStatsBaseline(book) {
    var _a, _b;
    try {
      let cfg = await this.configService.loadBookConfig(book) || {};
      cfg.stats = cfg.stats || {};
      cfg.stats.per_chapter = cfg.stats.per_chapter || {};
      const projectType = ((_a = cfg.basic) == null ? void 0 : _a.projectType) || PROJECT_TYPES.BOOK;
      const overrides = this.buildStatsOverrideSets(((_b = cfg.structure) == null ? void 0 : _b.tree) || []);
      const folder = this.app.vault.getAbstractFileByPath(book.path);
      if (!folder)
        return;
      const allMdFiles = this.collectMarkdownFiles(folder);
      const mdFiles = this.filterFilesByProjectType(allMdFiles, book.path, projectType, overrides);
      const currentPaths = new Set(mdFiles.map((f) => f.path.replace(book.path + "/", "")));
      for (const relPath of currentPaths) {
        if (!(relPath in cfg.stats.per_chapter)) {
          cfg.stats.per_chapter[relPath] = 0;
        }
      }
      for (const storedPath of Object.keys(cfg.stats.per_chapter)) {
        if (!currentPaths.has(storedPath)) {
          delete cfg.stats.per_chapter[storedPath];
        }
      }
      cfg.stats.last_modified = new Date().toISOString();
      await this.configService.saveBookConfig(book, cfg);
    } catch (e) {
      console.warn("syncChapterStatsBaseline failed", e);
    }
  }
};

// src/services/bookService.js
var import_obsidian2 = require("obsidian");
init_constants();

// src/templates/project/book.js
function bookChapterTemplate({ title }) {
  return `---
projectType: book
---

`;
}

// src/templates/project/script.js
function scriptChapterTemplate({ title }) {
  return `---
projectType: script
cssclasses: md-screenplay
---

`;
}

// src/services/bookService.js
var BookService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Scan for all books in the base path
   */
  async scanBooks(basePath) {
    var _a;
    const base = this.app.vault.getAbstractFileByPath(basePath);
    if (!(base instanceof import_obsidian2.TFolder))
      return [];
    const booksIndex = [];
    const seenPaths = /* @__PURE__ */ new Set();
    for (const bookFolder of base.children) {
      if (!bookFolder || !bookFolder.path)
        continue;
      if (seenPaths.has(bookFolder.path))
        continue;
      seenPaths.add(bookFolder.path);
      if (!(bookFolder instanceof import_obsidian2.TFolder))
        continue;
      const book = {
        name: bookFolder.name,
        path: bookFolder.path,
        cover: null,
        volumes: []
      };
      try {
        const legacyMetaPath = `${bookFolder.path}/misc/metadata`;
        const legacyMetaAf = this.app.vault.getAbstractFileByPath(legacyMetaPath);
        if (legacyMetaAf) {
          await this.app.vault.delete(legacyMetaAf, true);
        }
      } catch (e) {
      }
      for (const child of bookFolder.children) {
        if (child instanceof import_obsidian2.TFolder && child.name === "misc") {
          continue;
        }
        if (child instanceof import_obsidian2.TFolder) {
          const volume = {
            name: child.name,
            path: child.path,
            chapters: [],
            collapsed: false
          };
          for (const f of child.children) {
            if (f instanceof import_obsidian2.TFile && f.extension === "md") {
              volume.chapters.push({
                name: f.basename,
                path: f.path
              });
            }
          }
          book.volumes.push(volume);
        }
      }
      try {
        const cfg = await this.configService.loadBookConfig({ path: book.path }) || {};
        const coverRel = (_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.cover;
        if (coverRel) {
          const coverPath = `${book.path}/${coverRel}`;
          const coverFile = this.app.vault.getAbstractFileByPath(coverPath);
          if (coverFile instanceof import_obsidian2.TFile) {
            book.cover = coverFile;
          }
        } else {
          const coverFolderPath = `${book.path}/misc/cover`;
          const cf = this.app.vault.getAbstractFileByPath(coverFolderPath);
          if (cf && cf.children && cf.children.length > 0) {
            const first = cf.children.find((c) => c instanceof import_obsidian2.TFile);
            if (first)
              book.cover = first;
          }
        }
      } catch (e) {
      }
      booksIndex.push(book);
    }
    booksIndex.sort((a, b) => a.name.localeCompare(b.name));
    return booksIndex;
  }
  /**
   * Create a new book with structure from template
   */
  async createBook(basePath, name, projectType = "book", templateStructure = null) {
    if (!name)
      return;
    const path = `${basePath}/${name}`;
    if (await this.app.vault.adapter.exists(path))
      return;
    await this.app.vault.createFolder(path);
    const miscPath = `${path}/misc`;
    const coverPath = `${miscPath}/cover`;
    await this.app.vault.createFolder(miscPath);
    await this.app.vault.createFolder(coverPath);
    try {
      const bookConfigPath = `${path}/misc/project-config.json`;
      const now = new Date().toISOString();
      const defaultTree = templateStructure ? this.buildTreeFromTemplateStructure(templateStructure, "", now) : this.getDefaultTreeForProjectType(projectType, now);
      const defaultConfig = {
        basic: {
          title: name,
          author: [],
          subtitle: "",
          desc: "",
          uuid: `${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 10)}`,
          created_at: now,
          projectType
          // Save project type
        },
        structure: {
          tree: defaultTree
        },
        stats: {
          total_words: 0,
          target_total_words: 1e4,
          progress_by_words: 0,
          progress_by_chapter: 0,
          daily_words: {},
          writing_days: 0,
          average_daily_words: 0,
          last_writing_date: now,
          last_modified: now
        },
        export: {
          default_format: "pdf",
          template: "default",
          include_cover: true
        }
      };
      if (!this.app.vault.getAbstractFileByPath(bookConfigPath)) {
        await this.app.vault.create(bookConfigPath, JSON.stringify(defaultConfig, null, 2));
      }
    } catch (e) {
      console.warn("createBook: failed to create project-config.json in misc", e);
    }
    const bookFolder = this.app.vault.getAbstractFileByPath(path);
    if (bookFolder instanceof import_obsidian2.TFolder) {
      if (templateStructure && templateStructure.length > 0) {
        await this.createStructureFromTemplate(bookFolder, templateStructure, projectType);
      } else {
        if (projectType === PROJECT_TYPES.SCRIPT) {
          await this.ensureScriptStructure(bookFolder);
        } else if (projectType === PROJECT_TYPES.FILM) {
          await this.ensureFilmStructure(bookFolder);
        } else if (projectType === PROJECT_TYPES.ESSAY) {
          await this.ensureEssayStructure(bookFolder);
        } else {
          await this.ensureBookBaseStructure(bookFolder);
        }
      }
    }
  }
  /**
   * Build tree config from simple template structure
   */
  buildTreeFromTemplateStructure(structure, parentPath, now) {
    let order = 1;
    return structure.map((item) => {
      const itemPath = parentPath ? `${parentPath}/${item.title}` : item.title;
      const id = `${item.title.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
      if (item.type === "folder") {
        const filePath = itemPath;
        const node = {
          id,
          title: item.title,
          type: "group",
          path: filePath,
          order: order++,
          default_status: "draft",
          is_expanded: false,
          created_at: now,
          last_modified: now,
          children: item.children ? this.buildTreeFromTemplateStructure(item.children, filePath, now) : []
        };
        if (item.icon)
          node.icon = item.icon;
        return node;
      } else if (item.type === "canvas") {
        const node = {
          id,
          title: item.title,
          type: "canvas",
          path: `${itemPath}.canvas`,
          order: order++,
          default_status: "draft",
          created_at: now,
          last_modified: now
        };
        if (item.icon)
          node.icon = item.icon;
        return node;
      } else {
        const node = {
          id,
          title: item.title,
          type: "file",
          path: `${itemPath}.md`,
          order: order++,
          default_status: "draft",
          created_at: now,
          last_modified: now
        };
        if (item.icon)
          node.icon = item.icon;
        return node;
      }
    });
  }
  /**
   * Create actual files and folders from template structure
   */
  async createStructureFromTemplate(bookFolder, structure, projectType) {
    const vault = this.app.vault;
    const createItems = async (items, parentPath) => {
      for (const item of items) {
        const itemPath = `${parentPath}/${item.title}`;
        if (item.type === "folder") {
          if (!vault.getAbstractFileByPath(itemPath)) {
            await vault.createFolder(itemPath);
          }
          if (item.children && item.children.length > 0) {
            await createItems(item.children, itemPath);
          }
        } else if (item.type === "canvas") {
          const canvasPath = `${itemPath}.canvas`;
          if (!vault.getAbstractFileByPath(canvasPath)) {
            await vault.create(canvasPath, '{"nodes":[],"edges":[]}');
          }
        } else {
          const filePath = `${itemPath}.md`;
          if (!vault.getAbstractFileByPath(filePath)) {
            const frontmatter = `---
projectType: ${projectType}
---

`;
            await vault.create(filePath, frontmatter);
          }
        }
      }
    };
    await createItems(structure, bookFolder.path);
  }
  /**
   * Get default tree structure for project type (legacy fallback)
   */
  getDefaultTreeForProjectType(projectType, now) {
    if (projectType === PROJECT_TYPES.SCRIPT) {
      return [
        {
          id: "series-framework",
          title: "Show Dossier",
          type: "group",
          path: "Show Dossier",
          order: 1,
          icon: "folder-open",
          default_status: "draft",
          is_expanded: false,
          created_at: now,
          last_modified: now,
          children: [
            { id: "concept", title: "Concept", type: "group", path: "Show Dossier/Concept", order: 1, icon: "lightbulb", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "structure", title: "Structure", type: "group", path: "Show Dossier/Structure", order: 2, icon: "list-tree", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "faces", title: "Faces", type: "group", path: "Show Dossier/Faces", order: 3, icon: "users", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "places", title: "Places", type: "group", path: "Show Dossier/Places", order: 4, icon: "map-pin", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "objects", title: "Objects", type: "group", path: "Show Dossier/Objects", order: 5, icon: "box", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "documentation", title: "Documentation", type: "group", path: "Show Dossier/Documentation", order: 6, icon: "archive", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] }
          ]
        },
        { id: "episode1", title: "Episode 1", type: "group", path: "Episode 1", order: 2, icon: "clapperboard", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] }
      ];
    } else if (projectType === PROJECT_TYPES.FILM) {
      return [
        { id: "moodboard", title: "Moodboard", type: "canvas", path: "Moodboard.canvas", order: 1, icon: "layout-dashboard", default_status: "draft", created_at: now, last_modified: now },
        { id: "outline", title: "Outline", type: "file", path: "Outline.md", order: 2, icon: "list", default_status: "draft", created_at: now, last_modified: now },
        { id: "sequence1", title: "Sequence 1", type: "group", path: "Sequence 1", order: 3, icon: "film", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] }
      ];
    } else if (projectType === PROJECT_TYPES.ESSAY) {
      return [
        {
          id: "research",
          title: "Research",
          type: "group",
          path: "Research",
          order: 1,
          icon: "archive",
          default_status: "draft",
          is_expanded: false,
          created_at: now,
          last_modified: now,
          children: [
            { id: "document1", title: "Document 1", type: "file", path: "Research/Document 1.md", order: 1, icon: "file", default_status: "draft", created_at: now, last_modified: now }
          ]
        },
        { id: "outline", title: "Outline", type: "file", path: "Outline.md", order: 2, icon: "list", default_status: "draft", created_at: now, last_modified: now },
        { id: "manuscript", title: "Manuscript", type: "file", path: "Manuscript.md", order: 3, icon: "scroll-text", default_status: "draft", created_at: now, last_modified: now }
      ];
    } else {
      return [
        { id: "moodboard", title: "Moodboard", type: "canvas", path: "Moodboard.canvas", order: 1, icon: "layout-dashboard", default_status: "draft", created_at: now, last_modified: now },
        { id: "preface", title: "Preface", type: "file", path: "Preface.md", order: 2, icon: "file", default_status: "draft", created_at: now, last_modified: now },
        { id: "outline", title: "Outline", type: "file", path: "Outline.md", order: 3, icon: "list", default_status: "draft", created_at: now, last_modified: now },
        { id: "volume1", title: "Volume 1", type: "group", path: "Volume 1", order: 4, icon: "folder-open", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
        { id: "afterword", title: "Afterword", type: "file", path: "Afterword.md", order: 5, icon: "file", default_status: "draft", created_at: now, last_modified: now }
      ];
    }
  }
  /**
   * Ensure essay project has minimal structure: Research folder, Document 1.md, Outline.md, Manuscript.md
   */
  async ensureEssayStructure(bookFolder) {
    const vault = this.app.vault;
    const researchPath = `${bookFolder.path}/Research`;
    if (!vault.getAbstractFileByPath(researchPath)) {
      await vault.createFolder(researchPath);
    }
    const document1Path = `${researchPath}/Document 1.md`;
    if (!vault.getAbstractFileByPath(document1Path)) {
      await vault.create(document1Path, `---
projectType: essay
---

`);
    }
    const outlinePath = `${bookFolder.path}/Outline.md`;
    if (!vault.getAbstractFileByPath(outlinePath)) {
      await vault.create(outlinePath, `---
projectType: essay
---

`);
    }
    const manuscriptPath = `${bookFolder.path}/Manuscript.md`;
    if (!vault.getAbstractFileByPath(manuscriptPath)) {
      await vault.create(manuscriptPath, `---
projectType: essay
---

`);
    }
  }
  /**
   * Ensure script project has screenplay-specific structure
   */
  async ensureScriptStructure(bookFolder) {
    const vault = this.app.vault;
    const biblePath = `${bookFolder.path}/Show Dossier`;
    if (!vault.getAbstractFileByPath(biblePath)) {
      await vault.createFolder(biblePath);
    }
    const conceptPath = `${biblePath}/Concept`;
    const structurePath = `${biblePath}/Structure`;
    const facesPath = `${biblePath}/Faces`;
    const placesPath = `${biblePath}/Places`;
    const objectsPath = `${biblePath}/Objects`;
    const documentationPath = `${biblePath}/Documentation`;
    if (!vault.getAbstractFileByPath(conceptPath)) {
      await vault.createFolder(conceptPath);
    }
    if (!vault.getAbstractFileByPath(structurePath)) {
      await vault.createFolder(structurePath);
    }
    if (!vault.getAbstractFileByPath(facesPath)) {
      await vault.createFolder(facesPath);
    }
    if (!vault.getAbstractFileByPath(placesPath)) {
      await vault.createFolder(placesPath);
    }
    if (!vault.getAbstractFileByPath(objectsPath)) {
      await vault.createFolder(objectsPath);
    }
    if (!vault.getAbstractFileByPath(documentationPath)) {
      await vault.createFolder(documentationPath);
    }
    const conceptFiles = ["Logline.md", "Synopsis.md"];
    for (const file of conceptFiles) {
      const filePath = `${conceptPath}/${file}`;
      if (!vault.getAbstractFileByPath(filePath)) {
        await vault.create(filePath, `---
projectType: script
---

`);
      }
    }
    const beatSheetPath = `${structurePath}/Beat Sheet.md`;
    if (!vault.getAbstractFileByPath(beatSheetPath)) {
      await vault.create(beatSheetPath, `---
projectType: script
---

`);
    }
    const researchPath = `${documentationPath}/Research.md`;
    if (!vault.getAbstractFileByPath(researchPath)) {
      await vault.create(researchPath, `---
projectType: script
---

`);
    }
    const character1Path = `${facesPath}/Character 1.md`;
    if (!vault.getAbstractFileByPath(character1Path)) {
      await vault.create(character1Path, `---
projectType: script
---

`);
    }
    const location1Path = `${placesPath}/Location 1.md`;
    if (!vault.getAbstractFileByPath(location1Path)) {
      await vault.create(location1Path, `---
projectType: script
---

`);
    }
    const prop1Path = `${objectsPath}/Prop 1.md`;
    if (!vault.getAbstractFileByPath(prop1Path)) {
      await vault.create(prop1Path, `---
projectType: script
---

`);
    }
    const episode1Path = `${bookFolder.path}/Episode 1`;
    if (!vault.getAbstractFileByPath(episode1Path)) {
      await vault.createFolder(episode1Path);
    }
    const scene1Path = `${episode1Path}/Scene 1.md`;
    if (!vault.getAbstractFileByPath(scene1Path)) {
      await vault.create(scene1Path, `---
projectType: script
---

`);
    }
  }
  /**
   * Ensure film project has simplified structure
   */
  async ensureFilmStructure(bookFolder) {
    const vault = this.app.vault;
    const moodboardPath = `${bookFolder.path}/Moodboard.canvas`;
    if (!vault.getAbstractFileByPath(moodboardPath)) {
      await vault.create(moodboardPath, '{"nodes":[],"edges":[]}');
    }
    const outlinePath = `${bookFolder.path}/Outline.md`;
    if (!vault.getAbstractFileByPath(outlinePath)) {
      await vault.create(outlinePath, `---
projectType: film
---

`);
    }
    const sequence1Path = `${bookFolder.path}/Sequence 1`;
    if (!vault.getAbstractFileByPath(sequence1Path)) {
      await vault.createFolder(sequence1Path);
    }
    const scene1Path = `${sequence1Path}/Scene 1.md`;
    if (!vault.getAbstractFileByPath(scene1Path)) {
      await vault.create(scene1Path, `---
projectType: film
---

`);
    }
  }
  /**
   * Ensure book has basic structure (Preface, Outline, etc.)
   */
  async ensureBookBaseStructure(bookFolder) {
    const vault = this.app.vault;
    const filesToCreate = ["Preface.md", "Outline.md", "Moodboard.canvas", "Afterword.md"];
    for (const file of filesToCreate) {
      const filePath = `${bookFolder.path}/${file}`;
      if (!vault.getAbstractFileByPath(filePath)) {
        await vault.create(filePath, "");
      }
    }
    const miscPath = `${bookFolder.path}/misc`;
    const coverPath = `${miscPath}/cover`;
    if (!vault.getAbstractFileByPath(miscPath)) {
      await vault.createFolder(miscPath);
    }
    if (!vault.getAbstractFileByPath(coverPath)) {
      await vault.createFolder(coverPath);
    }
    try {
      const bmPath = `${bookFolder.path}/misc/project-config.json`;
      const legacyPath = `${bookFolder.path}/misc/book-config.json`;
      const hasNew = vault.getAbstractFileByPath(bmPath);
      const hasLegacy = vault.getAbstractFileByPath(legacyPath);
      if (!hasNew && !hasLegacy) {
        const now = new Date().toISOString();
        const defaultConfig = {
          basic: {
            title: bookFolder.name,
            author: [],
            subtitle: "",
            desc: "",
            uuid: `${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 10)}`,
            created_at: now
          },
          structure: { tree: [] },
          stats: {
            total_words: 0,
            target_total_words: 1e4,
            progress_by_words: 0,
            progress_by_chapter: 0,
            daily_words: {},
            writing_days: 0,
            average_daily_words: 0,
            last_writing_date: now,
            last_modified: now
          },
          export: {
            default_format: "pdf",
            template: "default",
            include_cover: true
          }
        };
        await vault.create(bmPath, JSON.stringify(defaultConfig, null, 2));
      }
    } catch (e) {
      console.warn("ensureBookBaseStructure: failed to create project-config.json in misc", e);
    }
  }
  /**
   * Create a new volume (folder) in a book
   */
  async createVolume(book, name) {
    if (!name)
      return;
    const path = `${book.path}/${name}`;
    if (await this.app.vault.adapter.exists(path))
      return;
    await this.app.vault.createFolder(path);
  }
  /**
   * Create a new chapter (markdown file) in a volume
   */
  async createChapter(volume, name, projectType = "book") {
    if (!name)
      return;
    const path = `${volume.path}/${name}.md`;
    if (await this.app.vault.adapter.exists(path))
      return;
    const template = projectType === PROJECT_TYPES.SCRIPT ? scriptChapterTemplate : bookChapterTemplate;
    const content = template({ title: name });
    await this.app.vault.create(path, content);
  }
  /**
   * Check if a file is a volume folder
   */
  isVolumeFolder(file, booksIndex) {
    try {
      return booksIndex.some(
        (b) => b.volumes.some((v) => v.path === file.path)
      );
    } catch (e) {
      return false;
    }
  }
  /**
   * Check if a file is a chapter file
   */
  isChapterFile(file, booksIndex) {
    try {
      return booksIndex.some(
        (b) => b.volumes.some(
          (v) => v.chapters.some((c) => c.path === file.path)
        )
      );
    } catch (e) {
      return false;
    }
  }
};

// src/main.js
init_constants();

// src/views/folioView.js
var import_obsidian4 = require("obsidian");
init_constants();
function getProjectTypeIcon3(plugin, projectType) {
  var _a;
  const templates = ((_a = plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
  const template = templates.find((t) => t.id === projectType);
  if (template == null ? void 0 : template.icon)
    return template.icon;
  if (projectType === PROJECT_TYPES.BOOK)
    return "book";
  if (projectType === PROJECT_TYPES.SCRIPT)
    return "tv";
  if (projectType === PROJECT_TYPES.FILM)
    return "clapperboard";
  if (projectType === PROJECT_TYPES.ESSAY)
    return "newspaper";
  return "book";
}
var FolioView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this._isRendering = false;
    this._renderCounter = 0;
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Folio";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    this.render();
  }
  onClose() {
    if (this.plugin && this.plugin.novelistLeaf === this.leaf) {
      this.plugin.novelistLeaf = null;
    }
  }
  clearView() {
    try {
      this.contentEl.empty();
    } catch (e) {
    }
    this._isRendering = false;
  }
  // Render a filesystem-backed editorial tree for a book folder (Obsidian-safe)
  // Now with Book-Smith style drag & drop support
  // Get custom icon for specific folder/file names
  getCustomIcon(title, isExpanded = false, nodeType = "file") {
    const lowerTitle = title.toLowerCase();
    if (lowerTitle === "outline")
      return "list";
    if (lowerTitle === "moodboard")
      return "layout-dashboard";
    if (lowerTitle === "manuscript")
      return "scroll-text";
    if (lowerTitle === "preface" || lowerTitle === "afterword")
      return "file";
    if (lowerTitle === "logline" || lowerTitle === "synopsis" || lowerTitle === "beat sheet")
      return "file";
    if (lowerTitle === "document 1" || lowerTitle.startsWith("document "))
      return "file";
    if (lowerTitle === "chapter 1" || lowerTitle.startsWith("chapter "))
      return "file";
    if (lowerTitle === "scene 1" || lowerTitle.startsWith("scene "))
      return "file";
    if (lowerTitle === "show dossier")
      return "folder-open";
    if (lowerTitle === "episode 1" || lowerTitle.startsWith("episode "))
      return "clapperboard";
    if (lowerTitle === "sequence 1" || lowerTitle.startsWith("sequence "))
      return "film";
    if (lowerTitle === "volume 1" || lowerTitle.startsWith("volume "))
      return "folder-open";
    if (lowerTitle === "concept")
      return "lightbulb";
    if (lowerTitle === "faces")
      return "users";
    if (lowerTitle === "places")
      return "map-pin";
    if (lowerTitle === "objects")
      return "box";
    if (lowerTitle === "structure")
      return "list-tree";
    if (lowerTitle === "documentation" || lowerTitle === "research")
      return "archive";
    if (nodeType === "file")
      return "file";
    return isExpanded ? "folder-open" : "folder";
  }
  async renderBookTree(container, bookFolder) {
    container.empty();
    const folder = bookFolder instanceof import_obsidian4.TFolder ? bookFolder : this.plugin.app.vault.getAbstractFileByPath(
      (bookFolder == null ? void 0 : bookFolder.path) || bookFolder
    );
    if (!(folder instanceof import_obsidian4.TFolder)) {
      console.error("Invalid book folder", bookFolder);
      return;
    }
    const book = this.plugin.activeBook;
    if (!book)
      return;
    let configTree = [];
    let useConfigTree = false;
    try {
      configTree = await this.plugin.buildTreeFromFilesystem(folder);
      if (configTree.length > 0) {
        const cfg = await this.plugin.loadBookConfig(book) || {};
        if (!cfg.structure)
          cfg.structure = {};
        cfg.structure.tree = configTree;
        await this.plugin.saveBookConfig(book, cfg);
        useConfigTree = true;
      }
    } catch (e) {
      console.warn("Failed to build/sync tree from filesystem", e);
    }
    let draggedElement = null;
    let draggedNodeId = null;
    const setupDragEvents = (element, nodeId, nodeType) => {
      element.setAttribute("draggable", "true");
      element.addEventListener("dragstart", (e) => {
        draggedElement = element;
        draggedNodeId = nodeId;
        element.classList.add("folio-dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", nodeId);
      });
      element.addEventListener("dragend", (e) => {
        element.classList.remove("folio-dragging");
        document.querySelectorAll(".folio-dragover, .folio-dragover-before, .folio-dragover-after, .folio-dragover-inside").forEach((el) => el.classList.remove("folio-dragover", "folio-dragover-before", "folio-dragover-after", "folio-dragover-inside"));
        draggedElement = null;
        draggedNodeId = null;
      });
      element.addEventListener("dragover", (e) => {
        if (!draggedElement || draggedElement === element)
          return;
        e.preventDefault();
        e.stopPropagation();
        const rect = element.getBoundingClientRect();
        const mouseY = e.clientY;
        const elementTop = rect.top;
        const elementBottom = rect.bottom;
        const elementHeight = rect.height;
        element.classList.remove("folio-dragover-before", "folio-dragover-after", "folio-dragover-inside");
        if (nodeType === "group") {
          const topQuarter = elementTop + elementHeight / 4;
          const bottomHalf = elementTop + elementHeight / 2;
          if (mouseY < topQuarter) {
            element.classList.add("folio-dragover-before");
            e.dataTransfer.dropEffect = "move";
          } else if (mouseY > bottomHalf) {
            element.classList.add("folio-dragover-after");
            e.dataTransfer.dropEffect = "move";
          } else {
            element.classList.add("folio-dragover-inside");
            e.dataTransfer.dropEffect = "move";
          }
        } else {
          const middle = elementTop + elementHeight / 2;
          if (mouseY < middle) {
            element.classList.add("folio-dragover-before");
          } else {
            element.classList.add("folio-dragover-after");
          }
          e.dataTransfer.dropEffect = "move";
        }
      });
      element.addEventListener("dragleave", (e) => {
        element.classList.remove("folio-dragover-before", "folio-dragover-after", "folio-dragover-inside");
      });
      element.addEventListener("drop", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!draggedNodeId || draggedElement === element)
          return;
        const rect = element.getBoundingClientRect();
        const mouseY = e.clientY;
        const elementTop = rect.top;
        const elementBottom = rect.bottom;
        const elementHeight = rect.height;
        let position = "after";
        if (nodeType === "group") {
          const topQuarter = elementTop + elementHeight / 4;
          const bottomHalf = elementTop + elementHeight / 2;
          if (mouseY < topQuarter) {
            position = "before";
          } else if (mouseY > bottomHalf) {
            position = "after";
          } else {
            position = "inside";
          }
        } else {
          const middle = elementTop + elementHeight / 2;
          position = mouseY < middle ? "before" : "after";
        }
        const success = await this.plugin.reorderTreeNodes(book, draggedNodeId, nodeId, position);
        if (success) {
          this.plugin.rerenderViews();
        }
        element.classList.remove("folio-dragover-before", "folio-dragover-after", "folio-dragover-inside");
      });
    };
    const renderNodeFromConfig = (node, parentContainer) => {
      const fullPath = `${book.path}/${node.path}`;
      const vaultItem = this.plugin.app.vault.getAbstractFileByPath(fullPath);
      if (!vaultItem) {
        console.warn("Vault item not found:", fullPath, "for node:", node);
        return;
      }
      if (node.type === "group") {
        const folderRow = parentContainer.createDiv("folio-tree-folder tree-item is-folder");
        folderRow.dataset.path = fullPath;
        folderRow.dataset.nodeId = node.id;
        const collapse = folderRow.createSpan({ cls: "folio-tree-toggle" });
        collapse.classList.toggle("is-open", this.plugin.expandedFolders.has(fullPath));
        const folderIcon = folderRow.createSpan({ cls: "folio-tree-icon folder-icon" });
        try {
          const isExpanded = this.plugin.expandedFolders.has(fullPath);
          const iconName = node.icon || this.getCustomIcon(node.title, isExpanded, "folder");
          (0, import_obsidian4.setIcon)(folderIcon, iconName);
          (0, import_obsidian4.setIcon)(collapse, isExpanded ? "chevron-down" : "chevron-right");
        } catch (e) {
        }
        const titleSpan = folderRow.createSpan({ text: node.title, cls: "folio-tree-label" });
        if (node.exclude) {
          titleSpan.classList.add("exclude-from-stats");
        }
        setupDragEvents(folderRow, node.id, "group");
        try {
          folderRow.addEventListener("contextmenu", (evt) => {
            evt.preventDefault();
            this.plugin.openVolumeMenu(evt, vaultItem, false, node);
          });
        } catch (e) {
        }
        const childrenEl = parentContainer.createDiv("folio-tree-children");
        childrenEl.classList.toggle("is-open", this.plugin.expandedFolders.has(fullPath));
        if (!this.plugin.expandedFolders.has(fullPath))
          childrenEl.style.display = "none";
        collapse.onclick = (e) => {
          e.stopPropagation();
          const isHidden = childrenEl.style.display === "none";
          childrenEl.style.display = isHidden ? "" : "none";
          collapse.classList.toggle("is-open", isHidden);
          childrenEl.classList.toggle("is-open", isHidden);
          if (isHidden)
            this.plugin.expandedFolders.add(fullPath);
          else
            this.plugin.expandedFolders.delete(fullPath);
          try {
            const iconName = node.icon || this.getCustomIcon(node.title, isHidden, "folder");
            (0, import_obsidian4.setIcon)(folderIcon, iconName);
            (0, import_obsidian4.setIcon)(collapse, isHidden ? "chevron-down" : "chevron-right");
          } catch (e2) {
          }
        };
        if (node.children && node.children.length > 0) {
          const sortedChildren = [...node.children].sort((a, b) => a.order - b.order);
          sortedChildren.forEach((child) => renderNodeFromConfig(child, childrenEl));
        }
      } else {
        const fileRow = parentContainer.createDiv("folio-tree-file tree-item is-file");
        fileRow.dataset.path = fullPath;
        fileRow.dataset.nodeId = node.id;
        const icon = fileRow.createSpan({ cls: "folio-tree-icon" });
        try {
          const defaultIcon = node.type === "canvas" ? "layout-dashboard" : this.getCustomIcon(node.title, false, "file");
          (0, import_obsidian4.setIcon)(icon, node.icon || defaultIcon);
        } catch (e) {
        }
        const label = fileRow.createSpan({ text: node.title, cls: "folio-tree-label" });
        if (node.exclude) {
          label.classList.add("exclude-from-stats");
        }
        if (node.completed) {
          label.classList.add("is-done");
        }
        fileRow.onclick = (e) => {
          e.stopPropagation();
          this.plugin.app.workspace.openLinkText(fullPath, "", false);
        };
        setupDragEvents(fileRow, node.id, "file");
        try {
          fileRow.addEventListener("contextmenu", (evt) => {
            evt.preventDefault();
            this.plugin.openChapterContextMenu(evt, vaultItem, node);
          });
        } catch (e) {
        }
      }
    };
    if (useConfigTree && configTree.length > 0) {
      console.log("Rendering tree with", configTree.length, "root nodes");
      const sortedTree = [...configTree].sort((a, b) => a.order - b.order);
      sortedTree.forEach((node) => renderNodeFromConfig(node, container));
    } else {
      console.warn("No config tree to render, useConfigTree:", useConfigTree, "length:", configTree.length);
    }
    try {
      container.addEventListener("contextmenu", (evt) => {
        try {
          if (evt.target && evt.target.closest && evt.target.closest(".tree-item"))
            return;
          evt.preventDefault();
          this.plugin.openVolumeMenu(evt, folder, true);
        } catch (e) {
        }
      });
    } catch (e) {
    }
  }
  async renderStats(container, book) {
    try {
      if (!book || !this.plugin.loadBookConfig)
        return;
      let cfg = {};
      try {
        cfg = await this.plugin.loadBookConfig(book) || {};
      } catch (e) {
      }
      try {
        if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
          console.debug("Folio.renderStats loaded cfg", book && book.path, { basic: cfg.basic, stats: cfg.stats });
      } catch (e) {
      }
      const stats = cfg.stats || {};
      if (!stats)
        return;
      const pad = (n) => typeof n === "number" ? n : 0;
      const formatTarget = (n) => {
        if (!n)
          return "\u2014";
        const num = Number(n) || 0;
        if (num >= 1e3) {
          const k = num / 1e3;
          return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
        }
        return String(num);
      };
      const todayKey = new Date().toISOString().slice(0, 10);
      const dailyWords = stats.daily_words || {};
      const todayCount = pad(dailyWords[todayKey]) || 0;
      const totalWords = pad(stats.total_words) || 0;
      const targetWords = pad(stats.target_total_words) || 0;
      const completionPct = typeof stats.progress_by_words !== "undefined" && stats.progress_by_words !== null ? Number(stats.progress_by_words) : targetWords > 0 ? Math.round(totalWords / targetWords * 1e4) / 100 : 0;
      const writingDays = typeof stats.writing_days === "number" ? stats.writing_days : stats.daily_words ? Object.keys(stats.daily_words).length : 0;
      const dailyAvg = typeof stats.average_daily_words === "number" ? stats.average_daily_words : writingDays > 0 ? Math.round(totalWords / writingDays) : 0;
      container.empty();
      const row = (iconName, label, value, extra) => {
        const r = container.createDiv("folio-stat-row");
        const left = r.createDiv({ cls: "folio-stat-left" });
        const iconSpan = left.createSpan({ cls: "folio-stat-icon" });
        try {
          if (Array.isArray(iconName)) {
            iconName.forEach((n, i) => {
              const s = iconSpan.createSpan({ cls: `folio-stat-icon-part part-${i}` });
              try {
                (0, import_obsidian4.setIcon)(s, n);
              } catch (e) {
              }
            });
          } else {
            try {
              (0, import_obsidian4.setIcon)(iconSpan, iconName);
            } catch (e) {
            }
          }
        } catch (e) {
        }
        left.createSpan({ text: label, cls: "folio-stat-label" });
        r.createSpan({ text: value, cls: "folio-stat-value" });
        if (extra && typeof extra === "function")
          extra(r);
      };
      row("pencil", "Today", `${todayCount} words`);
      row("file", "Total words", `${totalWords} / ${formatTarget(targetWords)}`);
      row("target", "Completion", `${(Math.round(completionPct * 100) / 100).toFixed(2)}%`);
      row("clock", "Writing days", `${writingDays} days`);
      row("calendar-clock", "Daily average", `${dailyAvg} words`);
    } catch (e) {
      console.warn("renderStats failed", e);
    }
  }
  async render() {
    const { NewBookModal: NewBookModal2 } = await Promise.resolve().then(() => (init_newBookModal(), newBookModal_exports));
    const { SwitchBookModal: SwitchBookModal2 } = await Promise.resolve().then(() => (init_switchBookModal(), switchBookModal_exports));
    const { ManageBooksModal: ManageBooksModal2 } = await Promise.resolve().then(() => (init_manageBooksModal(), manageBooksModal_exports));
    const { HelpModal: HelpModal2 } = await Promise.resolve().then(() => (init_helpModal(), helpModal_exports));
    const { TextInputModal: TextInputModal2 } = await Promise.resolve().then(() => (init_textInputModal(), textInputModal_exports));
    const token = ++this._renderCounter;
    this._isRendering = true;
    try {
      const el = this.contentEl;
      el.empty();
      if (this._renderCounter !== token)
        return;
      el.addClass("folio-view");
      const topBar = el.createDiv("folio-topbar");
      const newBtn = topBar.createEl("button", { cls: "folio-top-btn" });
      const newIcon = newBtn.createSpan({ cls: "folio-top-icon" });
      try {
        (0, import_obsidian4.setIcon)(newIcon, "edit");
      } catch (e) {
      }
      newBtn.createSpan({ text: "New Project", cls: "folio-top-label" });
      const switchBtn = topBar.createEl("button", { cls: "folio-top-btn" });
      const switchIcon = switchBtn.createSpan({ cls: "folio-top-icon" });
      try {
        (0, import_obsidian4.setIcon)(switchIcon, "repeat");
      } catch (e) {
      }
      switchBtn.createSpan({ text: "Switch", cls: "folio-top-label" });
      const manageBtn = topBar.createEl("button", { cls: "folio-top-btn" });
      const manageIcon = manageBtn.createSpan({ cls: "folio-top-icon" });
      try {
        (0, import_obsidian4.setIcon)(manageIcon, "library");
      } catch (e) {
      }
      manageBtn.createSpan({ text: "Manage", cls: "folio-top-label" });
      const helpBtn = topBar.createEl("button", { cls: "folio-help-btn" });
      const helpIcon = helpBtn.createSpan({ cls: "folio-help-icon" });
      try {
        (0, import_obsidian4.setIcon)(helpIcon, "help");
      } catch (e) {
      }
      newBtn.onclick = () => {
        new NewBookModal2(this.plugin).open();
      };
      switchBtn.onclick = () => {
        new SwitchBookModal2(this.plugin).open();
      };
      manageBtn.onclick = () => {
        new ManageBooksModal2(this.plugin).open();
      };
      helpBtn.onclick = () => {
        new HelpModal2(this.plugin).open();
      };
      const book = this.plugin.activeBook;
      if (!book) {
        const headerEl2 = el.createDiv("folio-book-header");
        const coverCol2 = headerEl2.createDiv("folio-book-cover-col");
        const coverEl2 = coverCol2.createDiv("folio-book-cover");
        coverEl2.addClass("folio-book-cover-placeholder");
        try {
          const iconEl = coverEl2.createDiv({ cls: "folio-book-cover-icon" });
          (0, import_obsidian4.setIcon)(iconEl, "square-plus");
        } catch (e) {
        }
        const titleBlock2 = headerEl2.createDiv("folio-book-title-block");
        titleBlock2.createEl("div", { cls: "folio-book-title", text: "No active project" });
        titleBlock2.createEl("div", { cls: "folio-book-subtitle", text: "(Select or create a project)" });
        const metaBlock2 = el.createDiv("folio-book-meta folio-book-info");
        const authorRow2 = metaBlock2.createDiv("folio-meta-row");
        authorRow2.createEl("div", { text: "Author", cls: "folio-meta-label" });
        authorRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value" });
        const descRow2 = metaBlock2.createDiv("folio-meta-row");
        descRow2.createEl("div", { text: "Description", cls: "folio-meta-label" });
        descRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value folio-meta-desc" });
        const structureEl2 = el.createDiv("folio-structure");
        structureEl2.createEl("p", { text: "(No project selected)" });
        try {
          const statsEl = el.createDiv("folio-stats");
          const makeRow = (label, value) => {
            const r = statsEl.createDiv("folio-stat-row");
            const left = r.createDiv({ cls: "folio-stat-left" });
            left.createSpan({ cls: "folio-stat-icon" });
            left.createSpan({ text: label, cls: "folio-stat-label" });
            r.createSpan({ text: value, cls: "folio-stat-value" });
          };
          makeRow("Today", "\u2014");
          makeRow("Total words", "\u2014 / \u2014");
          makeRow("Completion", "\u2014");
          makeRow("Writing days", "\u2014");
          makeRow("Daily average", "\u2014");
        } catch (e) {
        }
        return;
      }
      const bookFolderCheck = this.plugin.app.vault.getAbstractFileByPath(book.path);
      if (!bookFolderCheck || !(bookFolderCheck instanceof import_obsidian4.TFolder)) {
        const headerEl2 = el.createDiv("folio-book-header");
        const coverCol2 = headerEl2.createDiv("folio-book-cover-col");
        const coverEl2 = coverCol2.createDiv("folio-book-cover");
        coverEl2.addClass("folio-book-cover-placeholder");
        try {
          const iconEl = coverEl2.createDiv({ cls: "folio-book-cover-icon" });
          (0, import_obsidian4.setIcon)(iconEl, "square-plus");
        } catch (e) {
        }
        const titleBlock2 = headerEl2.createDiv("folio-book-title-block");
        titleBlock2.createEl("div", { cls: "folio-book-title", text: "No active project" });
        titleBlock2.createEl("div", { cls: "folio-book-subtitle", text: "(Project folder missing)" });
        const metaBlock2 = el.createDiv("folio-book-meta folio-book-info");
        const authorRow2 = metaBlock2.createDiv("folio-meta-row");
        authorRow2.createEl("div", { text: "Author", cls: "folio-meta-label" });
        authorRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value" });
        const descRow2 = metaBlock2.createDiv("folio-meta-row");
        descRow2.createEl("div", { text: "Description", cls: "folio-meta-label" });
        descRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value folio-meta-desc" });
        const structureEl2 = el.createDiv("folio-structure");
        structureEl2.createEl("p", { text: "(Book folder missing on disk)" });
        try {
          const statsEl = el.createDiv("folio-stats");
          const makeRow = (label, value) => {
            const r = statsEl.createDiv("folio-stat-row");
            const left = r.createDiv({ cls: "folio-stat-left" });
            left.createSpan({ cls: "folio-stat-icon" });
            left.createSpan({ text: label, cls: "folio-stat-label" });
            r.createSpan({ text: value, cls: "folio-stat-value" });
          };
          makeRow("Today", "\u2014");
          makeRow("Total words", "\u2014 / \u2014");
          makeRow("Completion", "\u2014");
          makeRow("Writing days", "\u2014");
          makeRow("Daily average", "\u2014");
        } catch (e) {
        }
        return;
      }
      let metadata = {};
      try {
        if (this.plugin.loadBookMeta)
          metadata = await this.plugin.loadBookMeta(book) || {};
      } catch (e) {
        metadata = {};
      }
      if (this._renderCounter !== token)
        return;
      const headerEl = el.createDiv("folio-book-header");
      const coverCol = headerEl.createDiv("folio-book-cover-col");
      const coverEl = coverCol.createDiv("folio-book-cover");
      const coverPath = book.cover ? this.plugin.app.vault.getResourcePath(book.cover) : null;
      if (coverPath) {
        coverEl.style.backgroundImage = `url("${coverPath}")`;
      } else {
        try {
          coverEl.addClass("folio-book-cover-placeholder");
          const iconEl = coverEl.createDiv({ cls: "folio-book-cover-icon" });
          const projectType = (metadata == null ? void 0 : metadata.projectType) || PROJECT_TYPES.BOOK;
          const iconName = getProjectTypeIcon3(this.plugin, projectType);
          (0, import_obsidian4.setIcon)(iconEl, iconName);
        } catch (e) {
        }
      }
      const titleBlock = headerEl.createDiv("folio-book-title-block");
      titleBlock.createEl("div", {
        cls: "folio-book-title",
        text: metadata && metadata.title || book.name || "Untitled book"
      });
      const subtitleText = metadata && metadata.subtitle || "";
      if (subtitleText) {
        titleBlock.createEl("div", {
          cls: "folio-book-subtitle",
          text: subtitleText
        });
      }
      const metaBlock = el.createDiv("folio-book-meta folio-book-info");
      const authorVal = metadata && metadata.author || "";
      const descVal = metadata && metadata.description || "";
      const authorRow = metaBlock.createDiv("folio-meta-row");
      authorRow.createEl("div", { text: "Author", cls: "folio-meta-label" });
      authorRow.createEl("div", { text: authorVal || "\u2014", cls: "folio-meta-value" });
      const descRow = metaBlock.createDiv("folio-meta-row");
      descRow.createEl("div", { text: "Description", cls: "folio-meta-label" });
      descRow.createEl("div", { text: descVal || "\u2014", cls: "folio-meta-value folio-meta-desc" });
      if (this._renderCounter !== token)
        return;
      const structureEl = el.createDiv("folio-structure");
      const bookFolder = this.plugin.app.vault.getAbstractFileByPath(book.path);
      if (this._renderCounter !== token)
        return;
      if (bookFolder instanceof import_obsidian4.TFolder) {
        await this.renderBookTree(structureEl, bookFolder);
      } else {
        structureEl.createEl("p", { text: "(No folder found on disk)" });
      }
      try {
        structureEl.addEventListener("contextmenu", (evt) => {
          try {
            const item = evt.target && evt.target.closest && evt.target.closest(".tree-item");
            if (item)
              return;
            evt.preventDefault();
            const menu = new import_obsidian4.Menu(this.plugin.app);
            menu.addItem(
              (it) => it.setTitle("New root canvas").setIcon("layout-dashboard").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New root canvas",
                  placeholder: "Canvas name (without .canvas)",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const raw = (value || "").trim();
                      if (!raw)
                        return;
                      const base = raw.endsWith(".canvas") ? raw.slice(0, -7) : raw;
                      let name = `${base}.canvas`;
                      let i = 1;
                      while (this.plugin.app.vault.getAbstractFileByPath(`${book.path}/${name}`)) {
                        name = `${base} ${i}.canvas`;
                        i += 1;
                      }
                      await this.plugin.app.vault.create(`${book.path}/${name}`, "");
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.addItem(
              (it) => it.setTitle("New root file").setIcon("file-plus").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New root file",
                  placeholder: "File name (without .md)",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const name = (value || "").trim();
                      if (!name)
                        return;
                      const fileName = name.endsWith(".md") ? name : `${name}.md`;
                      const path = `${book.path}/${fileName}`;
                      if (!this.plugin.app.vault.getAbstractFileByPath(path)) {
                        await this.plugin.app.vault.create(path, "");
                      }
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.addItem(
              (it) => it.setTitle("New volume").setIcon("folder-plus").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New volume",
                  placeholder: "Volume name",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const name = (value || "").trim();
                      if (!name)
                        return;
                      await this.plugin.createVolume(book, name);
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.showAtMouseEvent(evt);
          } catch (e) {
            console.error(e);
          }
        });
      } catch (e) {
      }
      if (this._renderCounter !== token)
        return;
      this.statsEl = el.createDiv("folio-stats");
      await this.renderStats(this.statsEl, book);
      try {
        if (this.statsEl)
          this.statsEl.addEventListener("contextmenu", (evt) => {
            try {
              evt.preventDefault();
              const row = evt.target && evt.target.closest && evt.target.closest(".folio-stat-row");
              if (row)
                return;
              const menu = new import_obsidian4.Menu(this.plugin.app);
              menu.addItem(
                (it) => it.setTitle("New root canvas").setIcon("layout-dashboard").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New root canvas",
                    placeholder: "Canvas name (without .canvas)",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const raw = (value || "").trim();
                        if (!raw)
                          return;
                        const base = raw.endsWith(".canvas") ? raw.slice(0, -7) : raw;
                        let name = `${base}.canvas`;
                        let i = 1;
                        while (this.plugin.app.vault.getAbstractFileByPath(`${book.path}/${name}`)) {
                          name = `${base} ${i}.canvas`;
                          i += 1;
                        }
                        await this.plugin.app.vault.create(`${book.path}/${name}`, "");
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.addItem(
                (it) => it.setTitle("New root file").setIcon("file-plus").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New root file",
                    placeholder: "File name (without .md)",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const name = (value || "").trim();
                        if (!name)
                          return;
                        const fileName = name.endsWith(".md") ? name : `${name}.md`;
                        const path = `${book.path}/${fileName}`;
                        if (!this.plugin.app.vault.getAbstractFileByPath(path)) {
                          await this.plugin.app.vault.create(path, "");
                        }
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.addItem(
                (it) => it.setTitle("New volume").setIcon("folder-plus").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New volume",
                    placeholder: "Volume name",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const name = (value || "").trim();
                        if (!name)
                          return;
                        await this.plugin.createVolume(book, name);
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.showAtMouseEvent(evt);
            } catch (e) {
              console.error(e);
            }
          });
      } catch (e) {
      }
    } finally {
      if (this._renderCounter === token) {
        this._isRendering = false;
      }
    }
  }
};

// src/views/writerToolsView.js
var import_obsidian6 = require("obsidian");

// src/modals/focusModeStatsModal.js
var import_obsidian5 = require("obsidian");
var FocusModeStatsModal = class extends import_obsidian5.Modal {
  constructor(plugin, project) {
    super(plugin.app);
    this.plugin = plugin;
    this.project = project;
  }
  setProject(project) {
    this.project = project;
  }
  async onOpen() {
    await this.render();
  }
  async refresh() {
    await this.render();
  }
  formatDate(value) {
    if (!value)
      return "\u2014";
    const date = new Date(value);
    if (Number.isNaN(date.getTime()))
      return "\u2014";
    return date.toLocaleDateString();
  }
  formatValue(value) {
    if (value === void 0 || value === null || value === "")
      return "\u2014";
    return value;
  }
  buildPieChart(container, title, slices, options = {}) {
    const size = options.size || 140;
    const radius = size / 2;
    const chartWrap = container.createDiv({ cls: "focus-mode-chart" });
    chartWrap.createDiv({ cls: "focus-mode-chart-title", text: title });
    const resolveColor = (value) => {
      if (!value)
        return value;
      const match = value.match(/^var\((--[^)]+)\)/);
      if (!match)
        return value;
      const varName = match[1];
      const computed = getComputedStyle(this.modalEl || document.body).getPropertyValue(varName).trim();
      return computed || value;
    };
    const resolvedSlices = slices.map((slice) => ({
      ...slice,
      color: resolveColor(slice.color)
    }));
    const borderColor = resolveColor("var(--background-modifier-border)");
    const total = resolvedSlices.reduce((sum, slice) => sum + slice.value, 0);
    if (!total) {
      const empty = chartWrap.createDiv({ cls: "focus-mode-chart-empty", text: "No data to display" });
      empty.setAttribute("aria-label", `${title}: no data`);
      return;
    }
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", "focus-mode-chart-svg");
    svg.setAttribute("width", `${size}`);
    svg.setAttribute("height", `${size}`);
    svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
    svg.setAttribute("role", "img");
    svg.setAttribute("aria-label", `${title} pie chart`);
    chartWrap.appendChild(svg);
    const center = radius;
    let cumulative = 0;
    const nonZeroSlices = resolvedSlices.filter((slice) => slice.value > 0);
    if (nonZeroSlices.length === 1) {
      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", `${center}`);
      circle.setAttribute("cy", `${center}`);
      circle.setAttribute("r", `${center}`);
      circle.setAttribute("fill", nonZeroSlices[0].color);
      circle.setAttribute("stroke", borderColor);
      circle.setAttribute("stroke-width", "1");
      svg.appendChild(circle);
      circle.style.fill = nonZeroSlices[0].color;
    } else {
      const polarToCartesian = (cx, cy, r, angle) => {
        const radians = (angle - 90) * (Math.PI / 180);
        return {
          x: cx + r * Math.cos(radians),
          y: cy + r * Math.sin(radians)
        };
      };
      const describeArc = (cx, cy, r, startAngle, endAngle) => {
        const start = polarToCartesian(cx, cy, r, endAngle);
        const end = polarToCartesian(cx, cy, r, startAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        return [
          `M ${cx} ${cy}`,
          `L ${start.x} ${start.y}`,
          `A ${r} ${r} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`,
          "Z"
        ].join(" ");
      };
      resolvedSlices.forEach((slice) => {
        if (slice.value <= 0)
          return;
        const startAngle = cumulative;
        const endAngle = cumulative + slice.value / total * 360;
        cumulative = endAngle;
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", describeArc(center, center, center, startAngle, endAngle));
        path.setAttribute("fill", slice.color);
        path.setAttribute("stroke", borderColor);
        path.setAttribute("stroke-width", "1");
        svg.appendChild(path);
        path.style.fill = slice.color;
        path.setAttribute("aria-label", `${slice.label}: ${slice.value}`);
      });
    }
    const legend = chartWrap.createDiv({ cls: "focus-mode-chart-legend" });
    slices.forEach((slice) => {
      const legendItem = legend.createDiv({ cls: "focus-mode-chart-legend-item" });
      legendItem.createSpan({ cls: "focus-mode-chart-legend-swatch" }).style.backgroundColor = slice.color;
      legendItem.createSpan({ cls: "focus-mode-chart-legend-label", text: `${slice.label}: ${slice.value}` });
    });
  }
  async render() {
    var _a;
    const { contentEl } = this;
    this._renderToken = (this._renderToken || 0) + 1;
    const token = this._renderToken;
    const header = contentEl.createDiv({ cls: "focus-mode-stats-modal-header" });
    header.createDiv({ cls: "focus-mode-stats-modal-title", text: "Focus mode stats" });
    const headerActions = header.createDiv({ cls: "focus-mode-stats-modal-actions" });
    headerActions.createEl("button", { cls: "focus-mode-stats-modal-btn", text: "Older sessions" });
    if (!this.project) {
      contentEl.createDiv({ cls: "focus-mode-stats-empty", text: "No active project." });
      return;
    }
    const cfg = await this.plugin.configService.loadProjectConfig(this.project) || {};
    const meta = await this.plugin.configService.loadProjectMeta(this.project) || {};
    if (token !== this._renderToken)
      return;
    contentEl.empty();
    const author = Array.isArray(meta.author) ? meta.author.join(", ") : meta.author;
    const createdAt = this.formatDate(meta.created_at);
    const lastModified = this.formatDate(((_a = cfg.stats) == null ? void 0 : _a.last_modified) || meta.last_modified);
    const infoSection = contentEl.createDiv({ cls: "focus-mode-stats-section" });
    infoSection.createDiv({ cls: "focus-mode-stats-section-title", text: "Project info" });
    const infoGrid = infoSection.createDiv({ cls: "focus-mode-info-grid" });
    const addInfoRow = (label, value) => {
      const row = infoGrid.createDiv({ cls: "focus-mode-info-row" });
      row.createDiv({ cls: "focus-mode-info-label", text: label });
      row.createDiv({ cls: "focus-mode-info-value", text: this.formatValue(value) });
    };
    addInfoRow("Title", meta.title || this.project.name || "\u2014");
    addInfoRow("Author", author || "\u2014");
    addInfoRow("Date of creation", createdAt);
    addInfoRow("Date of last modification", lastModified);
    const focusMode = cfg.focusMode || {};
    const history = Array.isArray(focusMode.history) ? focusMode.history : [];
    const currentWords = Number(focusMode.currentWords || 0);
    const currentTarget = Number(focusMode.wordGoal || 0);
    const statsSection = contentEl.createDiv({ cls: "focus-mode-stats-section" });
    statsSection.createDiv({ cls: "focus-mode-stats-section-title", text: "Focus sessions" });
    const statsGrid = statsSection.createDiv({ cls: "focus-mode-info-grid" });
    const addStatRow = (label, value) => {
      const row = statsGrid.createDiv({ cls: "focus-mode-info-row" });
      row.createDiv({ cls: "focus-mode-info-label", text: label });
      row.createDiv({ cls: "focus-mode-info-value", text: value.toString() });
    };
    addStatRow("Total Completed sessions", Number(focusMode.sessions || 0));
    addStatRow("Total Interrupted sessions", Number(focusMode.interruptions || 0));
    addStatRow("Total Words in session", currentWords);
    addStatRow("Total Session word target", currentTarget);
    const chartsSection = contentEl.createDiv({ cls: "focus-mode-stats-section focus-mode-charts" });
    chartsSection.createDiv({ cls: "focus-mode-stats-section-title", text: "Charts" });
    const chartsGrid = chartsSection.createDiv({ cls: "focus-mode-charts-grid" });
    const completedCount = Number(focusMode.sessions || 0);
    const interruptedCount = Number(focusMode.interruptions || 0);
    this.buildPieChart(chartsGrid, "Completed vs Interrupted", [
      { label: "Completed", value: completedCount, color: "var(--text-accent)" },
      { label: "Interrupted", value: interruptedCount, color: "var(--text-muted)" }
    ]);
    const remaining = Math.max(0, currentTarget - currentWords);
    this.buildPieChart(chartsGrid, "Words vs Target", [
      { label: "Words", value: currentWords, color: "var(--text-accent)" },
      { label: "Remaining", value: remaining, color: "var(--text-normal)" }
    ]);
  }
};

// src/views/writerToolsView.js
var WRITER_TOOLS_VIEW_TYPE2 = "folio-writer-tools";
var WriterToolsView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.focusModeActive = false;
    this.timerSeconds = 25 * 60;
    this.timerRunning = false;
    this.timerInterval = null;
    this.sessionStartWords = 0;
    this.focusStats = {
      sessions: 0,
      interruptions: 0,
      currentWords: 0,
      wordGoal: 500,
      totalTimeSpent: 0,
      // in seconds
      history: []
    };
    this.focusStatsModal = null;
  }
  getViewType() {
    return WRITER_TOOLS_VIEW_TYPE2;
  }
  getDisplayText() {
    return "Writer Tools";
  }
  getIcon() {
    return "pencil-ruler";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-writer-tools");
    const header = container.createDiv({ cls: "writer-tools-header" });
    const headerTitle = header.createDiv({ cls: "writer-tools-title" });
    headerTitle.createSpan({ text: "Writer tools" });
    container.createDiv({ cls: "writer-tools-divider" });
    this.toolsContainer = container.createDiv({ cls: "writer-tools-container" });
    this.renderToolsSection();
    this.renderResourcesSection();
    this.renderAboutSection();
  }
  renderToolsSection() {
    const section = this.toolsContainer.createDiv({ cls: "writer-tools-section" });
    section.createDiv({ cls: "writer-tools-section-title", text: "TOOLS" });
    const focusItem = section.createDiv({ cls: "writer-tools-item" });
    const focusIcon = focusItem.createSpan({ cls: "writer-tools-item-icon" });
    (0, import_obsidian6.setIcon)(focusIcon, "circle-dot");
    focusItem.createSpan({ cls: "writer-tools-item-text", text: "Focus mode" });
    focusItem.addEventListener("click", () => this.showFocusMode());
    const exportItem = section.createDiv({ cls: "writer-tools-item" });
    const exportIcon = exportItem.createSpan({ cls: "writer-tools-item-icon" });
    (0, import_obsidian6.setIcon)(exportIcon, "file-stack");
    exportItem.createSpan({ cls: "writer-tools-item-text", text: "Export assistant" });
    exportItem.addEventListener("click", () => {
      console.log("Consolidate document clicked");
    });
  }
  showFocusMode() {
    this.focusModeActive = true;
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-focus-mode");
    const project = this.plugin.activeProject || this.plugin.activeBook;
    if (!project) {
      container.createDiv({ cls: "focus-mode-no-project", text: "No project selected. Please select a project first." });
      const backBtn = container.createEl("button", { cls: "focus-mode-btn-secondary", text: "Back" });
      backBtn.addEventListener("click", () => this.exitFocusMode());
      return;
    }
    this.loadFocusStats(project).then(() => {
      this.renderFocusModeUI(container, project);
    });
  }
  async loadFocusStats(project) {
    try {
      const cfg = await this.plugin.configService.loadProjectConfig(project);
      if (cfg && cfg.focusMode) {
        this.focusStats = {
          sessions: cfg.focusMode.sessions || 0,
          interruptions: cfg.focusMode.interruptions || 0,
          currentWords: Number(cfg.focusMode.currentWords || 0),
          wordGoal: cfg.focusMode.wordGoal || 500,
          totalTimeSpent: cfg.focusMode.totalTimeSpent || 0,
          history: Array.isArray(cfg.focusMode.history) ? cfg.focusMode.history : []
        };
      }
    } catch (e) {
      console.warn("Failed to load focus stats", e);
    }
  }
  async saveFocusStats(project) {
    try {
      const cfg = await this.plugin.configService.loadProjectConfig(project) || {};
      cfg.focusMode = {
        sessions: this.focusStats.sessions,
        interruptions: this.focusStats.interruptions,
        currentWords: this.focusStats.currentWords || 0,
        wordGoal: this.focusStats.wordGoal,
        totalTimeSpent: this.focusStats.totalTimeSpent,
        history: this.focusStats.history,
        lastSession: new Date().toISOString()
      };
      await this.plugin.configService.saveProjectConfig(project, cfg);
      if (this.focusStatsModal) {
        this.focusStatsModal.setProject(project);
        this.focusStatsModal.refresh();
      }
    } catch (e) {
      console.warn("Failed to save focus stats", e);
    }
  }
  renderFocusModeUI(container, project) {
    this.focusModeProject = project;
    const header = container.createDiv({ cls: "focus-mode-header" });
    const headerIcon = header.createSpan({ cls: "focus-mode-header-icon" });
    (0, import_obsidian6.setIcon)(headerIcon, "circle-dot");
    header.createSpan({ cls: "focus-mode-header-title", text: "Focus mode" });
    const projectLabel = container.createDiv({ cls: "focus-mode-project-name" });
    projectLabel.createSpan({ text: "Project: ", cls: "focus-mode-project-label" });
    projectLabel.createSpan({ text: project.name, cls: "focus-mode-project-value" });
    const timerContainer = container.createDiv({ cls: "focus-mode-timer-container" });
    const timerCircle = timerContainer.createDiv({ cls: "focus-mode-timer-circle" });
    this.timerDisplay = timerCircle.createDiv({ cls: "focus-mode-timer-display" });
    this.updateTimerDisplay();
    this.statusText = container.createDiv({ cls: "focus-mode-status", text: "Ready to start" });
    const buttonsContainer = container.createDiv({ cls: "focus-mode-buttons" });
    this.startButton = buttonsContainer.createEl("button", { cls: "focus-mode-btn-primary", text: "Start focus" });
    this.startButton.addEventListener("click", () => this.toggleTimer());
    const exitButton = buttonsContainer.createEl("button", { cls: "focus-mode-btn-secondary", text: "Exit" });
    exitButton.addEventListener("click", () => this.exitFocusMode());
    const statsBar = container.createDiv({ cls: "focus-mode-stats-bar" });
    this.renderFocusStats(statsBar);
  }
  updateTimerDisplay() {
    const minutes = Math.floor(this.timerSeconds / 60);
    const seconds = this.timerSeconds % 60;
    this.timerDisplay.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
  toggleTimer() {
    if (this.timerRunning) {
      this.pauseTimer();
    } else {
      this.startTimer();
    }
  }
  startTimer() {
    this.timerRunning = true;
    this.startButton.textContent = "Pause";
    this.statusText.textContent = "Focus in progress...";
    if (this.timerSeconds === 25 * 60) {
      this.sessionStartWords = this.getActiveEditorWordCount();
      this.focusStats.currentWords = 0;
      this.refreshFocusStats();
    }
    this.timerInterval = setInterval(() => {
      if (this.timerSeconds > 0) {
        this.timerSeconds--;
        this.updateTimerDisplay();
      } else {
        this.completeSession();
      }
    }, 1e3);
  }
  pauseTimer() {
    this.timerRunning = false;
    this.startButton.textContent = "Resume";
    this.statusText.textContent = "Paused";
    this.focusStats.interruptions++;
    this.focusStats.history.push({
      type: "interrupted",
      timestamp: new Date().toISOString(),
      words: this.focusStats.currentWords || 0,
      target: this.focusStats.wordGoal || 0
    });
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    const project = this.plugin.activeProject || this.plugin.activeBook;
    if (project)
      this.saveFocusStats(project);
    this.refreshFocusStats();
    this.sessionStartWords = 0;
    this.focusStats.currentWords = 0;
  }
  completeSession() {
    this.timerRunning = false;
    this.focusStats.sessions++;
    this.focusStats.totalTimeSpent += 25 * 60;
    this.focusStats.history.push({
      type: "completed",
      timestamp: new Date().toISOString(),
      words: this.focusStats.currentWords || 0,
      target: this.focusStats.wordGoal || 0
    });
    this.startButton.textContent = "Start focus";
    this.statusText.textContent = "Session complete!";
    this.timerSeconds = 25 * 60;
    this.updateTimerDisplay();
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    const project = this.plugin.activeProject || this.plugin.activeBook;
    if (project)
      this.saveFocusStats(project);
    this.refreshFocusStats();
  }
  refreshFocusStats() {
    const statsBar = this.containerEl.querySelector(".focus-mode-stats-bar");
    if (statsBar) {
      statsBar.empty();
      this.renderFocusStats(statsBar);
    }
  }
  renderFocusStats(container) {
    const formatTime = (seconds) => {
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor(seconds % 3600 / 60);
      if (hrs > 0)
        return `${hrs}h ${mins}m`;
      return `${mins}m`;
    };
    const project = this.focusModeProject || this.plugin.activeProject || this.plugin.activeBook;
    const statsHeader = container.createDiv({ cls: "focus-mode-stats-header" });
    const statsButton = statsHeader.createEl("button", { cls: "focus-mode-stats-button", text: "Focus mode stats" });
    statsButton.addEventListener("click", async (evt) => {
      evt.stopPropagation();
      if (!project)
        return;
      await this.saveFocusStats(project);
      if (!this.focusStatsModal) {
        this.focusStatsModal = new FocusModeStatsModal(this.plugin, project);
      }
      this.focusStatsModal.setProject(project);
      this.focusStatsModal.open();
    });
    const tooltipZone = container.createDiv({ cls: "focus-mode-tooltip-zone" });
    const stats = [
      { label: "Completed sessions", value: this.focusStats.sessions, tooltip: "Number of 25-minute focus sessions completed without exiting", priority: "secondary" },
      { label: "Interrupted sessions", value: this.focusStats.interruptions, tooltip: "Number of times you paused during an active focus session", priority: "secondary" },
      { label: "Words in session", value: this.focusStats.currentWords, tooltip: "Words written during the current focus session", priority: "primary" },
      { label: "Session word target", value: this.focusStats.wordGoal, tooltip: "Target number of words to write per session", priority: "primary" }
    ];
    const statsRow = container.createDiv({ cls: "focus-mode-stats-row" });
    stats.forEach((stat) => {
      const statItem = statsRow.createDiv({ cls: `focus-mode-stat-item ${stat.priority === "primary" ? "is-primary" : "is-secondary"}` });
      statItem.createDiv({ cls: "focus-mode-stat-label", text: stat.label });
      statItem.createDiv({ cls: "focus-mode-stat-value", text: stat.value.toString() });
      statItem.addEventListener("click", (e) => {
        e.stopPropagation();
        tooltipZone.textContent = stat.tooltip;
        tooltipZone.classList.add("visible");
        setTimeout(() => {
          tooltipZone.classList.remove("visible");
        }, 3e3);
      });
    });
    container.addEventListener("click", () => {
      tooltipZone.classList.remove("visible");
    });
  }
  getActiveEditorWordCount() {
    var _a;
    try {
      const leaf = this.plugin.app.workspace.getMostRecentLeaf();
      const editor = (_a = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a.editor;
      if (!editor || typeof editor.getValue !== "function")
        return 0;
      return this.plugin.statsService.countWords(editor.getValue());
    } catch (e) {
      return 0;
    }
  }
  updateFocusSessionWordsFromEditor(text, file) {
    if (!this.focusModeActive)
      return;
    const project = this.focusModeProject || this.plugin.activeProject || this.plugin.activeBook;
    if (!project || !(file == null ? void 0 : file.path) || !file.path.startsWith(project.path + "/"))
      return;
    const total = this.plugin.statsService.countWords(text);
    if (this.sessionStartWords === void 0 || this.sessionStartWords === null) {
      this.sessionStartWords = total;
    }
    const current = Math.max(0, total - this.sessionStartWords);
    if (current !== this.focusStats.currentWords) {
      this.focusStats.currentWords = current;
      this.refreshFocusStats();
    }
  }
  exitFocusMode() {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    this.timerRunning = false;
    this.timerSeconds = 25 * 60;
    this.focusModeActive = false;
    const container = this.containerEl.children[1];
    container.removeClass("folio-focus-mode");
    this.onOpen();
  }
  renderResourcesSection() {
    const section = this.toolsContainer.createDiv({ cls: "writer-tools-section" });
    section.createDiv({ cls: "writer-tools-section-title", text: "RESOURCES" });
    const resourcesGrid = section.createDiv({ cls: "writer-tools-resources-grid" });
    const resources = [
      { icon: "user", label: "Character", tooltip: "Character development resources" },
      { icon: "bookmark", label: "Narrative", tooltip: "Narrative techniques" },
      { icon: "layout-grid", label: "Structure", tooltip: "Story structure guides" },
      { icon: "lightbulb", label: "Tips", tooltip: "Writing tips" }
    ];
    resources.forEach((resource) => {
      const resourceItem = resourcesGrid.createDiv({ cls: "writer-tools-resource-item" });
      resourceItem.setAttribute("aria-label", resource.tooltip);
      const iconWrapper = resourceItem.createDiv({ cls: "writer-tools-resource-icon" });
      (0, import_obsidian6.setIcon)(iconWrapper, resource.icon);
      resourceItem.createDiv({ cls: "writer-tools-resource-label", text: resource.label });
      resourceItem.addEventListener("click", () => {
        if (resource.label === "Character") {
          this.showCharacterResources();
          return;
        }
        if (resource.label === "Narrative") {
          this.showNarrativeResources();
          return;
        }
        if (resource.label === "Structure") {
          this.showStructureResources();
          return;
        }
        if (resource.label === "Tips") {
          this.showTipsResources();
          return;
        }
        console.log(`${resource.label} clicked`);
      });
    });
  }
  showCharacterResources() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-character-resources");
    const applyIcon = (el, iconName) => {
      (0, import_obsidian6.setIcon)(el, iconName);
      if (!el.querySelector("svg")) {
        (0, import_obsidian6.setIcon)(el, "circle-dot");
      }
    };
    const header = container.createDiv({ cls: "character-resources-header" });
    const headerIcon = header.createSpan({ cls: "character-resources-header-icon" });
    applyIcon(headerIcon, "user");
    header.createSpan({ cls: "character-resources-header-title", text: "Character resources" });
    const backButton = header.createEl("button", { cls: "character-resources-back", text: "Back" });
    backButton.addEventListener("click", () => this.exitCharacterResources());
    const arcsSection = container.createDiv({ cls: "character-resources-section" });
    arcsSection.createDiv({ cls: "character-resources-section-title", text: "Character arcs" });
    const arcsGrid = arcsSection.createDiv({ cls: "character-resources-arc-grid" });
    const arcs = [
      { label: "Moral Ascent", icon: "trending-up" },
      { label: "Moral Descent", icon: "trending-down" },
      { label: "Flat Moral", icon: "minus" },
      { label: "Moral Transformation", icon: "trending-up-down" }
    ];
    arcs.forEach((arc) => {
      const item = arcsGrid.createDiv({ cls: "character-resources-arc-item" });
      const icon = item.createSpan({ cls: "character-resources-card-icon" });
      applyIcon(icon, arc.icon);
      item.createDiv({ cls: "character-resources-arc-label", text: arc.label });
      item.addEventListener("click", () => {
        this.showResourceDetail(arc.label, () => this.showCharacterResources());
      });
    });
    const archetypesSection = container.createDiv({ cls: "character-resources-section is-separated" });
    archetypesSection.createDiv({ cls: "character-resources-section-title", text: "Character archetypes" });
    const campbellSection = archetypesSection.createDiv({ cls: "character-resources-subsection" });
    campbellSection.createDiv({ cls: "character-resources-subtitle", text: "Campbell archetypes" });
    const campbellGrid = campbellSection.createDiv({ cls: "character-resources-grid" });
    const campbellArchetypes = [
      { label: "The Ally", icon: "handshake" },
      { label: "The Herald", icon: "bell" },
      { label: "The Hero (Jung)", icon: "sword" },
      { label: "The Mentor", icon: "graduation-cap" },
      { label: "The Shadow", icon: "moon" },
      { label: "The Shapeshifter", icon: "hat-glasses" },
      { label: "The Threshold Guardian", icon: "shield" },
      { label: "The Trickster", icon: "dice" }
    ];
    campbellArchetypes.forEach((itemData) => {
      const item = campbellGrid.createDiv({ cls: "character-resources-card" });
      const icon = item.createSpan({ cls: "character-resources-card-icon" });
      applyIcon(icon, itemData.icon);
      item.createDiv({ cls: "character-resources-card-label", text: itemData.label });
      item.addEventListener("click", () => {
        this.showResourceDetail(itemData.label, () => this.showCharacterResources());
      });
    });
    const jungSection = archetypesSection.createDiv({ cls: "character-resources-subsection" });
    jungSection.createDiv({ cls: "character-resources-subtitle", text: "Jung archetypes" });
    const jungGrid = jungSection.createDiv({ cls: "character-resources-grid" });
    const jungArchetypes = [
      { label: "The Caregiver", icon: "heart-handshake" },
      { label: "The Creator", icon: "paintbrush" },
      { label: "The Everyman", icon: "users" },
      { label: "The Explorer", icon: "compass" },
      { label: "The Hero", icon: "sword" },
      { label: "The Innocent", icon: "baby" },
      { label: "The Jester", icon: "party-popper" },
      { label: "The Lover", icon: "heart" },
      { label: "The Magician", icon: "wand-2" },
      { label: "The Outlaw", icon: "flame-kindling" },
      { label: "The Ruler", icon: "crown" },
      { label: "The Sage", icon: "book-open" }
    ];
    jungArchetypes.forEach((itemData) => {
      const item = jungGrid.createDiv({ cls: "character-resources-card" });
      const icon = item.createSpan({ cls: "character-resources-card-icon" });
      applyIcon(icon, itemData.icon);
      item.createDiv({ cls: "character-resources-card-label", text: itemData.label });
      item.addEventListener("click", () => {
        this.showResourceDetail(itemData.label, () => this.showCharacterResources());
      });
    });
  }
  exitCharacterResources() {
    const container = this.containerEl.children[1];
    container.removeClass("folio-character-resources");
    this.onOpen();
  }
  showNarrativeResources() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-narrative-resources");
    const applyIcon = (el, iconName) => {
      (0, import_obsidian6.setIcon)(el, iconName);
      if (!el.querySelector("svg")) {
        (0, import_obsidian6.setIcon)(el, "circle-dot");
      }
    };
    const header = container.createDiv({ cls: "narrative-resources-header" });
    const headerIcon = header.createSpan({ cls: "narrative-resources-header-icon" });
    applyIcon(headerIcon, "bookmark");
    header.createSpan({ cls: "narrative-resources-header-title", text: "Narrative resources" });
    const backButton = header.createEl("button", { cls: "narrative-resources-back", text: "Back" });
    backButton.addEventListener("click", () => this.exitNarrativeResources());
    const intro = container.createDiv({ cls: "narrative-resources-intro" });
    intro.createSpan({ text: "Narrative techniques" });
    const groups = [
      {
        title: "Structural Time Manipulation",
        subtitle: "Techniques that reorganize chronology to control information flow.",
        items: [
          { label: "Flashback", icon: "rewind" },
          { label: "Flashforward", icon: "fast-forward" },
          { label: "Foreshadowing", icon: "scan-eye" }
        ],
        note: "These operate on the temporal axis of the narrative. They don\u2019t change events \u2014 they change when the audience receives them."
      },
      {
        title: "Setup / Payoff Mechanics",
        subtitle: "Techniques about planting and resolving narrative information. They\u2019re all about audience prediction vs outcome.",
        items: [
          { label: "Chekhov\u2019s Gun", icon: "bomb" },
          { label: "Red Herring", icon: "fish" },
          { label: "Plot Twist", icon: "rotate-3d" }
        ],
        note: ""
      },
      {
        title: "Resolution Devices",
        subtitle: "Techniques that control how conflict is concluded. Think of these as ending logic frameworks.",
        items: [
          { label: "Deus Ex Machina", icon: "wand-2" },
          { label: "Eucatastrophe", icon: "mountain" },
          { label: "Poetic Justice", icon: "scale" }
        ],
        note: ""
      },
      {
        title: "Style & Delivery Techniques",
        subtitle: "These shape how information is expressed rather than plot structure. These affect reader experience, not plot mechanics.",
        items: [
          { label: "\u201CShow, Don\u2019t Tell\u201D", icon: "eye" },
          { label: "Quibble (Wordplay)", icon: "quote" }
        ],
        note: ""
      }
    ];
    groups.forEach((group) => {
      const card = container.createDiv({ cls: "narrative-resources-card" });
      card.createDiv({ cls: "narrative-resources-card-title", text: group.title });
      card.createDiv({ cls: "narrative-resources-card-subtitle", text: group.subtitle });
      const grid = card.createDiv({ cls: "narrative-resources-grid" });
      group.items.forEach((label) => {
        const item = grid.createDiv({ cls: "narrative-resources-item" });
        const icon = item.createSpan({ cls: "narrative-resources-item-icon" });
        applyIcon(icon, label.icon);
        item.createSpan({ cls: "narrative-resources-item-text", text: label.label });
        item.addEventListener("click", () => {
          this.showResourceDetail(label.label, () => this.showNarrativeResources());
        });
      });
      if (group.note) {
        const note = card.createDiv({ cls: "narrative-resources-note" });
        group.note.split("\n").forEach((line, index) => {
          if (index > 0)
            note.createEl("br");
          note.createSpan({ text: line });
        });
      }
    });
  }
  exitNarrativeResources() {
    const container = this.containerEl.children[1];
    container.removeClass("folio-narrative-resources");
    this.onOpen();
  }
  showStructureResources() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-structure-resources");
    const applyIcon = (el, iconName) => {
      (0, import_obsidian6.setIcon)(el, iconName);
      if (!el.querySelector("svg")) {
        (0, import_obsidian6.setIcon)(el, "circle-dot");
      }
    };
    const header = container.createDiv({ cls: "structure-resources-header" });
    const headerIcon = header.createSpan({ cls: "structure-resources-header-icon" });
    applyIcon(headerIcon, "layout-grid");
    header.createSpan({ cls: "structure-resources-header-title", text: "Structure resources" });
    const backButton = header.createEl("button", { cls: "structure-resources-back", text: "Back" });
    backButton.addEventListener("click", () => this.exitStructureResources());
    const intro = container.createDiv({ cls: "structure-resources-intro" });
    intro.createSpan({ text: "Story architecture" });
    const groups = [
      {
        title: "Archetypal Character Journeys",
        subtitle: "Frameworks that model internal transformation and mythic character evolution rather than strict plot beats.",
        items: [
          { label: "The Hero\u2019s Journey", icon: "map" },
          { label: "Dan Harmon Story Circle", icon: "orbit" }
        ]
      },
      {
        title: "Dramatic Tension Architectures",
        subtitle: "Models that describe how narrative pressure rises and falls across the story.",
        items: [
          { label: "Freytag\u2019s Pyramid", icon: "triangle" },
          { label: "Fichtean Curve", icon: "line-chart" },
          { label: "Three Act Structure", icon: "columns-3" },
          { label: "Kish\u014Dtenketsu", icon: "route" }
        ]
      },
      {
        title: "Commercial Beat Frameworks",
        subtitle: "Prescriptive systems designed for audience engagement, genre expectations, and market-friendly pacing.",
        items: [
          { label: "Save the Cat", icon: "cat" },
          { label: "Seven Point Structure", icon: "wheat" },
          { label: "Pulp Formula", icon: "book" },
          { label: "McKee Story paradigm", icon: "book-open" },
          { label: "Into the Woods structure", icon: "trees" }
        ]
      },
      {
        title: "Narrative Geometry / Experimental Structures",
        subtitle: "Architectural choices that shape how perspective, time, or reality are presented.",
        items: [
          { label: "Frame Narrative", icon: "scan" },
          { label: "Nonlinear Structure", icon: "line-squiggle" },
          { label: "Rashomon Structure", icon: "shrink" },
          { label: "In Medias Res", icon: "git-commit-horizontal" }
        ]
      }
    ];
    groups.forEach((group) => {
      const card = container.createDiv({ cls: "structure-resources-card" });
      card.createDiv({ cls: "structure-resources-card-title", text: group.title });
      card.createDiv({ cls: "structure-resources-card-subtitle", text: group.subtitle });
      const grid = card.createDiv({ cls: "structure-resources-grid" });
      group.items.forEach((itemData) => {
        const item = grid.createDiv({ cls: "structure-resources-item" });
        const icon = item.createSpan({ cls: "structure-resources-item-icon" });
        applyIcon(icon, itemData.icon);
        item.createSpan({ cls: "structure-resources-item-text", text: itemData.label });
        item.addEventListener("click", () => {
          this.showResourceDetail(itemData.label, () => this.showStructureResources());
        });
      });
    });
  }
  exitStructureResources() {
    const container = this.containerEl.children[1];
    container.removeClass("folio-structure-resources");
    this.onOpen();
  }
  showTipsResources() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-tips-resources");
    const applyIcon = (el, iconName) => {
      (0, import_obsidian6.setIcon)(el, iconName);
      if (!el.querySelector("svg")) {
        (0, import_obsidian6.setIcon)(el, "circle-dot");
      }
    };
    const header = container.createDiv({ cls: "tips-resources-header" });
    const headerIcon = header.createSpan({ cls: "tips-resources-header-icon" });
    applyIcon(headerIcon, "lightbulb");
    header.createSpan({ cls: "tips-resources-header-title", text: "Writing tips" });
    const backButton = header.createEl("button", { cls: "tips-resources-back", text: "Back" });
    backButton.addEventListener("click", () => this.exitTipsResources());
    const intro = container.createDiv({ cls: "tips-resources-intro" });
    intro.createSpan({ text: "Writing tips" });
    const description = container.createDiv({ cls: "tips-resources-description" });
    description.createSpan({
      text: "Practical craft guidance focused on sentence-level execution, clarity of communication, and reader impact. Unlike structural frameworks, this category deals with how language operates moment to moment \u2014 voice, rhythm, precision, and rhetorical control. These tips refine technique inside paragraphs rather than shaping the macro architecture of a story."
    });
    const gridCard = container.createDiv({ cls: "tips-resources-card" });
    const grid = gridCard.createDiv({ cls: "tips-resources-grid" });
    const tips = [
      { label: "Argumentation (tips)", icon: "scale" },
      { label: "Description (tips)", icon: "image" },
      { label: "Dialogue (tips)", icon: "message-circle" },
      { label: "Exposition (tips)", icon: "file-text" },
      { label: "Narration (tips)", icon: "book-open" },
      { label: "Persuasion (tips)", icon: "megaphone" }
    ];
    tips.forEach((tip) => {
      const item = grid.createDiv({ cls: "tips-resources-item" });
      const icon = item.createSpan({ cls: "tips-resources-item-icon" });
      applyIcon(icon, tip.icon);
      item.createSpan({ cls: "tips-resources-item-text", text: tip.label });
      item.addEventListener("click", () => {
        this.showResourceDetail(tip.label, () => this.showTipsResources());
      });
    });
    container.createDiv({ cls: "tips-resources-divider" });
    container.createDiv({ cls: "tips-resources-subtitle", text: "Common pitfalls" });
    const pitfallsCard = container.createDiv({ cls: "tips-resources-card" });
    const pitfallsGrid = pitfallsCard.createDiv({ cls: "tips-resources-grid" });
    const pitfalls = [
      { label: "Character Pitfalls", icon: "user" },
      { label: "Character Arc Pitfalls", icon: "route" },
      { label: "Narrative Technique Pitfalls", icon: "book-open" },
      { label: "Structure Pitfalls", icon: "layout-grid" },
      { label: "Writing-Level Pitfalls", icon: "pen-line" }
    ];
    pitfalls.forEach((pitfall) => {
      const item = pitfallsGrid.createDiv({ cls: "tips-resources-item" });
      const icon = item.createSpan({ cls: "tips-resources-item-icon" });
      applyIcon(icon, pitfall.icon);
      item.createSpan({ cls: "tips-resources-item-text", text: pitfall.label });
      item.addEventListener("click", () => {
        this.showResourceDetail(pitfall.label, () => this.showTipsResources());
      });
    });
  }
  exitTipsResources() {
    const container = this.containerEl.children[1];
    container.removeClass("folio-tips-resources");
    this.onOpen();
  }
  showResourceDetail(title, onBack) {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-resource-detail");
    const header = container.createDiv({ cls: "resource-detail-header" });
    const headingText = this.getResourceHeading(title);
    const headingIcon = header.createSpan({ cls: "resource-detail-heading-icon" });
    (0, import_obsidian6.setIcon)(headingIcon, this.getResourceIcon(title));
    header.createSpan({ cls: "resource-detail-heading", text: headingText });
    const backButton = header.createEl("button", { cls: "resource-detail-back", text: "Back" });
    backButton.addEventListener("click", () => {
      container.removeClass("folio-resource-detail");
      onBack();
    });
    if (title === "The Hero") {
      this.renderHeroDetail(container);
      return;
    }
    if (title === "The Caregiver") {
      this.renderCaregiverDetail(container);
      return;
    }
    if (title === "The Creator") {
      this.renderCreatorDetail(container);
      return;
    }
    if (title === "The Everyman") {
      this.renderEverymanDetail(container);
      return;
    }
    if (title === "The Explorer") {
      this.renderExplorerDetail(container);
      return;
    }
    if (title === "The Hero (Jung)") {
      this.renderHeroJungDetail(container);
      return;
    }
    if (title === "The Innocent") {
      this.renderInnocentDetail(container);
      return;
    }
    if (title === "The Jester") {
      this.renderJesterDetail(container);
      return;
    }
    if (title === "The Lover") {
      this.renderLoverDetail(container);
      return;
    }
    if (title === "The Magician") {
      this.renderMagicianDetail(container);
      return;
    }
    if (title === "The Outlaw") {
      this.renderOutlawDetail(container);
      return;
    }
    if (title === "The Ruler") {
      this.renderRulerDetail(container);
      return;
    }
    if (title === "The Sage") {
      this.renderSageDetail(container);
      return;
    }
    if (title === "Moral Ascent") {
      this.renderMoralAscentDetail(container);
      return;
    }
    if (title === "Moral Descent") {
      this.renderMoralDescentDetail(container);
      return;
    }
    if (title === "Flat Moral") {
      this.renderFlatMoralDetail(container);
      return;
    }
    if (title === "Moral Transformation") {
      this.renderMoralTransformationDetail(container);
      return;
    }
    if (title === "Character Pitfalls") {
      this.renderPitfallsDetail(container, "Character Pitfalls", [
        "Flat characters",
        "Inconsistent motivation",
        "Unearned redemption",
        "Passive protagonists",
        "Villain without agency",
        "Archetype clich\xE9s"
      ]);
      return;
    }
    if (title === "Character Arc Pitfalls") {
      this.renderPitfallsDetail(container, "Character Arc Pitfalls", [
        "No real change",
        "Change without cause",
        "Moral whiplash",
        "Transformation too late",
        "Arc contradicts theme"
      ]);
      return;
    }
    if (title === "Narrative Technique Pitfalls") {
      this.renderPitfallsDetail(container, "Narrative Technique Pitfalls", [
        "Foreshadowing too obvious",
        "Plot twists without setup",
        "Red herrings that waste time",
        "Deus ex machina abuse",
        "Flashbacks killing momentum"
      ]);
      return;
    }
    if (title === "Structure Pitfalls") {
      this.renderPitfallsDetail(container, "Structure Pitfalls", [
        "Act breaks without tension",
        "Sagging middle",
        "Climax too early / too late",
        "Resolution without consequence",
        "Structure fighting the story"
      ]);
      return;
    }
    if (title === "Writing-Level Pitfalls") {
      this.renderPitfallsDetail(container, "Writing-Level Pitfalls", [
        "Over-exposition",
        "On-the-nose dialogue",
        "Telling instead of showing",
        "Purple prose",
        "Inconsistent tone"
      ]);
      return;
    }
    if (title === "Argumentation (tips)") {
      this.renderTipsDetail(container, {
        introTitle: "What is argumentative writing?",
        intro: [
          "Argumentative writing focuses on presenting, supporting, and defending a position with the goal of persuading the reader through reasoned discourse.",
          "It is essential for essays, opinion pieces, critical analysis, and persuasive nonfiction."
        ],
        techniques: [
          "Logical reasoning \u2014 Use deductive, inductive, or analogical reasoning to support claims and conclusions.",
          "Evidence and examples \u2014 Support arguments with facts, data, statistics, real-world examples, or credible sources.",
          "Counterarguments and refutation \u2014 Anticipate opposing views and address them directly to strengthen overall credibility.",
          "Emotional appeal \u2014 Engage the reader\u2019s emotions, values, or beliefs to reinforce logical points.",
          "Rhetorical strategies \u2014 Apply ethos (credibility), pathos (emotion), and logos (logic) strategically.",
          "Clear structure and organization \u2014 Present arguments in a coherent order with clear topic sentences and conclusions.",
          "Clarity and concision \u2014 Avoid unnecessary complexity; express ideas precisely and directly.",
          "Ethical responsibility \u2014 Ground arguments in honesty and respect for the audience\u2019s values and intelligence."
        ]
      });
      return;
    }
    if (title === "Description (tips)") {
      this.renderTipsDetail(container, {
        introTitle: "What is descriptive writing?",
        intro: [
          "Descriptive writing creates vivid mental images by engaging the reader\u2019s senses, emotions, and imagination. Its purpose is immersion rather than explanation."
        ],
        techniques: [
          "Sensory imagery \u2014 Appeal to sight, sound, touch, taste, and smell to create a multidimensional experience.",
          "Figurative language \u2014 Use metaphor, simile, personification, and imagery to enrich atmosphere and tone.",
          "Specificity and detail \u2014 Favor precise, concrete details over generic or abstract descriptions.",
          "Show, don\u2019t tell \u2014 Convey meaning through action, sensory detail, and implication rather than direct explanation.",
          "Point of view awareness \u2014 Filter description through the narrator\u2019s perspective, biases, and limitations.",
          "Emotional resonance \u2014 Connect description to characters\u2019 internal reactions and emotional states.",
          "Narrative pacing \u2014 Balance descriptive passages with action and dialogue to maintain momentum.",
          "Symbolism and motifs \u2014 Use recurring imagery to reinforce theme and meaning."
        ]
      });
      return;
    }
    if (title === "Dialogue (tips)") {
      this.renderTipsDetail(container, {
        introTitle: "What is effective dialogue?",
        intro: [
          "Effective dialogue creates believable conversations that reveal character, advance plot, and convey subtext without sounding artificial or expository."
        ],
        techniques: [
          "Distinct character voice \u2014 Give each character unique speech patterns, vocabulary, and tone.",
          "Subtext \u2014 Allow meaning to exist beneath the spoken words through implication and tension.",
          "Natural flow \u2014 Imitate real conversational rhythm without reproducing real speech verbatim.",
          "Rhythm and cadence \u2014 Vary sentence length and pacing to reflect emotional intensity.",
          "Conflict and tension \u2014 Use disagreement, power imbalance, or competing goals to energize exchanges.",
          "Show, don\u2019t tell \u2014 Reveal emotion and motivation through what is said \u2014 and what is avoided.",
          "Subtle exposition \u2014 Embed necessary information naturally within conversation.",
          "Authenticity and realism \u2014 Reflect cultural, social, and contextual speech patterns appropriately."
        ]
      });
      return;
    }
    if (title === "Exposition (tips)") {
      this.renderTipsDetail(container, {
        introTitle: "What is exposition?",
        intro: [
          "Exposition provides essential background information, context, or history needed for the audience to understand the story world without disrupting narrative flow."
        ],
        techniques: [
          "Narrative summary \u2014 Compress complex information into concise overviews.",
          "Flashbacks \u2014 Reveal past events that directly inform present actions or motivations.",
          "Dialogue-based exposition \u2014 Deliver information through natural conversation rather than narration.",
          "Descriptive context \u2014 Use sensory detail to establish setting, culture, or historical background.",
          "Prologues or introductory sections \u2014 Present foundational information before the main narrative begins.",
          "Gradual information release \u2014 Distribute exposition strategically to avoid overload.",
          "Integrated backstory \u2014 Weave background details into character thoughts or actions.",
          "Worldbuilding \u2014 Establish social, political, cultural, or historical frameworks that support the story."
        ]
      });
      return;
    }
    if (title === "Narration (tips)") {
      this.renderTipsDetail(container, {
        introTitle: "What is narration?",
        intro: [
          "Narration refers to how a story is told: the voice, perspective, structure, and style that shape how the reader experiences events."
        ],
        techniques: [
          "Point of view \u2014 Choose first person, second person, or third person (limited or omniscient) deliberately.",
          "Narrative structure \u2014 Organize events using linear, nonlinear, framed, or experimental sequencing.",
          "Tone and atmosphere \u2014 Establish emotional mood through diction, imagery, and rhythm.",
          "Characterization \u2014 Reveal character through actions, internal thought, and reaction.",
          "Foreshadowing and suspense \u2014 Plant hints and manage anticipation to sustain engagement.",
          "Symbolism and imagery \u2014 Use recurring symbols to convey deeper meaning.",
          "Voice and style \u2014 Develop a distinctive narrative presence consistent with theme and perspective.",
          "Narrative pacing \u2014 Control speed and tension through sentence structure, scene length, and transitions."
        ]
      });
      return;
    }
    if (title === "Persuasion (tips)") {
      this.renderTipsDetail(container, {
        introTitle: "What is persuasive writing?",
        intro: [
          "Persuasive writing aims to influence beliefs, attitudes, or actions by combining logic, emotion, credibility, and narrative clarity."
        ],
        techniques: [
          "Emotional appeal \u2014 Engage feelings such as empathy, fear, hope, or desire.",
          "Storytelling \u2014 Use anecdotes or narratives to humanize abstract ideas.",
          "Social proof \u2014 Reference collective agreement, trends, or testimonials.",
          "Authority \u2014 Establish credibility through expertise or reputable sources.",
          "Repetition \u2014 Reinforce key ideas to increase memorability.",
          "Persuasive language \u2014 Choose words that convey urgency, clarity, and emotional weight.",
          "Call to action \u2014 Direct the reader toward a specific response or behavior.",
          "Addressing counterarguments \u2014 Acknowledge and refute opposing views to strengthen trust."
        ]
      });
      return;
    }
    if (title === "Flashback") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is a Flashback?",
        intro: [
          "A flashback interrupts the present narrative to show events from the past. It provides context, emotional depth, or critical information that reshapes how the audience understands current events."
        ],
        core: [
          "Temporal shift to the past",
          "Reveals backstory",
          "Adds emotional or thematic weight",
          "Recontextualizes present actions"
        ],
        coreNote: "Flashbacks change understanding, not events.",
        narrativeFunction: [
          "Reveal motivation",
          "Explain relationships",
          "Deepen character psychology",
          "Withhold and release information strategically"
        ],
        risksTitle: "Common risks",
        risks: [
          "Interrupting narrative momentum",
          "Overexplaining",
          "Redundancy with present action"
        ],
        examplesTitle: "Flashback Examples",
        examples: [
          "Lost",
          "The Godfather Part II",
          "Citizen Kane",
          "Arrow",
          "Eternal Sunshine of the Spotless Mind"
        ]
      });
      return;
    }
    if (title === "Flashforward") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is a Flashforward?",
        intro: [
          "A flashforward reveals events that will occur later in the story. It creates anticipation, tension, or dramatic irony by showing consequences before causes."
        ],
        core: [
          "Temporal jump to the future",
          "Creates suspense",
          "Reframes current decisions",
          "Often partial or ambiguous"
        ],
        narrativeFunction: [
          "Build anticipation",
          "Signal inevitability",
          "Create dramatic irony",
          "Frame the narrative outcome"
        ],
        risksTitle: "Common risks",
        risks: [
          "Spoiling tension",
          "Removing mystery",
          "Confusing chronology"
        ],
        examplesTitle: "Flashforward Examples",
        examples: [
          "Breaking Bad (cold opens)",
          "How to Get Away with Murder",
          "Arrival",
          "Six Feet Under",
          "The Book Thief"
        ]
      });
      return;
    }
    if (title === "Foreshadowing") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is Foreshadowing?",
        intro: [
          "Foreshadowing plants subtle hints about future events. These clues may be symbolic, visual, verbal, or thematic.",
          "The goal is preparation, not prediction."
        ],
        core: [
          "Early setup",
          "Subtlety",
          "Payoff later in the story",
          "Often unnoticed on first read"
        ],
        narrativeFunction: [
          "Create cohesion",
          "Make twists feel earned",
          "Build subconscious anticipation",
          "Reinforce themes"
        ],
        risksTitle: "Common risks",
        risks: [
          "Being too obvious",
          "Making outcomes predictable",
          "Heavy-handed symbolism"
        ],
        examplesTitle: "Foreshadowing Examples",
        examples: [
          "Romeo and Juliet",
          "Jaws (early warnings)",
          "Breaking Bad (visual cues)",
          "Of Mice and Men",
          "The Sixth Sense"
        ]
      });
      return;
    }
    if (title === "Chekhov\u2019s Gun") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is Chekhov\u2019s Gun?",
        intro: [
          "Chekhov\u2019s Gun states that every significant element introduced in a story should have a purpose. If a detail is highlighted, it must eventually matter."
        ],
        core: [
          "Meaningful setup",
          "Inevitable payoff",
          "Narrative economy",
          "Focused attention"
        ],
        narrativeFunction: [
          "Eliminate filler",
          "Create satisfying resolutions",
          "Train audience attention",
          "Strengthen narrative cohesion"
        ],
        risksTitle: "Common risks",
        risks: [
          "Over-signaling importance",
          "Forced payoff",
          "Red herrings mistaken for setup"
        ],
        examplesTitle: "Chekhov\u2019s Gun Examples",
        examples: [
          "The rifle in Chekhov\u2019s plays",
          "The ring in Lord of the Rings",
          "The knife in Psycho",
          "The coin in No Country for Old Men"
        ]
      });
      return;
    }
    if (title === "Red Herring") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is a Red Herring?",
        intro: [
          "A red herring is a deliberate misdirection that leads the audience to form false assumptions. It distracts from the true narrative outcome."
        ],
        core: [
          "False emphasis",
          "Misdirection",
          "Plausibility",
          "Temporary relevance"
        ],
        narrativeFunction: [
          "Create mystery",
          "Increase suspense",
          "Hide twists",
          "Manipulate expectations"
        ],
        risksTitle: "Common risks",
        risks: [
          "Feeling unfair",
          "Wasting narrative time",
          "Breaking trust with the audience"
        ],
        examplesTitle: "Red Herring Examples",
        examples: [
          "Murder mystery suspects",
          "Knives Out",
          "Sherlock Holmes stories",
          "Gone Girl",
          "The Girl with the Dragon Tattoo"
        ]
      });
      return;
    }
    if (title === "Plot Twist") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is a Plot Twist?",
        intro: [
          "A plot twist is an unexpected development that recontextualizes the story. It surprises the audience while remaining logically consistent."
        ],
        core: [
          "Surprise",
          "Retrospective logic",
          "Setup and payoff",
          "Shift in perspective"
        ],
        narrativeFunction: [
          "Reframe the story",
          "Shock the audience",
          "Elevate stakes",
          "Reveal hidden truth"
        ],
        risksTitle: "Common risks",
        risks: [
          "Twist for shock only",
          "Lack of setup",
          "Undermining character logic"
        ],
        examplesTitle: "Plot Twist Examples",
        examples: [
          "The Sixth Sense",
          "Fight Club",
          "The Others",
          "Oldboy",
          "Shutter Island"
        ]
      });
      return;
    }
    if (title === "Deus Ex Machina") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is Deus Ex Machina?",
        intro: [
          "Deus ex Machina resolves conflict through an external, unexpected intervention that is not properly set up within the story."
        ],
        core: [
          "Sudden resolution",
          "External force",
          "Minimal foreshadowing",
          "Breaks causality"
        ],
        narrativeFunction: [
          "Resolve unsolvable conflicts",
          "Deliver moral or divine judgment"
        ],
        narrativeNote: "In modern storytelling, it is often discouraged.",
        risksTitle: "Common risks",
        risks: [
          "Undermining stakes",
          "Invalidating character effort",
          "Breaking narrative credibility"
        ],
        examplesTitle: "Deus Ex Machina Examples",
        examples: [
          "Ancient Greek theater",
          "War of the Worlds (original ending)",
          "Certain superhero rescues",
          "Mythological interventions"
        ]
      });
      return;
    }
    if (title === "Eucatastrophe") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is Eucatastrophe?",
        intro: [
          "Eucatastrophe is a sudden positive reversal at the story\u2019s darkest moment. Unlike Deus ex Machina, it feels meaningful and earned.",
          "The term was coined by J.R.R. Tolkien."
        ],
        core: [
          "Sudden hope",
          "Emotional release",
          "Moral or thematic payoff",
          "Earned resolution"
        ],
        narrativeFunction: [
          "Affirm hope",
          "Deliver catharsis",
          "Reinforce moral order",
          "Reward endurance"
        ],
        risksTitle: "Common risks",
        risks: [
          "Confusing it with Deus ex Machina",
          "Insufficient setup",
          "Over-sentimentality"
        ],
        examplesTitle: "Eucatastrophe Examples",
        examples: [
          "The Lord of the Rings",
          "The Lion, the Witch and the Wardrobe",
          "It\u2019s a Wonderful Life",
          "Harry Potter finales"
        ]
      });
      return;
    }
    if (title === "Poetic Justice") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is Poetic Justice?",
        intro: [
          "Poetic Justice ensures that characters receive outcomes that fittingly reflect their actions, values, or flaws."
        ],
        core: [
          "Moral symmetry",
          "Cause-and-effect resolution",
          "Thematic reinforcement",
          "Emotional satisfaction"
        ],
        narrativeFunction: [
          "Reinforce theme",
          "Deliver moral closure",
          "Satisfy audience expectations",
          "Balance narrative consequences"
        ],
        risksTitle: "Common risks",
        risks: [
          "Predictability",
          "Moral simplification",
          "Heavy-handed messaging"
        ],
        examplesTitle: "Poetic Justice Examples",
        examples: [
          "Villains undone by their own schemes",
          "Fables and fairy tales",
          "Crime fiction endings",
          "Shakespearean punishment arcs"
        ]
      });
      return;
    }
    if (title === "\u201CShow, Don\u2019t Tell\u201D") {
      this.renderTechniqueDetail(container, {
        introTitle: "What does \u201CShow, Don\u2019t Tell\u201D mean?",
        intro: [
          "This principle encourages conveying information through action, dialogue, and sensory detail rather than direct explanation."
        ],
        core: [
          "Implicit storytelling",
          "Sensory detail",
          "Active scenes",
          "Reader inference"
        ],
        narrativeFunction: [
          "Increase immersion",
          "Engage the reader",
          "Strengthen emotional impact",
          "Avoid exposition overload"
        ],
        risksTitle: "Common risks",
        risks: [
          "Obscuring clarity",
          "Over-description",
          "Avoiding necessary exposition"
        ],
        examplesTitle: "Show, Don\u2019t Tell Examples",
        examples: [
          "Character emotion shown through action",
          "Visual storytelling in film",
          "Minimalist prose styles",
          "Hemingway\u2019s writing"
        ]
      });
      return;
    }
    if (title === "Quibble (Wordplay)") {
      this.renderTechniqueDetail(container, {
        introTitle: "What is a Quibble?",
        intro: [
          "A quibble is playful or clever use of language, often relying on ambiguity, double meanings, or rhetorical tricks."
        ],
        core: [
          "Linguistic play",
          "Humor or irony",
          "Verbal agility",
          "Ambiguity"
        ],
        narrativeFunction: [
          "Add wit",
          "Reveal character intelligence",
          "Create tonal contrast",
          "Engage the audience linguistically"
        ],
        risksTitle: "Common risks",
        risks: [
          "Overuse",
          "Breaking tone",
          "Confusing meaning"
        ],
        examplesTitle: "Quibble Examples",
        examples: [
          "Shakespearean wordplay",
          "Oscar Wilde",
          "Legal or political dialogue",
          "Screwball comedies"
        ]
      });
      return;
    }
    if (title === "The Hero\u2019s Journey") {
      this.renderStructureDetail(container, {
        introTitle: "What is the Hero\u2019s Journey?",
        intro: [
          "The Hero\u2019s Journey is a mythic structure that frames story as transformation: a character leaves the familiar, faces trials, dies symbolically, and returns changed. It\u2019s less a rigid formula than a map for meaning and growth."
        ],
        core: [
          "A movement from comfort to challenge to return",
          "External trials that force internal change",
          "Symbolic death and rebirth",
          "A concluding \u201Cgift\u201D brought back to the world"
        ],
        stepsTitle: "Steps (classic model)",
        stepGroups: [
          {
            title: "ACT I",
            items: [
              {
                title: "Ordinary World",
                body: "Establish the Hero\u2019s baseline life, limitations, and unmet need.",
                icon: "earth"
              },
              {
                title: "Call to Adventure",
                body: "A disruption offers a mission, opportunity, or threat that demands response.",
                icon: "phone-incoming"
              },
              {
                title: "Refusal of the Call",
                body: "Fear, duty, or doubt causes hesitation; the Hero resists change.",
                icon: "phone-off"
              },
              {
                title: "Meeting the Mentor",
                body: "Guidance appears: training, tools, wisdom, or encouragement.",
                icon: "graduation-cap"
              },
              {
                title: "Crossing the First Threshold",
                body: "The Hero commits and enters the \u201Cspecial world,\u201D leaving the old life behind.",
                icon: "brick-wall"
              }
            ]
          },
          {
            title: "ACT II",
            items: [
              {
                title: "Tests, Allies, Enemies",
                body: "The rules of the new world are learned; relationships and rivalries form.",
                icon: "line-squiggle"
              },
              {
                title: "Approach to the Inmost Cave",
                body: "Preparation for the central crisis; tensions tighten and stakes clarify.",
                icon: "mountain"
              },
              {
                title: "Ordeal",
                body: "A major confrontation with death, failure, or the deepest fear.",
                icon: "swords"
              },
              {
                title: "Reward (Seizing the Sword)",
                body: "The Hero gains something: knowledge, power, object, love, or self-belief.",
                icon: "trophy"
              }
            ]
          },
          {
            title: "ACT III",
            items: [
              {
                title: "The Road Back",
                body: "Consequences arrive; the Hero must return with the reward under pressure.",
                icon: "arrow-big-left"
              },
              {
                title: "Resurrection",
                body: "A final test proves transformation. The Hero confronts the core flaw one last time.",
                icon: "user-round-plus"
              },
              {
                title: "Return with the Elixir",
                body: "The Hero returns changed, bringing value to others: healing, truth, freedom, hope.",
                icon: "gem"
              }
            ]
          }
        ],
        whyTitle: "Why this works",
        why: "These steps externalize inner change: the world forces the Hero to become someone new.",
        examplesTitle: "Hero\u2019s Journey Examples",
        examples: [
          "Star Wars",
          "The Matrix",
          "The Lord of the Rings",
          "Moana",
          "Harry Potter"
        ]
      });
      return;
    }
    if (title === "Dan Harmon Story Circle") {
      this.renderStructureDetail(container, {
        introTitle: "What is the Story Circle?",
        intro: [
          "The Story Circle compresses transformation into a repeatable loop: a character wants something, leaves comfort, pays a price, and returns changed. It\u2019s designed to be practical for episodes as well as features."
        ],
        core: [
          "Motivation-driven steps",
          "Clear cause-and-effect",
          "Repeatable structure (especially for TV)",
          "Emphasis on change and cost"
        ],
        stepsTitle: "Steps (8-step circle)",
        steps: [
          { title: "YOU (COMFORT)", body: "Establish the character\u2019s normal world and identity.", icon: "fish" },
          { title: "NEED (DESIRE)", body: "The character wants or needs something that disrupts balance.", icon: "candy" },
          { title: "GO (ENTER UNFAMILIAR)", body: "The character leaves comfort and enters a new situation.", icon: "log-in" },
          { title: "SEARCH (ADAPT)", body: "The character explores the new world and tries strategies that may fail.", icon: "map" },
          { title: "FIND (GET WHAT THEY WANTED)", body: "The character achieves the goal\u2014or seems to.", icon: "search-check" },
          { title: "TAKE (PAY A PRICE)", body: "There is a cost: sacrifice, loss, compromise, or consequence.", icon: "hand-coins" },
          { title: "RETURN (BACK TO FAMILIAR)", body: "The character returns to a version of their old world.", icon: "arrow-big-left" },
          { title: "CHANGE (TRANSFORMED)", body: "The character is different: wiser, broken, empowered, humbled, etc.", icon: "user-pen" }
        ],
        examplesTitle: "Story Circle Examples",
        examples: [
          "Episodic TV arcs",
          "Community",
          "Rick and Morty",
          "Character-centered short stories"
        ]
      });
      return;
    }
    if (title === "Three Act Structure") {
      this.renderStructureDetail(container, {
        introTitle: "What is the Three Act Structure?",
        intro: [
          "A story divided into Setup, Confrontation, and Resolution. It\u2019s the most common modern narrative skeleton because it aligns with audience attention and escalating stakes."
        ],
        stepsTitle: "Steps (typical beats)",
        numberedSteps: true,
        steps: [
          "ACT I \u2014 Setup",
          "1. Opening / Status Quo \u2014 Introduce the protagonist, their world, and the core problem-space.",
          "2. Inciting Incident \u2014 A disruption creates a new problem or opportunity.",
          "3. Debate / Refusal \u2014 The protagonist hesitates, resists, or explores alternatives.",
          "4. Act I Break (Commitment) \u2014 The protagonist commits and can\u2019t go back.",
          "ACT II \u2014 Confrontation",
          "5. Rising Complications \u2014 Obstacles escalate; stakes increase; plans fail.",
          "6. Midpoint Shift \u2014 A major reveal or reversal changes the story\u2019s direction and intensity.",
          "7. Bad Guys Close In / Pressure Peaks \u2014 Consequences compound; resources thin; relationships strain.",
          "8. All Is Lost \u2014 The lowest point; apparent defeat or devastating cost.",
          "9. Dark Night of the Soul \u2014 Reflection and decision: who will the protagonist become?",
          "ACT III \u2014 Resolution",
          "10. Act III Break (New plan) \u2014 The protagonist acts with new clarity, courage, or strategy.",
          "11. Climax \u2014 The decisive confrontation that resolves the central conflict.",
          "12. Denouement \u2014 Aftermath: new equilibrium; consequences; thematic closure."
        ],
        examplesTitle: "Three Act Examples",
        examples: [
          "Most Hollywood films",
          "Contemporary commercial novels",
          "Studio-driven storytelling"
        ]
      });
      return;
    }
    if (title === "Freytag\u2019s Pyramid") {
      this.renderStructureDetail(container, {
        introTitle: "What is Freytag\u2019s Pyramid?",
        intro: [
          "A classical five-part model of dramatic tension, often associated with tragedy. It formalizes a rise to climax followed by a decline into resolution."
        ],
        stepsTitle: "Steps (5-part model)",
        steps: [
          "1. Exposition \u2014 Introduce setting, characters, and the initial balance.",
          "2. Rising Action \u2014 Complications build; conflict intensifies; choices narrow.",
          "3. Climax \u2014 The turning point\u2014the peak tension where fate changes direction.",
          "4. Falling Action \u2014 Consequences unfold; momentum turns toward inevitable outcome.",
          "5. Denouement / Catastrophe \u2014 Final resolution, often with moral or tragic closure."
        ],
        examplesTitle: "Freytag Examples",
        examples: [
          "Classical tragedies",
          "Shakespearean drama",
          "Traditional stage plays"
        ]
      });
      return;
    }
    if (title === "Fichtean Curve") {
      this.renderStructureDetail(container, {
        introTitle: "What is the Fichtean Curve?",
        intro: [
          "A structure built from a chain of escalating crises with minimal exposition. The story begins close to conflict and continues increasing pressure until climax."
        ],
        stepsTitle: "Steps (crisis chain)",
        steps: [
          "1. Immediate Hook / First Crisis \u2014 Start near a problem, not far before it.",
          "2. Crisis Escalation 1 \u2014 The protagonist responds; the response creates new complications.",
          "3. Crisis Escalation 2 \u2014 Stakes rise; setbacks compound; options shrink.",
          "4. Crisis Escalation 3 \u2014 Pressure intensifies; emotional and practical costs deepen.",
          "5. Major Crisis / Low Point \u2014 A near-defeat moment that forces a decisive shift.",
          "6. Climax \u2014 The protagonist commits fully and confronts the core conflict.",
          "7. Short Resolution \u2014 Quick wrap-up; consequences and new stability."
        ],
        examplesTitle: "Fichtean Curve Examples",
        examples: [
          "Thrillers",
          "Page-turner genre fiction",
          "Serialized storytelling"
        ]
      });
      return;
    }
    if (title === "Kish\u014Dtenketsu") {
      this.renderStructureDetail(container, {
        introTitle: "What is Kish\u014Dtenketsu?",
        intro: [
          "Kish\u014Dtenketsu is a four-part structure that emphasizes development and contrast rather than conflict. It\u2019s common in East Asian storytelling and works well for narratives driven by discovery, theme, or perspective."
        ],
        stepsTitle: "Steps (4-part model)",
        steps: [
          "1. Ki (Introduction) \u2014 Establish the situation, characters, and core idea.",
          "2. Sh\u014D (Development) \u2014 Expand the situation; deepen detail and context without major disruption.",
          "3. Ten (Turn / Twist) \u2014 Introduce a surprising contrast or shift: a new angle, reveal, or reframing event.",
          "4. Ketsu (Conclusion) \u2014 Synthesize: show how the contrast changes meaning; resolve by integration rather than victory."
        ],
        examplesTitle: "Kish\u014Dtenketsu Examples",
        examples: [
          "Many slice-of-life stories",
          "Certain anime and manga arcs",
          "Essays or thematic short fiction",
          "Some puzzle-like narratives"
        ]
      });
      return;
    }
    if (title === "Save the Cat") {
      this.renderStructureDetail(container, {
        introTitle: "What is Save the Cat?",
        intro: [
          "Save the Cat is a commercial beat sheet designed to maximize audience engagement. It focuses on emotional timing, clarity, and likeability, especially for film and genre fiction."
        ],
        core: [
          "Strong emotional beats",
          "Clear pacing",
          "Audience empathy",
          "Market-tested structure"
        ],
        stepsTitle: "Steps (15-beat model)",
        steps: [
          "1. Opening Image \u2014 A snapshot of the protagonist\u2019s world before change.",
          "2. Theme Stated \u2014 A line or moment hints at the story\u2019s central lesson.",
          "3. Setup \u2014 Introduce characters, flaws, relationships, and stakes.",
          "4. Catalyst \u2014 The inciting incident that disrupts normal life.",
          "5. Debate \u2014 The protagonist hesitates and weighs options.",
          "6. Break into Act II \u2014 Commitment to the journey.",
          "7. B Story \u2014 A secondary plot, often emotional or relational.",
          "8. Fun and Games \u2014 The \u201Cpromise of the premise\u201D; the story delivers on genre.",
          "9. Midpoint \u2014 A major reversal: false victory or false defeat.",
          "10. Bad Guys Close In \u2014 Pressure increases; plans unravel.",
          "11. All Is Lost \u2014 Apparent defeat; emotional or literal low point.",
          "12. Dark Night of the Soul \u2014 Reflection and internal reckoning.",
          "13. Break into Act III \u2014 New insight leads to decisive action.",
          "14. Finale \u2014 The protagonist applies what they\u2019ve learned to win or lose meaningfully.",
          "15. Final Image \u2014 A mirror of the opening image, showing change."
        ],
        examplesTitle: "Save the Cat Examples",
        examples: [
          "Most studio films",
          "Romantic comedies",
          "High-concept genre movies",
          "Animated features"
        ]
      });
      return;
    }
    if (title === "Seven Point Structure") {
      this.renderStructureDetail(container, {
        introTitle: "What is the Seven Point Structure?",
        intro: [
          "A clean, flexible structure focused on cause-and-effect turning points. It emphasizes clarity and momentum."
        ],
        core: [
          "Fewer beats, higher impact",
          "Clear reversals",
          "Strong midpoint logic"
        ],
        stepsTitle: "Steps (7-point model)",
        numberedSteps: true,
        steps: [
          "1. Hook \u2014 Introduce the protagonist and the central problem.",
          "2. Plot Turn 1 \u2014 An event pushes the protagonist into action.",
          "3. Pinch Point 1 \u2014 Pressure reveals the antagonist\u2019s power.",
          "4. Midpoint \u2014 The protagonist shifts from reactive to proactive.",
          "5. Pinch Point 2 \u2014 Stakes intensify; consequences loom.",
          "6. Plot Turn 2 \u2014 Final commitment toward resolution.",
          "7. Resolution \u2014 Conflict concludes; new status quo established."
        ],
        examplesTitle: "Seven Point Examples",
        examples: [
          "Fantasy and sci-fi novels",
          "Plot-driven fiction",
          "Serialized narratives"
        ]
      });
      return;
    }
    if (title === "Pulp Formula") {
      this.renderStructureDetail(container, {
        introTitle: "What is the Pulp Formula?",
        intro: [
          "A fast-paced structure designed for entertainment, clarity, and momentum. It prioritizes action, stakes, and accessibility over thematic subtlety."
        ],
        core: [
          "Immediate engagement",
          "Clear heroes and villains",
          "Escalating danger",
          "High momentum"
        ],
        stepsTitle: "Steps (common pulp rhythm)",
        steps: [
          "1. Immediate Hook \u2014 Start with action or danger.",
          "2. Clear Goal \u2014 The protagonist knows what must be done.",
          "3. Obstacle Chain \u2014 Continuous challenges and reversals.",
          "4. Escalation \u2014 Stakes increase rapidly.",
          "5. Cliffhanger or Crisis \u2014 A major setback or revelation.",
          "6. Final Confrontation \u2014 Direct clash with the antagonist.",
          "7. Swift Resolution \u2014 Loose ends tied quickly."
        ],
        examplesTitle: "Pulp Examples",
        examples: [
          "Adventure serials",
          "Noir fiction",
          "Action thrillers",
          "Comic storytelling"
        ]
      });
      return;
    }
    if (title === "McKee Story paradigm") {
      this.renderStructureDetail(container, {
        introTitle: "What is the McKee Paradigm?",
        intro: [
          "Robert McKee\u2019s model emphasizes story as a sequence of value changes driven by conflict and choice. It focuses on scene design and narrative causality."
        ],
        core: [
          "Value shifts",
          "Progressive complications",
          "Scene-level causality",
          "Strong climax logic"
        ],
        stepsTitle: "Structural principles",
        steps: [
          "1. Inciting Incident \u2014 A radical change disrupts balance.",
          "2. Progressive Complications \u2014 Each action leads to greater difficulty.",
          "3. Crisis \u2014 A decision between irreconcilable values.",
          "4. Climax \u2014 Action that resolves the crisis.",
          "5. Resolution \u2014 The world stabilizes in a new form."
        ],
        examplesTitle: "McKee Examples",
        examples: [
          "Prestige drama",
          "Character-driven films",
          "Serious literary narratives"
        ]
      });
      return;
    }
    if (title === "Into the Woods structure") {
      this.renderStructureDetail(container, {
        introTitle: "What is the Into the Woods structure?",
        intro: [
          "John Yorke\u2019s model views story as a five-act, fractal pattern: order, disorder, repair, collapse, and transformation. It emphasizes repetition at multiple scales."
        ],
        core: [
          "Five-part rhythm",
          "Fractal repetition",
          "Moral consequence",
          "Thematic depth"
        ],
        stepsTitle: "Steps (5-act pattern)",
        steps: [
          "1. Order \u2014 Establish a flawed equilibrium.",
          "2. Disruption \u2014 A desire or problem breaks order.",
          "3. Attempted Repair \u2014 Characters try to fix things.",
          "4. Collapse \u2014 Efforts fail; chaos peaks.",
          "5. New Order \u2014 A transformed equilibrium emerges."
        ],
        examplesTitle: "Into the Woods Examples",
        examples: [
          "British television drama",
          "Prestige serialized storytelling",
          "Thematic narratives"
        ]
      });
      return;
    }
    if (title === "Frame Narrative") {
      this.renderStructureDetail(container, {
        introTitle: "What is a Frame Narrative?",
        intro: [
          "A story within a story. An outer narrative contextualizes or reframes an inner narrative."
        ],
        core: [
          "Nested storytelling",
          "Perspective mediation",
          "Interpretive distance"
        ],
        stepsTitle: "Structural layers",
        steps: [
          "1. Outer Frame \u2014 Establish the narrator or context.",
          "2. Inner Story \u2014 The primary narrative is told.",
          "3. Interruption or Commentary \u2014 The frame reacts or reframes meaning.",
          "4. Return to Frame \u2014 The story closes with new understanding."
        ],
        examplesTitle: "Frame Narrative Examples",
        examples: [
          "Frankenstein",
          "The Princess Bride",
          "Heart of Darkness",
          "Arabian Nights"
        ]
      });
      return;
    }
    if (title === "Nonlinear Structure") {
      this.renderStructureDetail(container, {
        introTitle: "What is a Nonlinear Structure?",
        intro: [
          "A narrative told out of chronological order. Meaning emerges from juxtaposition rather than sequence."
        ],
        core: [
          "Fragmented timeline",
          "Pattern recognition",
          "Active audience participation"
        ],
        stepsTitle: "Common nonlinear patterns",
        steps: [
          "Reverse chronology",
          "Interwoven timelines",
          "Fragmented memory",
          "Circular narratives"
        ],
        examplesTitle: "Nonlinear Examples",
        examples: [
          "Memento",
          "Pulp Fiction",
          "Westworld",
          "Slaughterhouse-Five"
        ]
      });
      return;
    }
    if (title === "Rashomon Structure") {
      this.renderStructureDetail(container, {
        introTitle: "What is a Rashomon Structure?",
        intro: [
          "A narrative that presents multiple, conflicting perspectives of the same event, emphasizing subjectivity and truth ambiguity."
        ],
        core: [
          "Multiple narrators",
          "Contradictory accounts",
          "Truth as unstable"
        ],
        stepsTitle: "Structural pattern",
        steps: [
          "1. Single event",
          "2. Multiple retellings",
          "3. Contradictions revealed",
          "4. Ambiguity preserved"
        ],
        examplesTitle: "Rashomon Examples",
        examples: [
          "Rashomon",
          "Hero",
          "The Affair",
          "Gone Girl (partial)"
        ]
      });
      return;
    }
    if (title === "In Medias Res") {
      this.renderStructureDetail(container, {
        introTitle: "What is In Medias Res?",
        intro: [
          "A narrative that begins in the middle of action, then later provides context for how events reached that point."
        ],
        core: [
          "Immediate engagement",
          "Delayed exposition",
          "Momentum-first storytelling"
        ],
        stepsTitle: "Structural pattern",
        steps: [
          "1. Mid-action opening",
          "2. Audience confusion",
          "3. Gradual backfill",
          "4. Recontextualization",
          "5. Continuation to resolution"
        ],
        examplesTitle: "In Medias Res Examples",
        examples: [
          "The Odyssey",
          "Breaking Bad (cold opens)",
          "Mad Max: Fury Road",
          "Fight Club"
        ]
      });
      return;
    }
    if (title === "The Mentor") {
      this.renderMentorDetail(container);
      return;
    }
    if (title === "The Herald") {
      this.renderHeraldDetail(container);
      return;
    }
    if (title === "The Shadow") {
      this.renderShadowDetail(container);
      return;
    }
    if (title === "The Trickster") {
      this.renderTricksterDetail(container);
      return;
    }
    if (title === "The Ally") {
      this.renderAllyDetail(container);
      return;
    }
    if (title === "The Shapeshifter") {
      this.renderShapeshifterDetail(container);
      return;
    }
    if (title === "The Threshold Guardian") {
      this.renderThresholdGuardianDetail(container);
      return;
    }
    if (title === "The Caregiver") {
      this.renderCaregiverDetail(container);
      return;
    }
    container.createDiv({ cls: "resource-detail-placeholder", text: "Content coming soon." });
  }
  getResourceIcon(title) {
    const iconMap = {
      "The Hero": "sword",
      "The Mentor": "graduation-cap",
      "The Herald": "bell",
      "The Shadow": "moon",
      "The Trickster": "dice",
      "The Ally": "handshake",
      "The Shapeshifter": "hat-glasses",
      "The Threshold Guardian": "shield",
      "The Caregiver": "heart-handshake",
      "The Creator": "paintbrush",
      "The Everyman": "users",
      "The Explorer": "compass",
      "The Hero (Jung)": "sword",
      "The Innocent": "baby",
      "The Jester": "party-popper",
      "The Lover": "heart",
      "The Magician": "wand-2",
      "The Outlaw": "flame-kindling",
      "The Ruler": "crown",
      "The Sage": "book-open",
      "Moral Ascent": "trending-up",
      "Moral Descent": "trending-down",
      "Flat Moral": "minus",
      "Moral Transformation": "trending-up-down",
      "Character Pitfalls": "user",
      "Character Arc Pitfalls": "route",
      "Narrative Technique Pitfalls": "book-open",
      "Structure Pitfalls": "layout-grid",
      "Writing-Level Pitfalls": "pen-line",
      "Flashback": "rewind",
      "Flashforward": "fast-forward",
      "Foreshadowing": "scan-eye",
      "Chekhov\u2019s Gun": "bomb",
      "Red Herring": "fish",
      "Plot Twist": "rotate-3d",
      "Deus Ex Machina": "wand-2",
      "Eucatastrophe": "mountain",
      "Poetic Justice": "scale",
      "\u201CShow, Don\u2019t Tell\u201D": "eye",
      "Quibble (Wordplay)": "quote",
      "The Hero\u2019s Journey": "map",
      "Dan Harmon Story Circle": "orbit",
      "Freytag\u2019s Pyramid": "triangle",
      "Fichtean Curve": "line-chart",
      "Three Act Structure": "columns-3",
      "Kish\u014Dtenketsu": "route",
      "Save the Cat": "cat",
      "Seven Point Structure": "wheat",
      "Pulp Formula": "book",
      "McKee Story paradigm": "book-open",
      "Into the Woods structure": "trees",
      "Frame Narrative": "scan",
      "Nonlinear Structure": "line-squiggle",
      "Rashomon Structure": "shrink",
      "In Medias Res": "git-commit-horizontal",
      "Argumentation (tips)": "scale",
      "Description (tips)": "image",
      "Dialogue (tips)": "message-circle",
      "Exposition (tips)": "file-text",
      "Narration (tips)": "book-open",
      "Persuasion (tips)": "megaphone"
    };
    return iconMap[title] || "book";
  }
  getResourceHeading(title) {
    const archetypeTitles = /* @__PURE__ */ new Set([
      "The Hero",
      "The Mentor",
      "The Herald",
      "The Shadow",
      "The Trickster",
      "The Ally",
      "The Shapeshifter",
      "The Threshold Guardian",
      "The Caregiver",
      "The Creator",
      "The Everyman",
      "The Explorer",
      "The Hero (Jung)",
      "The Innocent",
      "The Jester",
      "The Lover",
      "The Magician",
      "The Outlaw",
      "The Ruler",
      "The Sage"
    ]);
    if (archetypeTitles.has(title)) {
      return `${title.toUpperCase()} ARCHETYPE`;
    }
    if (title.endsWith("(tips)")) {
      return title.replace(" (tips)", "").toUpperCase();
    }
    return title.toUpperCase();
  }
  createResourceSubheading(parent, iconName, text) {
    const heading = parent.createDiv({ cls: "resource-detail-subheading-row" });
    const icon = heading.createSpan({ cls: "resource-detail-subheading-icon" });
    (0, import_obsidian6.setIcon)(icon, iconName);
    heading.createSpan({ cls: "resource-detail-subheading", text });
  }
  renderHeroDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Hero?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Hero is the transforming protagonist. They represent the struggle for personal growth, the confrontation of fear, and the overcoming of obstacles. The Hero symbolizes the human drive to transcend limits, improve, and give meaning to adversity."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This is a universal archetype found in myth, classical stories, and modern narratives. The Hero\u2019s journey forms the backbone of many plots."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Courage in the face of danger",
      "Inner and outer strength",
      "Empathy and leadership",
      "Strong sense of justice",
      "Human flaws and vulnerability"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Hero is not perfect. They fall, struggle, and rise transformed."
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Mentor \u2192 guidance and wisdom",
      "Ally \u2192 shared mission",
      "Threshold Guardian \u2192 trial or blockage",
      "Shadow \u2192 antagonist or repressed self",
      "Trickster \u2192 chaos and disruption",
      "Shapeshifter \u2192 uncertainty and tension",
      "Herald \u2192 announces change"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing a strong Hero");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Clear motivation",
      "Internal conflict",
      "Meaningful backstory",
      "Unique skills",
      "Emotional relationships",
      "Balance of strength and fragility",
      "Strong contrast between ordinary life and transformation"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const whyZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(whyZone, "chart-spline", "Why this archetype works");
    whyZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Because it mirrors the human experience: struggle, fall, learning, and transformation."
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "bookmark");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Hero Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Harry Potter",
      "Frodo Baggins",
      "Katniss Everdeen",
      "Mulan",
      "Luke Skywalker",
      "Simba",
      "Elizabeth Bennet"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderMentorDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Mentor?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Mentor guides, teaches, and inspires the Hero. They provide wisdom, experience, and emotional support, helping the Hero grow and overcome challenges."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Mentor represents inherited knowledge, tradition, and the possibility of inner transformation."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Spiritual and practical guide",
      "Accumulated wisdom",
      "Emotional support figure",
      "Ethical compass",
      "Connection to tradition",
      "Catalyst for action"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Often the Mentor sacrifices something, forcing the Hero into independence."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Mentor supports the Hero\u2019s growth as:"
    });
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Trusted advisor",
      "Trainer or teacher",
      "Giver of tools or gifts",
      "Emotional challenger",
      "Bridge between worlds"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "When the Mentor disappears, the Hero must act alone."
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Hero \u2192 formative bond",
      "Threshold Guardian \u2192 shared trials",
      "Shadow \u2192 moral counterpoint",
      "Ally \u2192 cooperation or tension",
      "Trickster \u2192 disruption of authority",
      "Shapeshifter \u2192 ambiguity",
      "Herald \u2192 signals the need for guidance"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing a compelling Mentor");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Strong introduction",
      "Clear motivation",
      "Demonstrated expertise",
      "Unique personality",
      "Revealing backstory",
      "Trust with the Hero",
      "Memorable first lesson",
      "Symbolic presence"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "layout-grid");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Mentor Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Gandalf",
      "Dumbledore",
      "Mr. Miyagi",
      "Yoda",
      "Professor Xavier",
      "Glinda",
      "Haymitch",
      "Rafiki",
      "Morpheus"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderHeraldDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Herald?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Herald announces change. They disrupt the status quo and deliver the call to adventure, signaling that the current world can no longer remain the same."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Herald does not need to stay in the story long \u2014 their power lies in initiating movement."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Messenger of change",
      "Catalyst for action",
      "Bringer of information or crisis",
      "External or internal trigger",
      "Neutral, positive, or threatening"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Herald forces a decision."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Herald appears to:"
    });
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Deliver news",
      "Introduce conflict",
      "Reveal danger or opportunity",
      "Force the Hero to act",
      "Break routine"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They are the narrative spark."
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Hero \u2192 awakens purpose",
      "Mentor \u2192 confirms the call",
      "Shadow \u2192 escalation of threat",
      "Ally \u2192 shared urgency",
      "Shapeshifter \u2192 uncertainty around meaning",
      "Trickster \u2192 distorted message"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing an effective Herald");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Clear message",
      "Strong timing",
      "Memorable entrance",
      "Emotional impact",
      "Immediate consequences",
      "No unnecessary exposition"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Herald Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "R2-D2",
      "The White Rabbit",
      "Hagrid",
      "The Letter from Hogwarts",
      "The Black Spot (Treasure Island)",
      "Morpheus (first contact)",
      "Paul Revere"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderShadowDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Shadow?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Shadow represents the Hero\u2019s greatest obstacle. It often embodies the Hero\u2019s repressed fears, flaws, or dark potential."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Shadow can be a villain, antagonist, rival, or internal force."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Opposition and threat",
      "Moral contrast",
      "Power or temptation",
      "Psychological mirror",
      "Fear incarnate"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Shadow tests the Hero\u2019s values."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Shadow exists to:"
    });
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Block progress",
      "Challenge morality",
      "Force growth",
      "Expose weakness",
      "Represent consequences"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Defeating the Shadow often means internal change."
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Hero \u2192 mirrored opposition",
      "Mentor \u2192 ideological contrast",
      "Ally \u2192 collateral conflict",
      "Trickster \u2192 destabilization",
      "Shapeshifter \u2192 hidden threat",
      "Threshold Guardian \u2192 shared function"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing a powerful Shadow");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Clear motivation",
      "Personal connection to Hero",
      "Symbolic design",
      "Escalating threat",
      "Moral complexity",
      "Consequences beyond defeat"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Shadow Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Darth Vader",
      "Voldemort",
      "Sauron",
      "Joker",
      "Scar",
      "Thanos",
      "Captain Ahab"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderTricksterDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Trickster?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Trickster introduces chaos, humor, and unpredictability. They question authority, expose hypocrisy, and disrupt order."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Trickster is rarely evil \u2014 they destabilize to reveal truth."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Humor and wit",
      "Rule-breaking behavior",
      "Irony and satire",
      "Unpredictability",
      "Social disruption"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They thrive on contradiction."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Trickster serves to:"
    });
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Relieve tension",
      "Challenge norms",
      "Reveal hidden truths",
      "Expose weakness",
      "Create narrative surprise"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They prevent stagnation."
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Hero \u2192 comic relief or moral test",
      "Mentor \u2192 challenges authority",
      "Shadow \u2192 ironic contrast",
      "Ally \u2192 unreliable support",
      "Shapeshifter \u2192 shared ambiguity"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing an effective Trickster");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Sharp dialogue",
      "Clear worldview",
      "Narrative timing",
      "Purposeful disruption",
      "Balance humor and impact"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Trickster Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Loki",
      "Jack Sparrow",
      "Bugs Bunny",
      "Deadpool",
      "The Joker (comic function)",
      "Puck",
      "Han Solo"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderAllyDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Ally?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Ally supports the Hero emotionally, strategically, or practically. They represent friendship, loyalty, and shared purpose."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Allies humanize the Hero."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Loyalty",
      "Complementary skills",
      "Emotional support",
      "Shared risk",
      "Personal stake"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Allies often have their own arcs."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Ally helps by:"
    });
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Assisting in conflict",
      "Providing perspective",
      "Supporting decisions",
      "Sharing danger",
      "Reflecting growth"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They reinforce connection."
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Hero \u2192 partnership",
      "Mentor \u2192 guidance extension",
      "Shadow \u2192 vulnerability",
      "Trickster \u2192 contrast",
      "Shapeshifter \u2192 trust tension"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing strong Allies");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Clear individuality",
      "Defined strengths",
      "Emotional bond",
      "Independent goals",
      "Potential conflict"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Ally Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Samwise Gamgee",
      "Ron Weasley",
      "Hermione Granger",
      "Chewbacca",
      "Dr. Watson",
      "Merry & Pippin",
      "Peeta Mellark"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderShapeshifterDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Shapeshifter?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Shapeshifter embodies uncertainty. Their allegiance, identity, or intentions are unclear, creating doubt and tension."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They represent change and ambiguity."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Duality",
      "Uncertainty",
      "Fluid loyalty",
      "Deception or mystery",
      "Emotional instability"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They challenge trust."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Shapeshifter exists to:"
    });
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Create doubt",
      "Test perception",
      "Complicate relationships",
      "Introduce surprise",
      "Represent internal conflict"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Hero \u2192 trust challenge",
      "Mentor \u2192 warning or lesson",
      "Shadow \u2192 secret alliance",
      "Ally \u2192 betrayal risk",
      "Trickster \u2192 shared chaos"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing a compelling Shapeshifter");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Clear mystery",
      "Consistent ambiguity",
      "Emotional stakes",
      "Gradual revelation",
      "Meaningful transformation"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Shapeshifter Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Catwoman",
      "Severus Snape",
      "Gollum",
      "Mystique",
      "Nick Fury",
      "Scarlett O\u2019Hara"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderThresholdGuardianDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Threshold Guardian?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Threshold Guardian blocks progress and tests readiness. They appear at key moments of transition."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They are not always villains \u2014 they are gatekeepers."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Obstacle or challenge",
      "Moral or physical test",
      "Enforcer of rules",
      "Neutral opposition",
      "Trial embodiment"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Passing them marks growth."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Tests commitment",
      "Filters worthiness",
      "Forces preparation",
      "Delays progression",
      "Raises stakes"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const relationshipsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(relationshipsZone, "flask-conical", "Key relationships");
    const relationships = relationshipsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Hero \u2192 rite of passage",
      "Mentor \u2192 preparation source",
      "Shadow \u2192 structural parallel",
      "Ally \u2192 shared test",
      "Trickster \u2192 bypass attempt"
    ].forEach((item) => {
      relationships.createEl("li", { text: item });
    });
    const writingZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(writingZone, "square-pen", "Writing effective Threshold Guardians");
    const writing = writingZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Clear rules",
      "Symbolic challenge",
      "Consequences for failure",
      "Escalation of difficulty",
      "Memorable encounter"
    ].forEach((item) => {
      writing.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "club");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Threshold Guardian Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "The Sphinx",
      "Cerberus",
      "The Bouncer",
      "Stormtroopers",
      "Gatekeepers",
      "Dragons",
      "The First Boss"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderCaregiverDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Caregiver?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Caregiver is driven by compassion, responsibility, and the desire to protect others. They exist to nurture, support, and sustain, often putting others\u2019 needs before their own."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This archetype represents altruism, sacrifice, and unconditional care."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Empathy and compassion",
      "Selflessness",
      "Responsibility",
      "Emotional strength",
      "Protective instinct"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Caregiver\u2019s weakness is often self-neglect."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Protects vulnerable characters",
      "Provides emotional stability",
      "Represents moral goodness",
      "Motivates sacrifice",
      "Creates emotional stakes"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They often anchor the story\u2019s heart."
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Helping others vs. self-preservation",
      "Love vs. burnout",
      "Responsibility vs. freedom"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Caregiver Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Marmee (Little Women)",
      "Samwise Gamgee",
      "Aunt May",
      "Molly Weasley",
      "Baymax",
      "Marlin (Finding Nemo)"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderCreatorDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Creator?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Creator is driven by imagination and the urge to build something meaningful. They seek originality, self-expression, and lasting impact through creation."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This archetype fears mediocrity and unrealized potential."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Creativity",
      "Vision",
      "Innovation",
      "Sensitivity",
      "Perfectionism"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They are often torn between inspiration and self-doubt."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Brings new ideas into the world",
      "Challenges existing systems",
      "Embodies artistic struggle",
      "Explores identity through creation"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Fear of failure",
      "Obsession with perfection",
      "Isolation",
      "The cost of creation"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Creator Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Victor Frankenstein",
      "Tony Stark",
      "Walt Disney (fictionalized)",
      "Dr. Emmett Brown",
      "Jo March",
      "Da Vinci\u2013type characters"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderEverymanDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Everyman?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Everyman represents normalcy, relatability, and belonging. They are not exceptional by skill or destiny, but by humanity."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This archetype allows the audience to see themselves in the story."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Humility",
      "Honesty",
      "Reliability",
      "Relatability",
      "Desire for connection"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They succeed through perseverance, not greatness."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Grounds the story",
      "Reflects audience values",
      "Humanizes extraordinary events",
      "Emphasizes community and belonging"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Feeling insignificant",
      "Fear of standing out",
      "Desire to belong vs. desire to matter"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Everyman Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Arthur Dent",
      "Bilbo Baggins (early)",
      "Jim Halpert",
      "Forrest Gump",
      "Frodo (initially)"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderExplorerDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Explorer?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Explorer seeks freedom, discovery, and self-definition. They reject confinement and pursue meaning through experience."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This archetype values independence above all else."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Curiosity",
      "Independence",
      "Courage",
      "Restlessness",
      "Self-reliance"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They fear conformity and stagnation."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Drives journeys and quests",
      "Expands the world of the story",
      "Challenges limits and borders",
      "Represents personal freedom"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Commitment",
      "Loneliness",
      "Rootlessness",
      "The cost of freedom"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Explorer Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Indiana Jones",
      "Lara Croft",
      "Moana",
      "Huck Finn",
      "The Doctor (Doctor Who)"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderHeroJungDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Hero?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Jungian Hero represents courage, willpower, and the drive to prove worth through action. Unlike the mythic Hero\u2019s Journey, this archetype focuses on strength and achievement."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Bravery",
      "Determination",
      "Discipline",
      "Moral clarity",
      "Endurance"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They define themselves through struggle."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Confronts danger directly",
      "Overcomes adversity",
      "Protects others",
      "Embodies action and resolve"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Pride",
      "Fear of weakness",
      "Burnout",
      "Identity tied solely to victory"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Hero Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Wonder Woman",
      "Captain America",
      "Achilles",
      "Beowulf",
      "Maximus"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderInnocentDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Innocent?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Innocent seeks happiness, safety, and goodness. They believe in a just world and trust others easily."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This archetype represents hope and moral purity."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Optimism",
      "Trust",
      "Faith",
      "Simplicity",
      "Moral clarity"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Their weakness is naivety."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Highlights corruption or cruelty",
      "Inspires protection",
      "Restores hope",
      "Contrasts darker characters"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Loss of faith",
      "Disillusionment",
      "Exposure to harsh reality"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Innocent Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Dorothy Gale",
      "Paddington",
      "Buddy (Elf)",
      "Bambi",
      "Am\xE9lie"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderJesterDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Jester?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Jester lives in the moment, embracing humor, chaos, and joy. They expose truth through laughter and subversion."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Humor",
      "Irreverence",
      "Playfulness",
      "Chaos",
      "Social critique"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They fear boredom and oppression."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Relieves tension",
      "Exposes hypocrisy",
      "Challenges authority",
      "Brings levity"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Being taken seriously",
      "Hiding pain behind humor"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Jester Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Jack Sparrow",
      "The Genie",
      "Tyrion Lannister",
      "Bugs Bunny",
      "Puck"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderLoverDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Lover?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Lover is driven by passion, intimacy, and connection. They seek union \u2014 romantic, emotional, or aesthetic."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Passion",
      "Devotion",
      "Sensuality",
      "Emotional depth",
      "Vulnerability"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They fear abandonment and loss."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Raises emotional stakes",
      "Motivates sacrifice",
      "Explores intimacy",
      "Drives relational conflict"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Obsession",
      "Dependency",
      "Loss of identity"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Lover Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Romeo & Juliet",
      "Rose (Titanic)",
      "Westley",
      "Scarlett O\u2019Hara",
      "Jack Dawson"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderMagicianDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Magician?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Magician seeks transformation \u2014 of self, others, or reality itself. They understand hidden systems and use knowledge to enact change."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Insight",
      "Vision",
      "Power",
      "Charisma",
      "Transformation"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They fear unintended consequences."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Enables change",
      "Transforms situations",
      "Reveals hidden truths",
      "Alters reality"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Control vs. ethics",
      "Power misuse",
      "Hubris"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Magician Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Gandalf",
      "Doctor Strange",
      "Merlin",
      "Neo",
      "Dumbledore"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderOutlawDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Outlaw?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Outlaw rejects rules, authority, and conformity. They seek freedom through rebellion and disruption."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Defiance",
      "Independence",
      "Anger or idealism",
      "Courage",
      "Anti-authoritarianism"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They fear powerlessness."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Challenges systems",
      "Sparks revolution",
      "Represents resistance",
      "Breaks unjust rules"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Destruction vs. change",
      "Isolation",
      "Moral ambiguity"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Outlaw Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "V",
      "Robin Hood",
      "Han Solo",
      "Tyler Durden",
      "Katniss Everdeen"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderRulerDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Ruler?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Ruler seeks order, control, and stability. They value leadership, responsibility, and structure."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Authority",
      "Control",
      "Responsibility",
      "Vision",
      "Discipline"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They fear chaos and loss of power."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Establishes order",
      "Sets laws and norms",
      "Represents power",
      "Creates political stakes"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Tyranny vs. justice",
      "Control vs. trust"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Ruler Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Mufasa",
      "Aragorn",
      "Queen Elizabeth\u2013type figures",
      "Tywin Lannister",
      "Odin"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderSageDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "Who is the Sage?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The Sage seeks truth through knowledge and understanding. They value wisdom over action."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core traits");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Intelligence",
      "Objectivity",
      "Insight",
      "Reflection",
      "Patience"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "They fear ignorance and deception."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Provides truth",
      "Explains systems",
      "Guides decisions",
      "Offers perspective"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Inner conflict");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Detachment",
      "Inaction",
      "Emotional distance"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Sage Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Obi-Wan Kenobi",
      "Socrates\u2013type figures",
      "Professor X",
      "Dumbledore (as Sage)",
      "Spock"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderMoralAscentDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "What is a Moral Ascent?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "A Moral Ascent arc follows a character who grows ethically over the course of the story. The character starts with flaws, ignorance, or selfishness and gradually learns to act with greater integrity, empathy, or responsibility."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This is the classic arc of becoming better."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core characteristics");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Ethical growth",
      "Increased empathy",
      "Personal responsibility",
      "Learning from mistakes",
      "Sacrifice for others"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The character ends the story morally stronger than they began."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Inspire the audience",
      "Reinforce ethical values",
      "Reward self-reflection and growth",
      "Create emotional catharsis"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    functionZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "It often aligns with hopeful or redemptive stories."
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Common internal conflicts");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Fear vs. courage",
      "Self-interest vs. responsibility",
      "Ignorance vs. awareness",
      "Comfort vs. change"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Moral Ascent Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Ebenezer Scrooge",
      "Zuko",
      "Jean Valjean",
      "Tony Stark",
      "Shrek",
      "Mulan"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderMoralDescentDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "What is a Moral Descent?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "A Moral Descent arc follows a character who deteriorates ethically over time. They begin with good intentions or neutrality but gradually compromise their values, often due to fear, ambition, pride, or trauma."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "This is the arc of corruption."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core characteristics");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Ethical erosion",
      "Rationalization of wrongdoing",
      "Increasing selfishness or cruelty",
      "Loss of empathy",
      "Escalating consequences"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The character becomes morally worse by the end."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Explore the cost of power",
      "Examine temptation and corruption",
      "Create tragedy or cautionary tales",
      "Critique ambition or hubris"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Common internal conflicts");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Power vs. morality",
      "Control vs. restraint",
      "Fear vs. conscience",
      "Justification vs. accountability"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Moral Descent Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Walter White",
      "Anakin Skywalker",
      "Michael Corleone",
      "Macbeth",
      "Gollum",
      "Light Yagami"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderFlatMoralDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "What is a Flat Moral Arc?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "In a Flat Moral Arc, the character does not significantly change their moral beliefs. Instead, the character\u2019s values remain constant while the world around them is challenged or transformed."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The character changes others, not themselves."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core characteristics");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Stable moral compass",
      "Strong convictions",
      "Resistance to pressure",
      "Consistency under stress",
      "Influence on others"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The arc is external rather than internal."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Represent ideal values",
      "Challenge a flawed world",
      "Serve as moral anchors",
      "Highlight societal change"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Common internal tensions");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Isolation due to integrity",
      "Conflict with changing norms",
      "Burden of being right",
      "Moral fatigue"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Flat Moral Arc Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Captain America",
      "Paddington",
      "Atticus Finch",
      "Superman",
      "Wonder Woman",
      "Marge Gunderson"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderMoralTransformationDetail(container) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", "What is a Moral Transformation?");
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "A Moral Transformation arc depicts a character who undergoes a fundamental ethical shift. Unlike gradual ascent or descent, this change is often abrupt, intense, and tied to a defining moment or revelation."
    });
    introZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "The character becomes morally different \u2014 not just better or worse."
    });
    const traitsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(traitsZone, "heart", "Core characteristics");
    const traits = traitsZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Pivotal turning point",
      "Identity redefinition",
      "Value realignment",
      "Emotional shock or revelation",
      "Clear \u201Cbefore and after\u201D"
    ].forEach((item) => {
      traits.createEl("li", { text: item });
    });
    traitsZone.createDiv({
      cls: "resource-detail-paragraph",
      text: "Transformation is often irreversible."
    });
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionsList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Mark decisive moments",
      "Reinvent characters",
      "Shock or reframe audience perception",
      "Signal thematic shifts"
    ].forEach((item) => {
      functionsList.createEl("li", { text: item });
    });
    const conflictZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(conflictZone, "alert-triangle", "Common internal conflicts");
    const conflictList = conflictZone.createEl("ul", { cls: "resource-detail-list" });
    [
      "Guilt vs. denial",
      "Old identity vs. new self",
      "Fear of change",
      "Consequences of awakening"
    ].forEach((item) => {
      conflictList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "user-round");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: "Moral Transformation Examples" });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    [
      "Darth Vader (redemption moment)",
      "Neo (awakening)",
      "Clarice Starling",
      "Jaime Lannister",
      "Elsa (acceptance)",
      "Andy Dufresne"
    ].forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderPitfallsDetail(container, title, items) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const pitfallsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(pitfallsZone, "alert-triangle", title);
    const list = pitfallsZone.createEl("ul", { cls: "resource-detail-list" });
    items.forEach((item) => {
      list.createEl("li", { text: item });
    });
  }
  renderTipsDetail(container, config) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", config.introTitle);
    config.intro.forEach((paragraph) => {
      introZone.createDiv({ cls: "resource-detail-paragraph", text: paragraph });
    });
    const techniquesZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(techniquesZone, "heart", "Core techniques");
    const techniquesList = techniquesZone.createDiv({ cls: "resource-detail-callout-list" });
    config.techniques.forEach((item) => {
      this.renderCalloutItem(techniquesList, item);
    });
  }
  renderCalloutItem(container, item) {
    var _a, _b, _c;
    const cleanText = typeof item === "string" ? item.replace(/^\d+\.\s*/, "") : "";
    const parts = cleanText ? cleanText.split(" \u2014 ") : [];
    const title = typeof item === "string" ? (_a = parts[0]) == null ? void 0 : _a.trim() : (_b = item == null ? void 0 : item.title) == null ? void 0 : _b.trim();
    const body = typeof item === "string" ? parts.slice(1).join(" \u2014 ").trim() : (_c = item == null ? void 0 : item.body) == null ? void 0 : _c.trim();
    const stepIconMap = {
      "EXPOSITION": "scroll-text",
      "RISING ACTION": "trending-up",
      "CLIMAX": "triangle",
      "FALLING ACTION": "trending-down",
      "DENOUEMENT / CATASTROPHE": "skull",
      "IMMEDIATE HOOK / FIRST CRISIS": "flame",
      "CRISIS ESCALATION 1": "move-up-right",
      "CRISIS ESCALATION 2": "trending-up",
      "CRISIS ESCALATION 3": "corner-right-up",
      "MAJOR CRISIS / LOW POINT": "triangle-alert",
      "SHORT RESOLUTION": "flag",
      "OPENING / STATUS QUO": "home",
      "INCITING INCIDENT": "zap",
      "DEBATE / REFUSAL": "message-circle-x",
      "ACT I BREAK (COMMITMENT)": "thumbs-up",
      "RISING COMPLICATIONS": "trending-up",
      "MIDPOINT SHIFT": "refresh-ccw-dot",
      "BAD GUYS CLOSE IN / PRESSURE PEAKS": "alert-triangle",
      "ALL IS LOST": "bone",
      "DARK NIGHT OF THE SOUL": "skull",
      "ACT III BREAK (NEW PLAN)": "notepad-text",
      "DENOUEMENT": "flag",
      "KI (INTRODUCTION)": "circle-play",
      "SH\xD4 (DEVELOPMENT)": "trending-up",
      "TEN (TURN / TWIST)": "rotate-cw",
      "KETSU (CONCLUSSION)": "flag",
      "OPENING IMAGE": "image",
      "THEME STATED": "quote",
      "SETUP": "list",
      "CATALYST": "sparkles",
      "DEBATE": "message-circle-x",
      "BREAK INTO ACT II": "log-in",
      "B STORY": "users",
      "FUN AND GAMES": "sparkles",
      "MIDPOINT": "refresh-ccw-dot",
      "BAD GUYS CLOSE IN": "alert-triangle",
      "BREAK INTO ACT III": "notepad-text",
      "FINALE": "flag",
      "FINAL IMAGE": "image",
      "HOOK": "sparkles",
      "PLOT TURN 1": "log-in",
      "PINCH POINT 1": "grip",
      "PINCH POINT 2": "grip",
      "PLOT TURN 2": "log-in",
      "RESOLUTION": "flag",
      "IMMEDIATE HOOK": "flame",
      "CLEAR GOAL": "target",
      "OBSTACLE CHAIN": "link-2",
      "ESCALATION": "trending-up",
      "CLIFFHANGER OR CRISIS": "siren",
      "FINAL CONFRONTATION": "swords",
      "SWIFT RESOLUTION": "flag",
      "PROGRESSIVE COMPLICATIONS": "trending-up",
      "CRISIS": "circle-alert",
      "ORDER": "square",
      "DISRUPTION": "sparkles",
      "ATTEMPTED REPAIR": "wrench",
      "COLLAPSE": "triangle-alert",
      "NEW ORDER": "flag",
      "OUTER FRAME": "frame",
      "INNER STORY": "book-open",
      "INTERRUPTION OR COMMENTARY": "message-square",
      "RETURN TO FRAME": "corner-up-left",
      "REVERSE CHRONOLOGY": "rotate-ccw",
      "INTERWOVEN TIMELINES": "split",
      "FRAGMENTED MEMORY": "brain",
      "CIRCULAR NARRATIVES": "repeat",
      "SINGLE EVENT": "dot",
      "MULTIPLE RETELLINGS": "repeat-2",
      "CONTRADICTIONS REVEALED": "alert-triangle",
      "AMBIGUITY PRESERVED": "help-circle",
      "MID-ACTION OPENING": "zap",
      "AUDIENCE CONFUSION": "help-circle",
      "GRADUAL BACKFILL": "clock-4",
      "RECONTEXTUALIZATION": "refresh-ccw-dot",
      "CONTINUATION TO RESOLUTION": "arrow-right"
    };
    const iconName = typeof item === "object" ? item == null ? void 0 : item.icon : title ? stepIconMap[title.toUpperCase()] : null;
    if (!title) {
      return;
    }
    const callout = container.createDiv({ cls: "resource-detail-callout" });
    if (iconName) {
      const icon = callout.createSpan({ cls: "resource-detail-callout-icon" });
      (0, import_obsidian6.setIcon)(icon, iconName);
    }
    callout.createSpan({ cls: "resource-detail-callout-title", text: title });
    if (body) {
      callout.createDiv({ cls: "resource-detail-callout-body", text: body });
    }
  }
  renderTechniqueDetail(container, config) {
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", config.introTitle);
    config.intro.forEach((paragraph) => {
      introZone.createDiv({ cls: "resource-detail-paragraph", text: paragraph });
    });
    const coreZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(coreZone, "heart", "Core characteristics");
    const coreList = coreZone.createEl("ul", { cls: "resource-detail-list" });
    config.core.forEach((item) => {
      coreList.createEl("li", { text: item });
    });
    if (config.coreNote) {
      coreZone.createDiv({ cls: "resource-detail-paragraph", text: config.coreNote });
    }
    const functionZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(functionZone, "chart-spline", "Narrative function");
    const functionList = functionZone.createEl("ul", { cls: "resource-detail-list" });
    config.narrativeFunction.forEach((item) => {
      functionList.createEl("li", { text: item });
    });
    if (config.narrativeNote) {
      functionZone.createDiv({ cls: "resource-detail-paragraph", text: config.narrativeNote });
    }
    const risksZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(risksZone, "alert-triangle", config.risksTitle || "Common risks");
    const risksList = risksZone.createEl("ul", { cls: "resource-detail-list" });
    config.risks.forEach((item) => {
      risksList.createEl("li", { text: item });
    });
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "bookmark");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: config.examplesTitle });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    config.examples.forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderStructureDetail(container, config) {
    var _a, _b;
    const content = container.createDiv({ cls: "resource-detail-content" });
    const introZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(introZone, "circle-question-mark", config.introTitle);
    config.intro.forEach((paragraph) => {
      introZone.createDiv({ cls: "resource-detail-paragraph", text: paragraph });
    });
    if ((_a = config.core) == null ? void 0 : _a.length) {
      const coreZone = content.createDiv({ cls: "resource-detail-zone" });
      this.createResourceSubheading(coreZone, "heart", "Core characteristics");
      const coreList = coreZone.createEl("ul", { cls: "resource-detail-list" });
      config.core.forEach((item) => {
        coreList.createEl("li", { text: item });
      });
      if (config.coreNote) {
        coreZone.createDiv({ cls: "resource-detail-paragraph", text: config.coreNote });
      }
    }
    const stepsZone = content.createDiv({ cls: "resource-detail-zone" });
    this.createResourceSubheading(stepsZone, "list-ordered", config.stepsTitle || "Steps");
    if ((_b = config.stepGroups) == null ? void 0 : _b.length) {
      const stepsList = stepsZone.createDiv({ cls: "resource-detail-numbered-steps" });
      config.stepGroups.forEach((group) => {
        const headingClass = /^ACT\\s+/i.test(group.title) ? "resource-detail-step-heading-plain" : "resource-detail-step-heading";
        const heading = stepsList.createDiv({ cls: headingClass });
        heading.createSpan({ text: group.title });
        const groupBox = stepsList.createDiv({ cls: "resource-detail-step-group" });
        group.items.forEach((item) => {
          this.renderCalloutItem(groupBox, item);
        });
      });
    } else if (config.numberedSteps) {
      const stepsList = stepsZone.createDiv({ cls: "resource-detail-numbered-steps" });
      let currentGroup = null;
      config.steps.forEach((item) => {
        if (/^ACT\s+[IVX]+\s+\s+/i.test(item)) {
          const heading = stepsList.createDiv({ cls: "resource-detail-step-heading" });
          heading.createSpan({ text: item });
          currentGroup = stepsList.createDiv({ cls: "resource-detail-step-group" });
          return;
        }
        if (!currentGroup) {
          currentGroup = stepsList.createDiv({ cls: "resource-detail-step-group" });
        }
        this.renderCalloutItem(currentGroup, item);
      });
    } else {
      const stepsList = stepsZone.createDiv({ cls: "resource-detail-numbered-steps" });
      config.steps.forEach((item) => {
        this.renderCalloutItem(stepsList, item);
      });
    }
    if (config.why) {
      const whyZone = content.createDiv({ cls: "resource-detail-zone" });
      this.createResourceSubheading(whyZone, "chart-spline", config.whyTitle || "Why this works");
      whyZone.createDiv({ cls: "resource-detail-paragraph", text: config.why });
    }
    const examplesZone = content.createDiv({ cls: "resource-detail-zone resource-detail-examples-zone" });
    const examplesHeader = examplesZone.createDiv({ cls: "resource-detail-examples-header" });
    const examplesIcon = examplesHeader.createSpan({ cls: "resource-detail-examples-icon" });
    (0, import_obsidian6.setIcon)(examplesIcon, "layout-grid");
    examplesHeader.createSpan({ cls: "resource-detail-subheading", text: config.examplesTitle });
    const examplesGrid = examplesZone.createDiv({ cls: "resource-detail-examples-grid" });
    config.examples.forEach((example) => {
      const card = examplesGrid.createDiv({ cls: "resource-detail-example-card" });
      card.createSpan({ text: example });
    });
  }
  renderAboutSection() {
    const section = this.toolsContainer.createDiv({ cls: "writer-tools-section" });
    section.createDiv({ cls: "writer-tools-section-title", text: "ABOUT" });
    const aboutItems = [
      { icon: "heart", label: "Donate", action: () => window.open("https://github.com/sponsors", "_blank") },
      { icon: "mail", label: "Contact", action: () => window.open("mailto:contact@example.com", "_blank") }
    ];
    aboutItems.forEach((item) => {
      const aboutItem = section.createDiv({ cls: "writer-tools-item" });
      const iconSpan = aboutItem.createSpan({ cls: "writer-tools-item-icon" });
      (0, import_obsidian6.setIcon)(iconSpan, item.icon);
      aboutItem.createSpan({ cls: "writer-tools-item-text", text: item.label });
      aboutItem.addEventListener("click", item.action);
    });
  }
  async onClose() {
  }
};

// src/views/folioSettingTab.js
var import_obsidian8 = require("obsidian");

// src/modals/iconPickerModal.js
var import_obsidian7 = require("obsidian");
var COMMON_ICONS = [
  // Books & Documents
  "book",
  "book-open",
  "book-text",
  "book-copy",
  "book-marked",
  "book-open-check",
  "book-open-text",
  "library",
  "library-big",
  "notebook",
  "notebook-pen",
  "notebook-tabs",
  "newspaper",
  "file-text",
  "file",
  "files",
  "file-check",
  "file-edit",
  "file-plus",
  "file-minus",
  "scroll",
  "scroll-text",
  "sticky-note",
  "clipboard",
  "clipboard-list",
  "clipboard-check",
  "bookmark",
  "bookmark-plus",
  "bookmarks",
  "bookmark-check",
  // Writing & Creativity
  "pen",
  "pen-tool",
  "pen-line",
  "pencil",
  "pencil-line",
  "pencil-ruler",
  "feather",
  "highlighter",
  "eraser",
  "type",
  "text",
  "text-cursor",
  "text-cursor-input",
  "signature",
  "quote",
  "pilcrow",
  "baseline",
  "subscript",
  "superscript",
  "spell-check",
  "spell-check-2",
  "whole-word",
  "case-sensitive",
  // Media & Entertainment
  "tv",
  "tv-minimal",
  "tv-minimal-play",
  "monitor-play",
  "clapperboard",
  "film",
  "video",
  "videotape",
  "camera",
  "camera-off",
  "projector",
  "theater",
  "popcorn",
  "ticket",
  "drama",
  "music",
  "music-2",
  "music-3",
  "music-4",
  "mic",
  "mic-2",
  "mic-off",
  "headphones",
  "headset",
  "radio",
  "podcast",
  "audio-lines",
  "audio-waveform",
  "play",
  "play-circle",
  "pause",
  "pause-circle",
  "stop-circle",
  "skip-forward",
  "skip-back",
  "rewind",
  "fast-forward",
  "repeat",
  "repeat-1",
  "shuffle",
  "list-music",
  // Visual & Art
  "image",
  "image-plus",
  "images",
  "gallery-horizontal",
  "gallery-vertical",
  "palette",
  "paintbrush",
  "paintbrush-2",
  "brush",
  "paint-bucket",
  "paint-roller",
  "pipette",
  "droplet",
  "droplets",
  "blend",
  "contrast",
  "sun-dim",
  "aperture",
  "focus",
  "scan",
  "crop",
  "flip-horizontal",
  "flip-vertical",
  "rotate-ccw",
  "rotate-cw",
  "move",
  "maximize",
  "minimize",
  "frame",
  "picture-in-picture",
  "picture-in-picture-2",
  // Folders & Organization
  "folder",
  "folder-open",
  "folder-closed",
  "folder-plus",
  "folder-minus",
  "folder-check",
  "folder-x",
  "folder-search",
  "folder-heart",
  "folder-input",
  "folder-output",
  "folder-archive",
  "folder-cog",
  "folder-dot",
  "folder-git",
  "folder-git-2",
  "folder-kanban",
  "folder-key",
  "folder-lock",
  "folder-symlink",
  "folder-sync",
  "folder-tree",
  "folders",
  "package",
  "package-open",
  "box",
  "boxes",
  "archive",
  "archive-restore",
  // Education & Learning
  "graduation-cap",
  "school",
  "school-2",
  "backpack",
  "brain",
  "brain-circuit",
  "brain-cog",
  "lightbulb",
  "lightbulb-off",
  "lamp",
  "lamp-desk",
  "lamp-floor",
  "lamp-ceiling",
  "lamp-wall-down",
  "lamp-wall-up",
  "presentation",
  "flip-chart",
  "clipboard-pen",
  "clipboard-type",
  "calculator",
  "ruler",
  "triangle-ruler",
  "drafting-compass",
  "beaker",
  "flask-conical",
  "flask-round",
  "microscope",
  "telescope",
  "atom",
  // Technology
  "code",
  "code-2",
  "terminal",
  "terminal-square",
  "braces",
  "brackets",
  "database",
  "server",
  "hard-drive",
  "cpu",
  "memory-stick",
  "usb",
  "monitor",
  "laptop",
  "laptop-2",
  "tablet",
  "smartphone",
  "phone",
  "keyboard",
  "mouse",
  "mouse-pointer",
  "mouse-pointer-2",
  "touchpad",
  "wifi",
  "wifi-off",
  "bluetooth",
  "nfc",
  "signal",
  "antenna",
  "battery",
  "battery-charging",
  "battery-full",
  "battery-low",
  "battery-medium",
  "battery-warning",
  "plug",
  "plug-2",
  "plug-zap",
  "power",
  "power-off",
  "git-branch",
  "git-commit",
  "git-merge",
  "git-pull-request",
  "git-fork",
  "git-compare",
  "github",
  "gitlab",
  "chrome",
  "firefox",
  // Navigation & Location
  "globe",
  "globe-2",
  "earth",
  "map",
  "map-pin",
  "map-pinned",
  "compass",
  "navigation",
  "navigation-2",
  "locate",
  "locate-fixed",
  "locate-off",
  "route",
  "signpost",
  "signpost-big",
  "milestone",
  "flag",
  "flag-triangle-right",
  "home",
  "house",
  "house-plus",
  "building",
  "building-2",
  "factory",
  "warehouse",
  "store",
  "castle",
  "church",
  "landmark",
  "tent",
  "tent-tree",
  "mountain",
  "mountain-snow",
  "trees",
  // People & Social
  "user",
  "user-2",
  "user-circle",
  "user-circle-2",
  "user-check",
  "user-plus",
  "user-minus",
  "user-x",
  "users",
  "users-2",
  "users-round",
  "contact",
  "contact-2",
  "contacts",
  "person-standing",
  "accessibility",
  "baby",
  "hand",
  "hand-metal",
  "handshake",
  "heart",
  "heart-handshake",
  "heart-pulse",
  "activity",
  "heart-crack",
  "heart-off",
  "thumbs-up",
  "thumbs-down",
  "smile",
  "smile-plus",
  "frown",
  "meh",
  "laugh",
  "angry",
  // Communication
  "mail",
  "mail-open",
  "mail-plus",
  "mail-check",
  "mail-x",
  "mail-warning",
  "mail-search",
  "inbox",
  "send",
  "send-horizontal",
  "forward",
  "reply",
  "reply-all",
  "message-circle",
  "message-square",
  "message-square-plus",
  "messages-square",
  "at-sign",
  "hash",
  "phone",
  "phone-call",
  "phone-incoming",
  "phone-outgoing",
  "voicemail",
  "megaphone",
  "volume",
  "volume-1",
  "volume-2",
  "volume-x",
  "bell",
  "bell-ring",
  "bell-plus",
  "bell-minus",
  "bell-off",
  // Weather & Nature
  "sun",
  "sun-dim",
  "sun-medium",
  "sun-moon",
  "sunrise",
  "sunset",
  "moon",
  "moon-star",
  "cloud",
  "cloud-sun",
  "cloud-rain",
  "cloud-snow",
  "cloud-lightning",
  "snowflake",
  "wind",
  "tornado",
  "rainbow",
  "thermometer",
  "thermometer-sun",
  "thermometer-snowflake",
  "umbrella",
  "umbrella-off",
  "droplet",
  "droplets",
  "waves",
  "tree",
  "tree-deciduous",
  "tree-pine",
  "trees",
  "palm-tree",
  "sprout",
  "leaf",
  "clover",
  "flower",
  "flower-2",
  "cherry",
  "apple",
  "banana",
  "grape",
  "citrus",
  "bird",
  "bug",
  "cat",
  "dog",
  "fish",
  "rabbit",
  "snail",
  "squirrel",
  "turtle",
  // Objects & Tools
  "wrench",
  "hammer",
  "axe",
  "pickaxe",
  "shovel",
  "scissors",
  "knife",
  "screwdriver",
  "nut",
  "cog",
  "settings",
  "settings-2",
  "sliders",
  "sliders-horizontal",
  "key",
  "key-round",
  "key-square",
  "lock",
  "lock-keyhole",
  "unlock",
  "unlock-keyhole",
  "shield",
  "shield-check",
  "shield-alert",
  "shield-off",
  "shield-question",
  "glasses",
  "binoculars",
  "eye",
  "eye-off",
  "scan-eye",
  "scan-face",
  "magnet",
  "flashlight",
  "flashlight-off",
  "lighter",
  "flame",
  "fire-extinguisher",
  "trash",
  "trash-2",
  "recycle",
  "archive",
  "archive-restore",
  "archive-x",
  // Shapes & Symbols
  "circle",
  "square",
  "triangle",
  "diamond",
  "pentagon",
  "hexagon",
  "octagon",
  "star",
  "stars",
  "sparkle",
  "sparkles",
  "zap",
  "zap-off",
  "bolt",
  "crown",
  "gem",
  "award",
  "badge",
  "badge-check",
  "medal",
  "trophy",
  "ribbon",
  "gift",
  "party-popper",
  "cake",
  "cake-slice",
  "candy",
  "candy-cane",
  "cookie",
  "ice-cream",
  "check",
  "check-circle",
  "check-square",
  "x",
  "x-circle",
  "x-square",
  "plus",
  "plus-circle",
  "plus-square",
  "minus",
  "minus-circle",
  "minus-square",
  "equal",
  "divide",
  "percent",
  "infinity",
  "sigma",
  "pi",
  "omega",
  // Arrows & Direction
  "arrow-up",
  "arrow-down",
  "arrow-left",
  "arrow-right",
  "arrow-up-right",
  "arrow-up-left",
  "arrow-down-right",
  "arrow-down-left",
  "chevron-up",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevrons-up",
  "chevrons-down",
  "chevrons-left",
  "chevrons-right",
  "move-up",
  "move-down",
  "move-left",
  "move-right",
  "corner-up-left",
  "corner-up-right",
  "corner-down-left",
  "corner-down-right",
  "undo",
  "undo-2",
  "redo",
  "redo-2",
  "refresh-cw",
  "refresh-ccw",
  // Time & Calendar
  "clock",
  "clock-1",
  "clock-2",
  "clock-3",
  "clock-4",
  "clock-5",
  "clock-6",
  "alarm-clock",
  "alarm-clock-check",
  "alarm-clock-minus",
  "alarm-clock-off",
  "alarm-clock-plus",
  "timer",
  "timer-off",
  "timer-reset",
  "stopwatch",
  "hourglass",
  "history",
  "calendar",
  "calendar-days",
  "calendar-check",
  "calendar-plus",
  "calendar-minus",
  "calendar-x",
  "calendar-heart",
  "calendar-clock",
  "calendar-range",
  "calendar-search",
  // Layout & UI
  "layout-dashboard",
  "layout-grid",
  "layout-list",
  "layout-template",
  "layout-panel-left",
  "layout-panel-top",
  "kanban",
  "kanban-square",
  "trello",
  "columns",
  "rows",
  "table",
  "table-2",
  "grid-2x2",
  "grid-3x3",
  "align-left",
  "align-center",
  "align-right",
  "align-justify",
  "list",
  "list-checks",
  "list-ordered",
  "list-todo",
  "list-tree",
  "list-filter",
  "sidebar",
  "panel-left",
  "panel-right",
  "panel-top",
  "panel-bottom",
  "split",
  "split-square-horizontal",
  "split-square-vertical",
  "maximize-2",
  "minimize-2",
  "expand",
  "shrink",
  "fullscreen",
  // Actions & Status
  "search",
  "zoom-in",
  "zoom-out",
  "filter",
  "filter-x",
  "sort-asc",
  "sort-desc",
  "save",
  "save-all",
  "download",
  "upload",
  "import",
  "share",
  "share-2",
  "link",
  "link-2",
  "unlink",
  "external-link",
  "qr-code",
  "scan-barcode",
  "copy",
  "clipboard-copy",
  "clipboard-paste",
  "cut",
  "edit",
  "edit-2",
  "edit-3",
  "info",
  "circle-help",
  "help-circle",
  "alert-circle",
  "alert-triangle",
  "alert-octagon",
  "ban",
  "slash",
  "loader",
  "loader-2",
  "refresh-cw",
  "rotate-ccw",
  "grip-horizontal",
  "grip-vertical",
  "more-horizontal",
  "more-vertical",
  "menu",
  // Commerce & Finance
  "dollar-sign",
  "euro",
  "pound-sterling",
  "bitcoin",
  "coins",
  "piggy-bank",
  "wallet",
  "wallet-2",
  "credit-card",
  "banknote",
  "receipt",
  "ticket",
  "tags",
  "tag",
  "percent",
  "shopping-cart",
  "shopping-bag",
  "shopping-basket",
  "store",
  "storefront",
  "scale",
  "scale-3d",
  "weight",
  "barcode",
  "scan-line",
  // Travel & Transport
  "plane",
  "plane-takeoff",
  "plane-landing",
  "rocket",
  "satellite",
  "satellite-dish",
  "car",
  "car-front",
  "bus",
  "train",
  "train-front",
  "tram-front",
  "bike",
  "ship",
  "sailboat",
  "anchor",
  "fuel",
  "parking-meter",
  "traffic-cone",
  "luggage",
  "briefcase",
  "suitcase",
  "suitcase-rolling",
  // Sports & Games
  "dumbbell",
  "trophy",
  "medal",
  "target",
  "crosshair",
  "goal",
  "gamepad",
  "gamepad-2",
  "joystick",
  "dice-1",
  "dice-2",
  "dice-3",
  "dice-4",
  "dice-5",
  "dice-6",
  "puzzle",
  "swords",
  "sword",
  "wand",
  "wand-2",
  "crown"
];
var IconPickerModal = class extends import_obsidian7.Modal {
  constructor(app, { title, currentIcon, onSelect }) {
    super(app);
    this.title = title || "Select Icon";
    this.currentIcon = currentIcon;
    this.onSelect = onSelect;
    this.searchQuery = "";
    this.filteredIcons = [...COMMON_ICONS];
  }
  onOpen() {
    const { contentEl, modalEl, containerEl } = this;
    contentEl.empty();
    contentEl.addClass("folio-icon-picker-modal");
    if (containerEl) {
      containerEl.style.zIndex = "9999";
    }
    if (modalEl) {
      modalEl.style.zIndex = "10000";
    }
    contentEl.createEl("h2", { text: this.title });
    const searchContainer = contentEl.createDiv({ cls: "folio-icon-picker-search" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search icons...",
      cls: "folio-icon-picker-search-input"
    });
    searchInput.oninput = (e) => {
      this.searchQuery = e.target.value.toLowerCase();
      this.filterAndRenderIcons(iconGrid);
    };
    const iconGrid = contentEl.createDiv({ cls: "folio-icon-picker-grid" });
    this.renderIcons(iconGrid, COMMON_ICONS);
    searchInput.focus();
  }
  filterAndRenderIcons(container) {
    const filtered = this.searchQuery ? COMMON_ICONS.filter((icon) => icon.toLowerCase().includes(this.searchQuery)) : COMMON_ICONS;
    this.renderIcons(container, filtered);
  }
  renderIcons(container, icons) {
    container.empty();
    if (icons.length === 0) {
      container.createDiv({
        cls: "folio-icon-picker-empty",
        text: "No icons found"
      });
      return;
    }
    icons.forEach((iconName) => {
      const iconOption = container.createDiv({
        cls: "folio-icon-picker-option" + (iconName === this.currentIcon ? " is-selected" : "")
      });
      iconOption.title = iconName;
      (0, import_obsidian7.setIcon)(iconOption, iconName);
      const label = iconOption.createSpan({ cls: "folio-icon-picker-label" });
      label.textContent = iconName;
      iconOption.onclick = () => {
        this.onSelect(iconName);
        this.close();
      };
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/folioSettingTab.js
init_constants();
var FolioSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const el = this.containerEl;
    el.empty();
    el.createEl("h2", { text: "Folio" });
    const basicSection = el.createDiv({ cls: "folio-settings-section" });
    const basicHeader = basicSection.createDiv({ cls: "folio-settings-section-header" });
    const basicToggle = basicHeader.createSpan({ cls: "folio-settings-toggle" });
    (0, import_obsidian8.setIcon)(basicToggle, "chevron-right");
    basicHeader.createSpan({ text: "Basic options", cls: "folio-settings-section-title" });
    const basicContent = basicSection.createDiv({ cls: "folio-settings-section-content collapsed" });
    basicHeader.onclick = () => {
      basicContent.classList.toggle("collapsed");
      (0, import_obsidian8.setIcon)(basicToggle, basicContent.classList.contains("collapsed") ? "chevron-right" : "chevron-down");
    };
    new import_obsidian8.Setting(basicContent).setName("Default author").setDesc("Default author name for new projects").addText(
      (text) => text.setPlaceholder("Author name").setValue(this.plugin.settings.defaultAuthor || "").onChange(async (value) => {
        this.plugin.settings.defaultAuthor = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(basicContent).setName("Project storage path").setDesc("Default storage path for new projects (relative to vault root)").addText((text) => {
      text.setPlaceholder("projects").setValue(this.plugin.settings.basePath || "projects").onChange(async (value) => {
        let normalizedPath = value.trim().replace(/^\/+|\/+$/g, "") || "projects";
        this.plugin.settings.basePath = normalizedPath;
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", async () => {
        await this.plugin.ensureBasePath();
        await this.plugin.refresh();
      });
    });
    const templateSection = el.createDiv({ cls: "folio-settings-section" });
    const templateHeader = templateSection.createDiv({ cls: "folio-settings-section-header" });
    const templateToggle = templateHeader.createSpan({ cls: "folio-settings-toggle" });
    (0, import_obsidian8.setIcon)(templateToggle, "chevron-right");
    templateHeader.createSpan({ text: "Template options", cls: "folio-settings-section-title" });
    const templateContent = templateSection.createDiv({ cls: "folio-settings-section-content collapsed" });
    templateHeader.onclick = () => {
      templateContent.classList.toggle("collapsed");
      (0, import_obsidian8.setIcon)(templateToggle, templateContent.classList.contains("collapsed") ? "chevron-right" : "chevron-down");
    };
    if (!this.plugin.settings.projectTemplates) {
      this.plugin.settings.projectTemplates = [
        { id: "book", name: "Book", icon: "book", order: 1, description: "Novel or written work" },
        { id: "script", name: "TV Show", icon: "tv", order: 2, description: "Series with episodes and sequences" },
        { id: "film", name: "Film", icon: "clapperboard", order: 3, description: "Feature film or short" },
        { id: "essay", name: "Essay", icon: "newspaper", order: 4, description: "Essay or short nonfiction piece" }
      ];
    }
    const templates = this.plugin.settings.projectTemplates || [];
    const defaultOptions = {};
    templates.sort((a, b) => a.order - b.order).forEach((t) => {
      defaultOptions[t.id] = t.name;
    });
    new import_obsidian8.Setting(templateContent).setName("Default template").setDesc("Default template used when creating new projects").addDropdown(
      (dropdown) => dropdown.addOptions(defaultOptions).setValue(this.plugin.settings.defaultProjectType || "book").onChange(async (value) => {
        this.plugin.settings.defaultProjectType = value;
        await this.plugin.saveSettings();
      })
    );
    templateContent.createEl("h4", { text: "Project templates", cls: "folio-settings-subheader" });
    const templatesHeaderRow = templateContent.createDiv({ cls: "folio-templates-header-row" });
    const resetBtn = templatesHeaderRow.createEl("button", { cls: "folio-reset-templates-btn" });
    (0, import_obsidian8.setIcon)(resetBtn, "rotate-ccw");
    resetBtn.title = "Reset all templates to defaults";
    resetBtn.onclick = async () => {
      const confirmed = confirm("Are you sure you want to reset all templates to their default values? This will remove any custom templates and restore the original Book, TV Show, Film, and Essay templates.");
      if (confirmed) {
        this.plugin.settings.projectTemplates = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.projectTemplates));
        await this.plugin.saveSettings();
        this.renderTemplatesList(templatesListEl);
        this.plugin.rerenderViews();
        new import_obsidian8.Notice("Templates reset to defaults");
      }
    };
    const templatesListEl = templateContent.createDiv({ cls: "folio-templates-list" });
    this.renderTemplatesList(templatesListEl);
    const addBtnContainer = templateContent.createDiv({ cls: "folio-settings-add-btn-container" });
    const addBtn = addBtnContainer.createEl("button", { text: "Add new template", cls: "mod-cta folio-add-template-btn" });
    addBtn.onclick = () => {
      this.openTemplateEditor(null, templatesListEl);
    };
  }
  renderTemplatesList(container) {
    container.empty();
    const templates = (this.plugin.settings.projectTemplates || []).sort((a, b) => a.order - b.order);
    templates.forEach((template, index) => {
      const row = container.createDiv({ cls: "folio-template-row" });
      const iconEl = row.createDiv({ cls: "folio-template-icon" });
      (0, import_obsidian8.setIcon)(iconEl, template.icon || "file");
      const infoEl = row.createDiv({ cls: "folio-template-info" });
      infoEl.createDiv({ text: template.name, cls: "folio-template-name" });
      infoEl.createDiv({ text: template.description || "", cls: "folio-template-desc" });
      const actionsEl = row.createDiv({ cls: "folio-template-actions" });
      const editBtn = actionsEl.createEl("button", { cls: "folio-template-action-btn" });
      (0, import_obsidian8.setIcon)(editBtn, "pencil");
      editBtn.title = "Edit template";
      editBtn.onclick = () => {
        this.openTemplateEditor(template, container);
      };
      if (templates.length > 1) {
        const deleteBtn = actionsEl.createEl("button", { cls: "folio-template-action-btn mod-danger" });
        (0, import_obsidian8.setIcon)(deleteBtn, "trash");
        deleteBtn.title = "Delete template";
        deleteBtn.onclick = async () => {
          this.plugin.settings.projectTemplates = templates.filter((t) => t.id !== template.id);
          await this.plugin.saveSettings();
          this.renderTemplatesList(container);
          this.plugin.rerenderViews();
        };
      }
    });
  }
  openTemplateEditor(template, listContainer) {
    var _a;
    const isNew = !template;
    const editData = template ? JSON.parse(JSON.stringify(template)) : {
      id: `custom-${Date.now()}`,
      name: "",
      icon: "file",
      order: (((_a = this.plugin.settings.projectTemplates) == null ? void 0 : _a.length) || 0) + 1,
      description: "",
      structure: []
    };
    if (!editData.structure) {
      editData.structure = [];
    }
    const overlay = document.createElement("div");
    overlay.className = "folio-template-editor-overlay";
    const modal = document.createElement("div");
    modal.className = "folio-template-editor-modal folio-template-editor-modal-large";
    const title = document.createElement("h3");
    title.textContent = isNew ? "Add new template" : "Edit template";
    modal.appendChild(title);
    const nameRow = document.createElement("div");
    nameRow.className = "folio-template-editor-row";
    const nameLabel = document.createElement("label");
    nameLabel.textContent = "Name";
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.className = "folio-template-editor-input";
    nameInput.value = editData.name;
    nameInput.placeholder = "Template name";
    nameInput.onkeydown = (e) => e.stopPropagation();
    nameRow.appendChild(nameLabel);
    nameRow.appendChild(nameInput);
    modal.appendChild(nameRow);
    const iconRow = document.createElement("div");
    iconRow.className = "folio-template-editor-row";
    const iconLabel = document.createElement("label");
    iconLabel.textContent = "Icon";
    iconRow.appendChild(iconLabel);
    const iconInputRow = document.createElement("div");
    iconInputRow.className = "folio-template-icon-input-row";
    const iconPreview = document.createElement("span");
    iconPreview.className = "folio-template-icon-preview folio-icon-clickable";
    iconPreview.title = "Click to browse icons";
    const iconInput = document.createElement("input");
    iconInput.type = "text";
    iconInput.className = "folio-template-editor-input";
    iconInput.value = editData.icon;
    iconInput.placeholder = "e.g., book, newspaper, file";
    iconInput.onkeydown = (e) => e.stopPropagation();
    iconInputRow.appendChild(iconPreview);
    iconInputRow.appendChild(iconInput);
    iconRow.appendChild(iconInputRow);
    modal.appendChild(iconRow);
    const updateIconPreview = () => {
      iconPreview.innerHTML = "";
      try {
        (0, import_obsidian8.setIcon)(iconPreview, iconInput.value || "file");
      } catch (e) {
        (0, import_obsidian8.setIcon)(iconPreview, "file");
      }
    };
    updateIconPreview();
    iconInput.addEventListener("input", updateIconPreview);
    iconPreview.onclick = () => {
      new IconPickerModal(this.app, {
        title: "Select Template Icon",
        currentIcon: iconInput.value,
        onSelect: (iconName) => {
          iconInput.value = iconName;
          updateIconPreview();
        }
      }).open();
    };
    const descRow = document.createElement("div");
    descRow.className = "folio-template-editor-row";
    const descLabel = document.createElement("label");
    descLabel.textContent = "Description";
    const descInput = document.createElement("input");
    descInput.type = "text";
    descInput.className = "folio-template-editor-input";
    descInput.value = editData.description || "";
    descInput.placeholder = "Short description";
    descInput.onkeydown = (e) => e.stopPropagation();
    descRow.appendChild(descLabel);
    descRow.appendChild(descInput);
    modal.appendChild(descRow);
    const structureSection = document.createElement("div");
    structureSection.className = "folio-template-structure-section";
    const structureHeader = document.createElement("div");
    structureHeader.className = "folio-template-structure-header";
    const structureLabel = document.createElement("label");
    structureLabel.textContent = "Default structure";
    structureHeader.appendChild(structureLabel);
    const structureActions = document.createElement("div");
    structureActions.className = "folio-template-structure-actions";
    const addFileBtn = document.createElement("button");
    addFileBtn.className = "folio-template-structure-add-btn";
    addFileBtn.type = "button";
    (0, import_obsidian8.setIcon)(addFileBtn, "file-plus");
    addFileBtn.appendChild(document.createTextNode(" File"));
    addFileBtn.onclick = () => {
      editData.structure.push({ title: "New File", type: "file" });
      renderStructureTree();
    };
    const addFolderBtn = document.createElement("button");
    addFolderBtn.className = "folio-template-structure-add-btn";
    addFolderBtn.type = "button";
    (0, import_obsidian8.setIcon)(addFolderBtn, "folder-plus");
    addFolderBtn.appendChild(document.createTextNode(" Folder"));
    addFolderBtn.onclick = () => {
      editData.structure.push({ title: "New Folder", type: "folder", children: [] });
      renderStructureTree();
    };
    const addCanvasBtn = document.createElement("button");
    addCanvasBtn.className = "folio-template-structure-add-btn";
    addCanvasBtn.type = "button";
    (0, import_obsidian8.setIcon)(addCanvasBtn, "layout-dashboard");
    addCanvasBtn.appendChild(document.createTextNode(" Canvas"));
    addCanvasBtn.onclick = () => {
      editData.structure.push({ title: "New Canvas", type: "canvas" });
      renderStructureTree();
    };
    structureActions.appendChild(addFileBtn);
    structureActions.appendChild(addFolderBtn);
    structureActions.appendChild(addCanvasBtn);
    structureHeader.appendChild(structureActions);
    structureSection.appendChild(structureHeader);
    const structureTree = document.createElement("div");
    structureTree.className = "folio-template-structure-tree";
    structureSection.appendChild(structureTree);
    const expandedFolders = /* @__PURE__ */ new Set();
    let draggedNode = null;
    let draggedIndex = null;
    let draggedParentArray = null;
    const renderStructureTree = () => {
      structureTree.innerHTML = "";
      const renderNode = (node, parentArray, index, depth = 0) => {
        const nodeContainer = document.createElement("div");
        nodeContainer.className = "folio-template-structure-node-container";
        const nodeRow = document.createElement("div");
        nodeRow.className = "folio-template-structure-node";
        nodeRow.style.paddingLeft = `${depth * 20}px`;
        nodeRow.draggable = true;
        const dragHandle = document.createElement("span");
        dragHandle.className = "folio-template-structure-node-drag-handle";
        dragHandle.title = "Drag to reorder";
        (0, import_obsidian8.setIcon)(dragHandle, "grip-horizontal");
        nodeRow.appendChild(dragHandle);
        nodeRow.addEventListener("dragstart", (e) => {
          draggedNode = node;
          draggedIndex = index;
          draggedParentArray = parentArray;
          nodeRow.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          setTimeout(() => nodeRow.style.opacity = "0.5", 0);
        });
        nodeRow.addEventListener("dragend", (e) => {
          nodeRow.style.opacity = "1";
          nodeRow.classList.remove("dragging");
          document.querySelectorAll(".folio-template-structure-node").forEach((n) => {
            n.classList.remove("drag-over");
          });
        });
        nodeRow.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          nodeRow.classList.add("drag-over");
        });
        nodeRow.addEventListener("dragleave", (e) => {
          nodeRow.classList.remove("drag-over");
        });
        nodeRow.addEventListener("drop", (e) => {
          e.preventDefault();
          e.stopPropagation();
          nodeRow.classList.remove("drag-over");
          if (draggedNode && draggedParentArray === parentArray && draggedIndex !== index) {
            parentArray.splice(draggedIndex, 1);
            const newIndex = draggedIndex < index ? index - 1 : index;
            parentArray.splice(newIndex, 0, draggedNode);
            renderStructureTree();
          }
          draggedNode = null;
          draggedIndex = null;
          draggedParentArray = null;
        });
        if (node.type === "folder") {
          const toggleBtn = document.createElement("span");
          toggleBtn.className = "folio-template-structure-node-toggle";
          const isExpanded = expandedFolders.has(node);
          (0, import_obsidian8.setIcon)(toggleBtn, isExpanded ? "chevron-down" : "chevron-right");
          toggleBtn.onclick = () => {
            if (expandedFolders.has(node)) {
              expandedFolders.delete(node);
            } else {
              expandedFolders.add(node);
            }
            renderStructureTree();
          };
          nodeRow.appendChild(toggleBtn);
        } else {
          const spacer = document.createElement("span");
          spacer.className = "folio-template-structure-node-spacer";
          nodeRow.appendChild(spacer);
        }
        const nodeIcon = document.createElement("span");
        nodeIcon.className = "folio-template-structure-node-icon folio-icon-clickable";
        nodeIcon.title = "Click to change icon";
        const defaultIcon = node.type === "folder" ? "folder" : node.type === "canvas" ? "layout-dashboard" : "file";
        (0, import_obsidian8.setIcon)(nodeIcon, node.icon || defaultIcon);
        nodeIcon.onclick = (e) => {
          e.stopPropagation();
          new IconPickerModal(this.app, {
            title: `Select Icon for "${node.title}"`,
            currentIcon: node.icon || defaultIcon,
            onSelect: (iconName) => {
              node.icon = iconName;
              renderStructureTree();
            }
          }).open();
        };
        nodeRow.appendChild(nodeIcon);
        const titleInput = document.createElement("input");
        titleInput.type = "text";
        titleInput.className = "folio-template-structure-node-title";
        titleInput.value = node.title;
        titleInput.onclick = (e) => e.stopPropagation();
        titleInput.onkeydown = (e) => e.stopPropagation();
        titleInput.oninput = (e) => {
          node.title = e.target.value;
        };
        titleInput.onblur = (e) => {
          node.title = e.target.value.trim() || "Untitled";
          if (!e.target.value.trim()) {
            e.target.value = "Untitled";
          }
        };
        nodeRow.appendChild(titleInput);
        const typeBadge = document.createElement("span");
        typeBadge.className = "folio-template-structure-node-type";
        typeBadge.textContent = node.type;
        nodeRow.appendChild(typeBadge);
        const nodeActions = document.createElement("div");
        nodeActions.className = "folio-template-structure-node-actions";
        if (node.type === "folder") {
          const addFileBtn2 = document.createElement("button");
          addFileBtn2.className = "folio-template-structure-node-btn";
          addFileBtn2.type = "button";
          addFileBtn2.title = "Add file";
          (0, import_obsidian8.setIcon)(addFileBtn2, "file-plus");
          addFileBtn2.onclick = () => {
            if (!node.children)
              node.children = [];
            node.children.push({ title: "New File", type: "file" });
            expandedFolders.add(node);
            renderStructureTree();
          };
          nodeActions.appendChild(addFileBtn2);
          const addFolderBtn2 = document.createElement("button");
          addFolderBtn2.className = "folio-template-structure-node-btn";
          addFolderBtn2.type = "button";
          addFolderBtn2.title = "Add folder";
          (0, import_obsidian8.setIcon)(addFolderBtn2, "folder-plus");
          addFolderBtn2.onclick = () => {
            if (!node.children)
              node.children = [];
            node.children.push({ title: "New Folder", type: "folder", children: [] });
            expandedFolders.add(node);
            renderStructureTree();
          };
          nodeActions.appendChild(addFolderBtn2);
          const addCanvasBtn2 = document.createElement("button");
          addCanvasBtn2.className = "folio-template-structure-node-btn";
          addCanvasBtn2.type = "button";
          addCanvasBtn2.title = "Add canvas";
          (0, import_obsidian8.setIcon)(addCanvasBtn2, "layout-dashboard");
          addCanvasBtn2.onclick = () => {
            if (!node.children)
              node.children = [];
            node.children.push({ title: "New Canvas", type: "canvas" });
            expandedFolders.add(node);
            renderStructureTree();
          };
          nodeActions.appendChild(addCanvasBtn2);
        }
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "folio-template-structure-node-btn mod-danger";
        deleteBtn.type = "button";
        deleteBtn.title = "Delete";
        (0, import_obsidian8.setIcon)(deleteBtn, "trash");
        deleteBtn.onclick = () => {
          parentArray.splice(index, 1);
          renderStructureTree();
        };
        nodeActions.appendChild(deleteBtn);
        nodeRow.appendChild(nodeActions);
        nodeContainer.appendChild(nodeRow);
        structureTree.appendChild(nodeContainer);
        if (node.type === "folder" && node.children && node.children.length > 0 && expandedFolders.has(node)) {
          node.children.forEach((child, childIndex) => {
            renderNode(child, node.children, childIndex, depth + 1);
          });
        }
      };
      if (editData.structure.length === 0) {
        const emptyMsg = document.createElement("div");
        emptyMsg.className = "folio-template-structure-empty";
        emptyMsg.textContent = "No items. Add files or folders above.";
        structureTree.appendChild(emptyMsg);
      } else {
        editData.structure.forEach((node, index) => {
          renderNode(node, editData.structure, index, 0);
        });
      }
    };
    renderStructureTree();
    modal.appendChild(structureSection);
    const actions = document.createElement("div");
    actions.className = "folio-template-editor-actions";
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "folio-template-editor-cancel";
    cancelBtn.textContent = "Cancel";
    cancelBtn.type = "button";
    cancelBtn.onclick = () => overlay.remove();
    const saveBtn = document.createElement("button");
    saveBtn.className = "folio-template-editor-save mod-cta";
    saveBtn.textContent = isNew ? "Add" : "Save";
    saveBtn.type = "button";
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim();
      const icon = iconInput.value.trim() || "file";
      const desc = descInput.value.trim();
      if (!name) {
        nameInput.style.borderColor = "red";
        return;
      }
      editData.name = name;
      editData.icon = icon;
      editData.description = desc;
      if (isNew) {
        this.plugin.settings.projectTemplates = this.plugin.settings.projectTemplates || [];
        this.plugin.settings.projectTemplates.push(editData);
      } else {
        const idx = this.plugin.settings.projectTemplates.findIndex((t) => t.id === editData.id);
        if (idx !== -1) {
          this.plugin.settings.projectTemplates[idx] = editData;
        }
      }
      await this.plugin.saveSettings();
      overlay.remove();
      this.renderTemplatesList(listContainer);
      this.plugin.rerenderViews();
    };
    actions.appendChild(cancelBtn);
    actions.appendChild(saveBtn);
    modal.appendChild(actions);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    overlay.onclick = (e) => {
      if (e.target === overlay)
        overlay.remove();
    };
    modal.onkeydown = (e) => e.stopPropagation();
    modal.onkeyup = (e) => e.stopPropagation();
    modal.onkeypress = (e) => e.stopPropagation();
    nameInput.focus();
  }
};

// src/main.js
init_newBookModal();
init_switchBookModal();
init_manageBooksModal();
init_editBookModal();
init_helpModal();
init_textInputModal();
init_confirmModal();
var {
  Plugin,
  PluginSettingTab: PluginSettingTab2,
  Setting: Setting2,
  ItemView: ItemView3,
  TFile: TFile6,
  TFolder: TFolder4,
  Modal: Modal11,
  Menu: Menu2,
  setIcon: setIcon8
} = require("obsidian");
module.exports = class FolioPlugin extends Plugin {
  async onload() {
    var _a;
    await this.loadSettings();
    console.log("[Folio] onload - basePath after loadSettings:", this.settings.basePath);
    console.log("[Folio] onload - lastActiveBookPath:", this.settings.lastActiveBookPath);
    this.configService = new ConfigService(this.app);
    this.treeService = new TreeService(this.app, this.configService);
    this.statsService = new StatsService(this.app, this.configService);
    this.bookService = new BookService(this.app, this.configService);
    this.booksIndex = [];
    this.activeBook = null;
    this.folioLeaf = null;
    this.activeFile = null;
    console.log("[Folio] onload - about to ensureBasePath, getBasePath():", this.getBasePath());
    await this.ensureBasePath();
    await this.scanBooks();
    console.log("[Folio] onload - after scanBooks, booksIndex:", this.booksIndex.map((b) => b.path));
    try {
      if (this.settings && this.settings.lastActiveBookPath) {
        const byPath = this.booksIndex.find((b) => b.path === this.settings.lastActiveBookPath);
        console.log("[Folio] onload - looking for lastActiveBookPath:", this.settings.lastActiveBookPath, "found:", !!byPath);
        if (byPath)
          this.activeBook = byPath;
      }
    } catch (e) {
    }
    console.log("[Folio] onload - activeBook:", ((_a = this.activeBook) == null ? void 0 : _a.path) || "none");
    this.expandedFolders = /* @__PURE__ */ new Set();
    this.activeFilePath = null;
    this.registerView(
      VIEW_TYPE,
      (leaf) => new FolioView(leaf, this)
    );
    this.registerView(
      WRITER_TOOLS_VIEW_TYPE,
      (leaf) => new WriterToolsView(leaf, this)
    );
    this.addRibbonIcon("book", "Open Folio", () => {
      this.activateFolio();
    });
    this.addSettingTab(new FolioSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("create", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("delete", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("rename", async () => {
        var _a2;
        const activePath = (_a2 = this.activeBook) == null ? void 0 : _a2.path;
        await this.refresh();
        if (activePath) {
          const book = this.booksIndex.find((b) => b.path === activePath);
          if (book) {
            this.activeBook = book;
            try {
              await this.syncChapterStatsBaseline(book);
            } catch (e) {
              console.warn("syncChapterStatsBaseline (rename) failed", e);
            }
          }
        }
      })
    );
    this._statsDebounceTimers = {};
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        try {
          this.onFileModified(file);
        } catch (e) {
          console.warn("onFileModified handler failed", e);
        }
      })
    );
    try {
      this.registerEvent(
        this.app.workspace.on("editor-change", (editor, view) => {
          try {
            const f = view == null ? void 0 : view.file;
            if (f)
              this.onFileModified(f);
            if (editor && typeof editor.getValue === "function") {
              const text = editor.getValue();
              const leaves = this.app.workspace.getLeavesOfType(WRITER_TOOLS_VIEW_TYPE);
              for (const leaf of leaves) {
                const wtView = leaf.view;
                if (wtView && typeof wtView.updateFocusSessionWordsFromEditor === "function") {
                  wtView.updateFocusSessionWordsFromEditor(text, f);
                }
              }
            }
          } catch (e) {
            console.warn("editor-change handler failed", e);
          }
        })
      );
    } catch (e) {
    }
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        const af = this.app.workspace.getActiveFile();
        this.activeFilePath = af ? af.path : null;
        try {
          this.updateActiveFileInViews();
        } catch (e) {
          this.rerenderViews();
        }
      })
    );
  }
  // Minimal chapter context menu (Open in new tab/pane, Exclude toggle, Create copy, Rename, Delete)
  async openChapterContextMenu(evt, file, node = null) {
    var _a, _b, _c;
    try {
      (_a = evt.preventDefault) == null ? void 0 : _a.call(evt);
      const menu = new Menu2(this.app);
      let shouldCount = !(node == null ? void 0 : node.exclude);
      try {
        const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
        if (book) {
          const cfg = await this.loadBookConfig(book) || {};
          const projectType = ((_b = cfg.basic) == null ? void 0 : _b.projectType) || PROJECT_TYPES.BOOK;
          const overrides = this.statsService.buildStatsOverrideSets(((_c = cfg.structure) == null ? void 0 : _c.tree) || []);
          const rules = this.statsService.getStatsRulesForProjectType(projectType);
          shouldCount = this.statsService.shouldCountFileForStats(
            file,
            book.path,
            projectType,
            rules,
            overrides
          );
        }
      } catch (e) {
        console.warn("Failed to load stats inclusion state", e);
      }
      menu.addItem(
        (it) => it.setTitle("Open in new tab").setIcon("file").onClick(() => {
          (async () => {
            try {
              const leaf = this.app.workspace.getLeaf("tab");
              if (leaf && typeof leaf.openFile === "function") {
                await leaf.openFile(file);
              }
            } catch (e) {
              try {
                const leaf = this.app.workspace.getLeaf(true);
                if (leaf && typeof leaf.openFile === "function")
                  await leaf.openFile(file);
              } catch (e2) {
                console.warn(e2);
              }
            }
          })();
        })
      );
      menu.addItem(
        (it) => it.setTitle("Open in new pane").setIcon("split").onClick(() => {
          (async () => {
            try {
              const leaf = this.app.workspace.getLeaf("split");
              if (leaf && typeof leaf.openFile === "function") {
                await leaf.openFile(file);
              }
            } catch (e) {
              try {
                const leaf = this.app.workspace.getLeaf(true);
                if (leaf && typeof leaf.openFile === "function")
                  await leaf.openFile(file);
              } catch (e2) {
                console.warn(e2);
              }
            }
          })();
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle(shouldCount ? "Exclude from stats" : "Include in stats").setIcon(shouldCount ? "eye-off" : "eye").onClick(() => {
          this.setStatsOverride(file, shouldCount ? "exclude" : "include");
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle("Create copy").setIcon("copy").onClick(() => {
          try {
            this.app.fileManager.duplicateFile(file);
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Rename").setIcon("pencil").onClick(() => {
          try {
            this.app.fileManager.promptForFileRename(file);
          } catch (e) {
            console.warn(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Delete").setIcon("trash").onClick(async () => {
          try {
            await this.app.vault.delete(file, file instanceof TFolder4);
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.showAtMouseEvent(evt);
    } catch (e) {
      console.error(e);
    }
  }
  openVolumeMenu(evt, folder, isRoot = false, node = null) {
    var _a;
    try {
      (_a = evt.preventDefault) == null ? void 0 : _a.call(evt);
      const menu = new Menu2(this.app);
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New root canvas" : "New canvas").setIcon("layout-dashboard").onClick(async () => {
          try {
            const folderObj = folder instanceof TFolder4 ? folder : this.app.vault.getAbstractFileByPath((folder == null ? void 0 : folder.path) || folder);
            if (!(folderObj instanceof TFolder4))
              return;
            let base = "Canvas";
            let name = `${base}.canvas`;
            let i = 1;
            while (this.app.vault.getAbstractFileByPath(`${folderObj.path}/${name}`)) {
              i += 1;
              name = `${base} ${i}.canvas`;
            }
            await this.app.vault.create(`${folderObj.path}/${name}`, "");
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New root file" : "New file").setIcon("file-plus").onClick(() => {
          const modal = new TextInputModal(this.app, {
            title: "New file",
            placeholder: "File name",
            cta: "Create",
            onSubmit: async (value) => {
              const name = (value || "").trim();
              if (!name)
                return;
              try {
                const fileName = name.endsWith(".md") ? name : `${name}.md`;
                const dest = `${folder.path}/${fileName}`;
                if (!this.app.vault.getAbstractFileByPath(dest)) {
                  await this.app.vault.create(dest, "");
                  const book = this.booksIndex.find((b) => dest.startsWith(b.path));
                  if (book)
                    await this.syncChapterStatsBaseline(book);
                }
                await this.refresh();
                this.rerenderViews();
              } catch (e) {
                console.error(e);
              }
            }
          });
          modal.open();
        })
      );
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New volume" : "New folder").setIcon("folder-plus").onClick(() => {
          const modal = new TextInputModal(this.app, {
            title: "New folder",
            placeholder: "Folder name",
            cta: "Create",
            onSubmit: async (value) => {
              const name = (value || "").trim();
              if (!name)
                return;
              try {
                const dest = `${folder.path}/${name}`;
                if (!this.app.vault.getAbstractFileByPath(dest)) {
                  await this.app.vault.createFolder(dest);
                }
                await this.refresh();
                this.rerenderViews();
              } catch (e) {
                console.error(e);
              }
            }
          });
          modal.open();
        })
      );
      menu.addSeparator();
      if (!isRoot && node) {
        const isExcluded = node.exclude || false;
        menu.addItem(
          (it) => it.setTitle(isExcluded ? "Include in stats" : "Exclude from stats").setIcon(isExcluded ? "eye" : "eye-off").onClick(() => {
            this.toggleExcludeFromStats(folder, !isExcluded);
          })
        );
      }
      menu.addItem(
        (it) => it.setTitle("Create copy").setIcon("copy").onClick(() => {
          try {
            this.createCopy(folder.path);
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle("Rename").setIcon("pencil").onClick(() => {
          try {
            this.app.fileManager.promptForFileRename(folder);
          } catch (e) {
            console.warn(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Delete").setIcon("trash").onClick(async () => {
          try {
            await this.app.vault.delete(folder, folder instanceof TFolder4);
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.showAtMouseEvent(evt);
    } catch (e) {
      console.error(e);
    }
  }
  // Helper: open a file in the current leaf
  openFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      this.app.workspace.openLinkText(file.path, "", false);
    }
  }
  // Helper: open file in a new tab (open in new leaf)
  openFileInNewTab(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      try {
        this.app.workspace.openLinkText(file.path, "", true);
      } catch (e) {
        const leaf = this.app.workspace.getLeaf(true);
        leaf.openFile(file);
      }
    }
  }
  // Helper: open file in a new split/pane
  openFileInNewPane(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      try {
        const leaf = this.app.workspace.getLeaf(true);
        leaf.openFile(file);
      } catch (e) {
        console.warn(e);
      }
    }
  }
  renamePath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file) {
      try {
        this.app.fileManager.promptForFileRename(file);
      } catch (e) {
        console.warn(e);
      }
    }
  }
  async deletePath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file)
      return;
    try {
      await this.app.vault.delete(file, file instanceof TFolder4);
      await this.refresh();
      this.rerenderViews();
    } catch (e) {
      console.error(e);
    }
  }
  createCopy(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file)
      return;
    try {
      if (file instanceof TFile6) {
        this.app.fileManager.duplicateFile(file);
      } else if (file instanceof TFolder4) {
        const parentPath = file.path.split("/").slice(0, -1).join("/") || "";
        const baseName = `${file.name} Copy`;
        let destPath = `${parentPath}/${baseName}`.replace(/\/+/g, "/");
        let i = 1;
        while (this.app.vault.getAbstractFileByPath(destPath)) {
          destPath = `${parentPath}/${baseName} ${i}`;
          i++;
        }
        const createFolderAndCopy = async (src, dest) => {
          await this.app.vault.createFolder(dest);
          const folder = this.app.vault.getAbstractFileByPath(src);
          if (!(folder instanceof TFolder4))
            return;
          for (const child of folder.children) {
            const childDest = `${dest}/${child.name}`;
            if (child instanceof TFile6) {
              const content = await this.app.vault.read(child);
              await this.app.vault.create(childDest, content);
            } else if (child instanceof TFolder4) {
              await createFolderAndCopy(child.path, childDest);
            }
          }
        };
        createFolderAndCopy(file.path, destPath).then(async () => {
          await this.refresh();
          this.rerenderViews();
        });
      }
    } catch (e) {
      console.error(e);
    }
  }
  async createNextChapterFile(folder) {
    var _a;
    try {
      const folderObj = folder instanceof TFolder4 ? folder : this.app.vault.getAbstractFileByPath((folder == null ? void 0 : folder.path) || folder);
      if (!(folderObj instanceof TFolder4))
        return;
      const existing = ((_a = folderObj.children) != null ? _a : []).filter((c) => c instanceof TFile6 && c.extension === "md").map((f) => f.basename);
      let max = 0;
      for (const name of existing) {
        const match = name.match(/^Chapter (\d+)$/i);
        if (match) {
          const n = parseInt(match[1], 10);
          if (!isNaN(n))
            max = Math.max(max, n);
        }
      }
      const next = max + 1;
      const fileName = `Chapter ${next}.md`;
      const path = `${folderObj.path}/${fileName}`;
      if (this.app.vault.getAbstractFileByPath(path))
        return;
      await this.app.vault.create(path, "");
      try {
        const book = this.booksIndex.find((b) => path.startsWith(b.path));
        if (book)
          await this.syncChapterStatsBaseline(book);
      } catch (e) {
        console.warn("syncChapterStatsBaseline (createNextChapterFile) failed", e);
      }
    } catch (e) {
      console.error(e);
    }
  }
  // Helper: create sub-volume (folder) under a given folder path via modal
  createSubVolume(parentFolderPath) {
    const modal = new TextInputModal(this.app, {
      title: "New folder",
      placeholder: "Folder name",
      cta: "Create",
      onSubmit: async (value) => {
        if (!value)
          return;
        const folderObj = { path: parentFolderPath };
        await this.createVolume(folderObj, value);
        await this.refresh();
        this.rerenderViews();
      }
    });
    modal.open();
  }
  /* Activate both views: Folio (left) + Writer Tools (right) */
  async activateFolio() {
    await this.activateView();
    await this.openWriterTools();
  }
  /* Reusable activator: always reuse the same leaf (singleton view) */
  async activateView() {
    const { workspace } = this.app;
    const existing = workspace.getLeavesOfType(VIEW_TYPE);
    if (existing.length > 0) {
      workspace.revealLeaf(existing[0]);
      this.folioLeaf = existing[0];
      return;
    }
    const leftLeaf = workspace.getLeftLeaf(false);
    await leftLeaf.setViewState({
      type: VIEW_TYPE,
      active: true
    });
    this.folioLeaf = leftLeaf;
    workspace.revealLeaf(leftLeaf);
  }
  /* Open Writer Tools in right sidebar */
  async openWriterTools() {
    const { workspace } = this.app;
    const existing = workspace.getLeavesOfType(WRITER_TOOLS_VIEW_TYPE);
    if (existing.length > 0) {
      workspace.revealLeaf(existing[0]);
      return;
    }
    const rightLeaf = workspace.getRightLeaf(false);
    await rightLeaf.setViewState({
      type: WRITER_TOOLS_VIEW_TYPE,
      active: true
    });
    workspace.revealLeaf(rightLeaf);
  }
  async refresh() {
    await this.scanBooks();
    this.rerenderViews();
  }
  // Normalize basePath - remove leading/trailing slashes and multiple slashes
  getBasePath() {
    let base = this.settings.basePath || "projects";
    base = base.replace(/^\/+|\/+$/g, "").replace(/\/+/g, "/");
    return base || "projects";
  }
  async ensureBasePath() {
    const base = this.getBasePath();
    if (!await this.app.vault.adapter.exists(base)) {
      await this.app.vault.createFolder(base);
    }
  }
  /* ===============================================================
   * SCAN BOOKS (filesystem source of truth)
   * =============================================================== */
  async scanBooks() {
    var _a, _b;
    const basePath = this.getBasePath();
    this.booksIndex = await this.bookService.scanBooks(basePath);
    if (!this.activeBook && this.booksIndex.length > 0) {
      this.activeBook = this.booksIndex[0];
    }
    this.activeBook = (_b = (_a = this.booksIndex.find(
      (b) => {
        var _a2;
        return b.path === ((_a2 = this.activeBook) == null ? void 0 : _a2.path);
      }
    )) != null ? _a : this.booksIndex[0]) != null ? _b : null;
  }
  /* ===============================================================
   * CREATE METHODS
   * =============================================================== */
  async createBook(name, projectType = "book", templateStructure = null) {
    const basePath = this.getBasePath();
    return this.bookService.createBook(basePath, name, projectType, templateStructure);
  }
  async ensureBookBaseStructure(bookFolder) {
    return this.bookService.ensureBookBaseStructure(bookFolder);
  }
  async createVolume(book, name) {
    return this.bookService.createVolume(book, name);
  }
  async createChapter(volume, name, projectType = "book") {
    const result = await this.bookService.createChapter(volume, name, projectType);
    try {
      const book = this.booksIndex.find((b) => `${volume.path}/${name}.md`.startsWith(b.path));
      if (book)
        await this.syncChapterStatsBaseline(book);
    } catch (e) {
      console.warn("syncChapterStatsBaseline (createChapter) failed", e);
    }
    return result;
  }
  /* Helpers for native file-menu integration */
  isVolumeFolder(file) {
    try {
      return this.booksIndex.some(
        (b) => b.volumes.some((v) => v.path === file.path)
      );
    } catch (e) {
      return false;
    }
  }
  isChapterFile(file) {
    try {
      return this.booksIndex.some(
        (b) => b.volumes.some(
          (v) => v.chapters.some((c) => c.path === file.path)
        )
      );
    } catch (e) {
      return false;
    }
  }
  async deleteVolume(folder) {
    const af = this.app.vault.getAbstractFileByPath(folder.path) || folder;
    await this.app.vault.delete(af, true);
    await this.refresh();
  }
  async deleteChapter(file) {
    const af = this.app.vault.getAbstractFileByPath(file.path) || file;
    await this.app.vault.delete(af);
    await this.refresh();
    try {
      const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
      if (book)
        await this.syncChapterStatsBaseline(book);
    } catch (e) {
      console.warn("syncChapterStatsBaseline (deleteChapter) failed", e);
    }
  }
  // Move a folder and all its children to trash
  async deleteFolderRecursive(path) {
    try {
      const af = this.app.vault.getAbstractFileByPath(path);
      if (!af)
        return;
      await this.app.vault.trash(af, true);
    } catch (e) {
      console.warn("deleteFolderRecursive (trash) failed", path, e);
    }
  }
  async toggleExcludeFromStats(file, exclude) {
    const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
    if (!book) {
      console.warn("Could not find book for file:", file.path);
      return;
    }
    await this.treeService.toggleExcludeFromStats(book, file, exclude);
    await this.computeAndSaveStatsForBook(book);
    await this.refresh();
    this.rerenderViews();
  }
  async setStatsOverride(file, action) {
    const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
    if (!book) {
      console.warn("Could not find book for file:", file.path);
      return;
    }
    if (action === "include") {
      await this.treeService.setStatsOverride(book, file, { include: true, exclude: false });
    } else if (action === "exclude") {
      await this.treeService.setStatsOverride(book, file, { include: false, exclude: true });
    }
    await this.computeAndSaveStatsForBook(book);
    await this.refresh();
    this.rerenderViews();
  }
  async loadSettings() {
    const savedData = await this.loadData() || {};
    console.log("[Folio] loadSettings - savedData:", JSON.stringify(savedData, null, 2));
    console.log("[Folio] loadSettings - savedData.basePath:", savedData.basePath);
    this.settings = { ...DEFAULT_SETTINGS };
    Object.keys(savedData).forEach((key) => {
      if (key !== "projectTemplates") {
        this.settings[key] = savedData[key];
      }
    });
    console.log("[Folio] loadSettings - after merge, this.settings.basePath:", this.settings.basePath);
    if (savedData.projectTemplates && Array.isArray(savedData.projectTemplates)) {
      const defaultTemplatesMap = new Map(
        DEFAULT_SETTINGS.projectTemplates.map((t) => [t.id, t])
      );
      const mergedTemplates = savedData.projectTemplates.map((savedTemplate) => {
        const defaultTemplate = defaultTemplatesMap.get(savedTemplate.id);
        if (defaultTemplate) {
          return {
            id: savedTemplate.id,
            name: savedTemplate.name !== void 0 ? savedTemplate.name : defaultTemplate.name,
            icon: savedTemplate.icon !== void 0 ? savedTemplate.icon : defaultTemplate.icon,
            order: savedTemplate.order !== void 0 ? savedTemplate.order : defaultTemplate.order,
            description: savedTemplate.description !== void 0 ? savedTemplate.description : defaultTemplate.description,
            structure: savedTemplate.structure !== void 0 ? savedTemplate.structure : defaultTemplate.structure
          };
        }
        return savedTemplate;
      });
      DEFAULT_SETTINGS.projectTemplates.forEach((defaultTemplate) => {
        if (!mergedTemplates.find((t) => t.id === defaultTemplate.id)) {
          mergedTemplates.push({ ...defaultTemplate });
        }
      });
      this.settings.projectTemplates = mergedTemplates;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Delegate to ConfigService
  async loadBookConfig(book) {
    return this.configService.loadBookConfig(book);
  }
  // Delegate to ConfigService
  async saveBookConfig(book, config) {
    return this.configService.saveBookConfig(book, config);
  }
  // Delegate to ConfigService
  async loadBookMeta(book) {
    return this.configService.loadProjectMeta(book);
  }
  async waitForFolderSync(path, retries = 20) {
    const delay = (ms) => new Promise((r) => setTimeout(r, ms));
    while (retries-- > 0) {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (folder && folder.children && folder.children.length > 0)
        return;
      await delay(50);
    }
  }
  rerenderViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      try {
        if (view && typeof view.render === "function") {
          view.render();
        }
      } catch (e) {
        console.warn("render failed", e);
      }
    }
  }
  updateActiveFileInViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      try {
        if (!view || !view.contentEl)
          continue;
        const root = view.contentEl;
        const items = root.querySelectorAll(".tree-item");
        items.forEach((el) => {
          try {
            const p = el.getAttribute("data-path");
            if (p && p === this.activeFilePath)
              el.classList.add("is-active");
            else
              el.classList.remove("is-active");
          } catch (e) {
          }
        });
      } catch (e) {
        console.warn("updateActiveFileInViews failed", e);
      }
    }
  }
  // Update only the stats block in existing Folio views to avoid full re-renders
  async updateStatsInViews(book) {
    try {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
      for (const leaf of leaves) {
        const view = leaf.view;
        try {
          if (!view || !view.statsEl)
            continue;
          if (!book || !view.plugin || !view.plugin.activeBook)
            continue;
          if (view.plugin.activeBook.path !== book.path)
            continue;
          if (typeof view.renderStats === "function") {
            await view.renderStats(view.statsEl, book);
          }
        } catch (e) {
        }
      }
    } catch (e) {
      console.warn("updateStatsInViews failed", e);
    }
  }
  // Handle modified files  debounce per-book to avoid excessive work
  async onFileModified(file) {
    try {
      if (!file || !file.path)
        return;
      if (file.extension !== "md" && !file.path.endsWith(".md"))
        return;
      const book = this.booksIndex.find((b) => file.path === b.path || file.path.startsWith(b.path + "/"));
      if (!book)
        return;
      const key = book.path;
      if (this._statsDebounceTimers[key])
        clearTimeout(this._statsDebounceTimers[key]);
      this._statsDebounceTimers[key] = setTimeout(() => {
        this.computeAndSaveStatsForBook(book).catch((e) => console.warn("computeAndSaveStatsForBook failed", e));
        delete this._statsDebounceTimers[key];
      }, 400);
    } catch (e) {
      console.warn("onFileModified error", e);
    }
  }
  // Walk folder recursively to collect markdown TFile objects
  _collectMarkdownFiles(folder) {
    const out = [];
    if (!folder || !folder.children)
      return out;
    for (const c of folder.children) {
      if (c instanceof TFile6 && c.name && c.name.toLowerCase().endsWith(".md"))
        out.push(c);
      else if (c.children) {
        out.push(...this._collectMarkdownFiles(c));
      }
    }
    return out;
  }
  // Count words in text
  _countWords(text) {
    if (!text)
      return 0;
    let content = text;
    const frontmatterRegex = /^---\s*\n[\s\S]*?\n---\s*\n/;
    content = content.replace(frontmatterRegex, "");
    content = content.replace(/^#{1,6}\s+/gm, "").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/\*([^*]+)\*/g, "$1").replace(/\_\_([^_]+)\_\_/g, "$1").replace(/\_([^_]+)\_/g, "$1").replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/^>\s+/gm, "");
    const parts = content.replace(/\n/g, " ").split(/\s+/).filter(Boolean);
    return parts.length;
  }
  _getTodayKey() {
    return new Date().toISOString().slice(0, 10);
  }
  // Delegate to StatsService
  async computeAndSaveStatsForBook(book) {
    const stats = await this.statsService.computeAndSaveStatsForBook(book);
    if (stats) {
      await this.updateStatsInViews(book);
    }
    return stats;
  }
  // Delegate to StatsService
  async syncChapterStatsBaseline(book) {
    return this.statsService.syncChapterStatsBaseline(book);
  }
  /* ===============================================================
   * TREE MANAGEMENT HELPERS (Book-Smith pattern)
   * =============================================================== */
  // Generate unique node ID
  generateNodeId() {
    return `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  async buildTreeFromFilesystem(bookFolder) {
    return this.treeService.buildTreeFromFilesystem(bookFolder);
  }
  async reorderTreeNodes(book, draggedNodeId, targetNodeId, position) {
    return this.treeService.reorderTreeNodes(book, draggedNodeId, targetNodeId, position);
  }
};
