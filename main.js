/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/modals/newBookModal.js
var newBookModal_exports = {};
__export(newBookModal_exports, {
  NewBookModal: () => NewBookModal
});
var Modal, TFile3, NewBookModal;
var init_newBookModal = __esm({
  "src/modals/newBookModal.js"() {
    ({ Modal, TFile: TFile3 } = require("obsidian"));
    NewBookModal = class extends Modal {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Create new book" });
        const makeDivider = () => contentEl.createDiv({ cls: "novelist-modal-divider" });
        makeDivider();
        const tplRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const tplLeft = tplRow.createDiv({ cls: "novelist-modal-left" });
        tplLeft.createEl("div", { text: "Template", cls: "novelist-modal-row-title" });
        tplLeft.createEl("div", { text: "Please select a book template", cls: "novelist-modal-row-sub" });
        const tplRight = tplRow.createDiv({ cls: "novelist-modal-right" });
        const tplSelect = tplRight.createEl("select", { cls: "novelist-template-select" });
        tplSelect.createEl("option", { text: "default", value: "default" });
        makeDivider();
        const coverRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const coverLeft = coverRow.createDiv({ cls: "novelist-modal-left" });
        coverLeft.createEl("div", { text: "Cover", cls: "novelist-modal-row-title" });
        coverLeft.createEl("div", { text: "Select cover image (optional)", cls: "novelist-modal-row-sub" });
        const coverRight = coverRow.createDiv({ cls: "novelist-modal-right" });
        const coverBtn = coverRight.createEl("button", { text: "Select Image" });
        this._selectedCover = null;
        coverBtn.onclick = () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.style.display = "none";
          input.onchange = async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file)
              return;
            try {
              const reader = new FileReader();
              reader.onload = (ev) => {
                const ab = ev.target.result;
                this._selectedCover = { name: file.name, data: ab };
                coverBtn.textContent = "Select Image";
              };
              reader.readAsArrayBuffer(file);
            } catch (err) {
              console.warn("cover selection failed", err);
            }
          };
          document.body.appendChild(input);
          input.click();
          document.body.removeChild(input);
        };
        makeDivider();
        const titleRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const titleLeft = titleRow.createDiv({ cls: "novelist-modal-left" });
        titleLeft.createEl("div", { text: "Title", cls: "novelist-modal-row-title" });
        titleLeft.createEl("div", { text: "Please enter book title", cls: "novelist-modal-row-sub" });
        const titleRight = titleRow.createDiv({ cls: "novelist-modal-right" });
        const fieldWidth = "min(320px, 60%)";
        const titleInput = titleRight.createEl("input", { type: "text", placeholder: "Book title", cls: "novelist-modal-input" });
        try {
          titleInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const subRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const subLeft = subRow.createDiv({ cls: "novelist-modal-left" });
        subLeft.createEl("div", { text: "Subtitle", cls: "novelist-modal-row-title" });
        subLeft.createEl("div", { text: "Optional", cls: "novelist-modal-row-sub" });
        const subRight = subRow.createDiv({ cls: "novelist-modal-right" });
        const subtitleInput = subRight.createEl("input", { type: "text", placeholder: "Subtitle", cls: "novelist-modal-input" });
        try {
          subtitleInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const targetRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const targetLeft = targetRow.createDiv({ cls: "novelist-modal-left" });
        targetLeft.createEl("div", { text: "Target word count", cls: "novelist-modal-row-title" });
        targetLeft.createEl("div", { text: "Set estimated total word count (in 1k)", cls: "novelist-modal-row-sub" });
        const targetRight = targetRow.createDiv({ cls: "novelist-modal-right" });
        const targetInput = targetRight.createEl("input", { type: "text", placeholder: "e.g., 20 (20k) or 20000", cls: "novelist-modal-input" });
        try {
          targetInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const authorRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const authorLeft = authorRow.createDiv({ cls: "novelist-modal-left" });
        authorLeft.createEl("div", { text: "Author", cls: "novelist-modal-row-title" });
        authorLeft.createEl("div", { text: "Enter author names, separate multiple authors with commas", cls: "novelist-modal-row-sub" });
        const authorRight = authorRow.createDiv({ cls: "novelist-modal-right" });
        const authorInput = authorRight.createEl("input", { type: "text", placeholder: "Author", cls: "novelist-modal-input" });
        try {
          authorInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const descRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const descLeft = descRow.createDiv({ cls: "novelist-modal-left" });
        descLeft.createEl("div", { text: "Description", cls: "novelist-modal-row-title" });
        descLeft.createEl("div", { text: "Please enter book description", cls: "novelist-modal-row-sub" });
        const descRight = descRow.createDiv({ cls: "novelist-modal-right" });
        const descInput = descRight.createEl("textarea", { placeholder: "Book description", cls: "novelist-modal-textarea" });
        try {
          descInput.style.width = fieldWidth;
          descInput.style.minHeight = "120px";
        } catch (e) {
        }
        makeDivider();
        const actions = contentEl.createDiv({ cls: "novelist-modal-actions" });
        const createBtn = actions.createEl("button", { text: "Create", cls: "mod-cta novelist-modal-create" });
        createBtn.onclick = async () => {
          const title = titleInput.value.trim();
          if (!title)
            return;
          const subtitleVal = subtitleInput.value.trim();
          const authorVal = authorInput.value.trim();
          const descVal = descInput.value.trim();
          const targetValRaw = targetInput.value;
          const targetValNum = parseFloat(targetValRaw) || 0;
          this.close();
          await this.plugin.createBook(title);
          const basePath = this.plugin.settings && this.plugin.settings.basePath ? String(this.plugin.settings.basePath).replace(/\/+/g, "/") : "projects";
          const bookPath = `${basePath}/${title}`.replace(/\/+/g, "/");
          try {
            if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
              console.debug("NewBookModal.create captured", { title, subtitleVal, authorVal, descVal, targetValNum, bookPath });
          } catch (e) {
          }
          await this.plugin.waitForFolderSync(bookPath);
          await this.plugin.refresh();
          const book = this.plugin.booksIndex.find((b) => b.path === bookPath) || this.plugin.booksIndex.find((b) => b.name === title);
          if (book) {
            try {
              let cfg = {};
              if (this.plugin.loadBookConfig)
                cfg = await this.plugin.loadBookConfig(book) || {};
              cfg.basic = cfg.basic || {};
              cfg.basic.title = title;
              cfg.basic.subtitle = subtitleVal || "";
              cfg.basic.author = authorVal ? authorVal.split(",").map((s) => s.trim()).filter(Boolean) : cfg.basic.author || [];
              cfg.basic.desc = descVal || "";
              cfg.basic.created_at = cfg.basic.created_at || new Date().toISOString();
              cfg.stats = cfg.stats || {};
              const targ = targetValNum || 0;
              if (targ > 0) {
                cfg.stats.target_total_words = targ >= 1e3 ? Math.round(targ) : Math.round(targ * 1e3);
              } else {
                cfg.stats.target_total_words = cfg.stats.target_total_words || 0;
              }
              if (this._selectedCover && this._selectedCover.name && this._selectedCover.data) {
                try {
                  const destName = `${Date.now()}-${this._selectedCover.name}`.replace(/[^a-zA-Z0-9._-]/g, "_");
                  const destPath = `${book.path}/misc/cover/${destName}`;
                  if (this.plugin.app.vault.adapter && typeof this.plugin.app.vault.adapter.writeBinary === "function") {
                    const uint8 = new Uint8Array(this._selectedCover.data);
                    await this.plugin.app.vault.adapter.writeBinary(destPath, uint8);
                  } else {
                    const blob = new Blob([this._selectedCover.data]);
                    const arrayBuf = await blob.arrayBuffer();
                    const uint8 = new Uint8Array(arrayBuf);
                    try {
                      await this.plugin.app.vault.create(destPath, uint8);
                    } catch (e) {
                      console.warn("fallback cover write failed", e);
                    }
                  }
                  cfg.basic.cover = `misc/cover/${destName}`;
                } catch (e) {
                  console.warn("saving selected cover failed", e);
                }
              }
              if (this.plugin.saveBookConfig) {
                await this.plugin.saveBookConfig(book, cfg);
                try {
                  if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
                    console.debug("NewBookModal saved initial config for", book.path, { basic: cfg.basic });
                } catch (e) {
                }
              }
            } catch (e) {
              console.warn(e);
            }
            await this.plugin.createVolume(book, "Volume 1");
            await this.plugin.createChapter({ path: `${book.path}/Volume 1` }, "Chapter 1");
            await this.plugin.refresh();
            const updatedBook = this.plugin.booksIndex.find((b) => b.path === book.path);
            if (updatedBook) {
              this.plugin.activeBook = updatedBook;
              try {
                this.plugin.settings = this.plugin.settings || {};
                this.plugin.settings.lastActiveBookPath = updatedBook.path;
                await this.plugin.saveSettings();
              } catch (e) {
                console.warn("failed to persist lastActiveBookPath", e);
              }
            }
          }
          this.plugin.rerenderViews();
        };
        titleInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            createBtn.click();
          } else if (e.key === "Escape") {
            this.close();
          }
        });
        titleInput.focus();
      }
    };
  }
});

// src/modals/switchBookModal.js
var switchBookModal_exports = {};
__export(switchBookModal_exports, {
  SwitchBookModal: () => SwitchBookModal
});
var Modal2, SwitchBookModal;
var init_switchBookModal = __esm({
  "src/modals/switchBookModal.js"() {
    ({ Modal: Modal2 } = require("obsidian"));
    SwitchBookModal = class extends Modal2 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Switch book" });
        const search = contentEl.createEl("input", {
          type: "text",
          placeholder: "Search books...",
          cls: "novelist-manage-search"
        });
        const list = contentEl.createDiv({ cls: "novelist-manage-list" });
        const formatTarget = (n) => {
          if (!n)
            return "\u2014";
          const num = Number(n) || 0;
          if (num >= 1e3) {
            const k = num / 1e3;
            return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
          }
          return String(num);
        };
        const renderList = async (filter) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
          list.empty();
          const seen = /* @__PURE__ */ new Set();
          for (const book of this.plugin.booksIndex) {
            if (!book || !book.path)
              continue;
            if (seen.has(book.path))
              continue;
            seen.add(book.path);
            let cfg = {};
            try {
              cfg = await this.plugin.loadBookConfig(book) || {};
            } catch (e) {
            }
            const subtitle = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.subtitle) || "";
            const authors = Array.isArray((_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.author) ? cfg.basic.author.join(", ") : ((_c = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _c.author) || "";
            const desc = ((_d = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _d.desc) || ((_e = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _e.description) || "";
            const totalWords = ((_f = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _f.total_words) || 0;
            const targetWords = Number(((_g = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _g.target_total_words) || ((_h = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _h.targetWordCount) || 0) || 0;
            let displayTitle = cfg && cfg.basic && cfg.basic.title ? cfg.basic.title : book.name || "";
            const q = filter ? String(filter).trim().toLowerCase() : "";
            if (q) {
              const fields = [displayTitle || book.name || "", subtitle || "", authors || "", desc || ""];
              const matches = fields.some((f) => {
                const s = String(f).toLowerCase();
                if (s.startsWith(q))
                  return true;
                return s.split(/\s+/).some((w) => w.startsWith(q));
              });
              if (!matches)
                continue;
            }
            const row = list.createDiv({ cls: "novelist-switch-book-row" });
            const leftCol = row.createDiv({ cls: "novelist-switch-left" });
            const rightCol = row.createDiv({ cls: "novelist-switch-right" });
            const titleRow = leftCol.createDiv({ cls: "novelist-switch-title-row" });
            titleRow.createSpan({ text: displayTitle || book.name || "Untitled", cls: "novelist-switch-title" });
            if (subtitle) {
              titleRow.createSpan({ text: " - ", cls: "novelist-switch-dash" });
              titleRow.createSpan({ text: subtitle, cls: "novelist-switch-subtitle" });
            }
            const progressPct = targetWords > 0 ? Math.round(Number(totalWords) / Number(targetWords) * 100) : "\u2014";
            let lastMod = "\u2014";
            try {
              const lm = ((_i = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _i.last_modified) || ((_j = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _j.lastModified) || "";
              if (lm)
                lastMod = new Date(lm).toLocaleString();
            } catch (e) {
            }
            leftCol.createDiv({ text: `Author: ${authors || "\u2014"} | Progress: ${progressPct}% | Words: ${formatTarget(totalWords)}`, cls: "novelist-switch-meta" });
            leftCol.createDiv({ text: `Last modified: ${lastMod}`, cls: "novelist-switch-meta-second" });
            const selectBtn = rightCol.createEl("button", { text: "Select", cls: "mod-cta" });
            selectBtn.onclick = () => {
              this.plugin.activeBook = book;
              this.plugin.rerenderViews();
              this.close();
            };
            row.onclick = () => selectBtn.click();
          }
        };
        search.addEventListener("input", (e) => {
          renderList(e.target.value);
        });
        await renderList("");
      }
    };
  }
});

// src/modals/confirmModal.js
var Modal3, ConfirmModal;
var init_confirmModal = __esm({
  "src/modals/confirmModal.js"() {
    ({ Modal: Modal3 } = require("obsidian"));
    ConfirmModal = class extends Modal3 {
      constructor(app, { title, message, confirmText, onConfirm }) {
        super(app);
        this.title = title;
        this.message = message;
        this.confirmText = confirmText || "Confirm";
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: this.title });
        contentEl.createEl("p", { text: this.message });
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", { text: "Cancel" });
        const confirmBtn = actions.createEl("button", {
          text: this.confirmText,
          cls: "mod-warning"
        });
        cancelBtn.onclick = () => this.close();
        confirmBtn.onclick = async () => {
          await this.onConfirm();
          this.close();
        };
      }
    };
  }
});

// src/modals/editBookModal.js
var Modal4, TFile4, EditBookModal;
var init_editBookModal = __esm({
  "src/modals/editBookModal.js"() {
    ({ Modal: Modal4, TFile: TFile4 } = require("obsidian"));
    EditBookModal = class extends Modal4 {
      constructor(plugin, book) {
        super(plugin.app);
        this.plugin = plugin;
        this.book = book;
      }
      async onOpen() {
        var _a, _b, _c, _d, _e, _f, _g;
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Edit book" });
        let meta = {};
        let cfg = {};
        try {
          if (this.plugin.loadBookConfig)
            cfg = await this.plugin.loadBookConfig(this.book) || {};
        } catch (e) {
        }
        if (cfg && cfg.basic) {
          meta.title = cfg.basic.title || this.book.name || "";
          meta.subtitle = cfg.basic.subtitle || "";
          meta.author = Array.isArray(cfg.basic.author) ? cfg.basic.author.join(", ") : cfg.basic.author || "";
          meta.description = cfg.basic.desc || cfg.basic.description || "";
        } else {
          try {
            if (this.plugin.loadBookMeta)
              meta = await this.plugin.loadBookMeta(this.book) || {};
          } catch (e) {
          }
          try {
            if (!meta || Object.keys(meta).length === 0) {
              const fm = await this.plugin.readBookMetadata(this.book);
              if (fm)
                meta = Object.assign({}, meta, fm);
            }
          } catch (e) {
          }
        }
        const fieldWidth = "min(320px, 60%)";
        let selectedCover = null;
        contentEl.createDiv({ cls: "novelist-modal-divider" });
        const coverRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const coverLeft = coverRow.createDiv({ cls: "novelist-modal-left" });
        coverLeft.createEl("div", { text: "Cover", cls: "novelist-modal-row-title" });
        coverLeft.createEl("div", { text: "Select image (optional)", cls: "novelist-modal-row-sub" });
        const coverRight = coverRow.createDiv({ cls: "novelist-modal-right" });
        const coverBtn = coverRight.createEl("button", { text: "Select Image" });
        try {
          const existingCover = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.cover) || "";
          if (existingCover) {
            const baseName = existingCover.split("/").pop();
            selectedCover = { name: baseName, data: null };
          }
        } catch (e) {
        }
        coverBtn.onclick = () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.style.display = "none";
          input.onchange = async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file)
              return;
            try {
              const reader = new FileReader();
              reader.onload = (ev) => {
                const ab = ev.target.result;
                selectedCover = { name: file.name, data: ab };
                coverBtn.textContent = "Select Image";
              };
              reader.readAsArrayBuffer(file);
            } catch (err) {
              console.warn("cover selection failed", err);
            }
          };
          document.body.appendChild(input);
          input.click();
          document.body.removeChild(input);
        };
        contentEl.createDiv({ cls: "novelist-modal-divider" });
        const titleRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const titleLeft = titleRow.createDiv({ cls: "novelist-modal-left" });
        titleLeft.createEl("div", { text: "Title", cls: "novelist-modal-row-title" });
        titleLeft.createEl("div", { text: "Please enter book title", cls: "novelist-modal-row-sub" });
        const titleRight = titleRow.createDiv({ cls: "novelist-modal-right" });
        const titleInput = titleRight.createEl("input", { type: "text", cls: "novelist-modal-input" });
        try {
          titleInput.style.width = fieldWidth;
        } catch (e) {
        }
        titleInput.value = meta.title || this.book.name || "";
        contentEl.createDiv({ cls: "novelist-modal-divider" });
        const subRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const subLeft = subRow.createDiv({ cls: "novelist-modal-left" });
        subLeft.createEl("div", { text: "Subtitle", cls: "novelist-modal-row-title" });
        subLeft.createEl("div", { text: "Optional", cls: "novelist-modal-row-sub" });
        const subRight = subRow.createDiv({ cls: "novelist-modal-right" });
        const subtitleInput = subRight.createEl("input", { type: "text", cls: "novelist-modal-input" });
        try {
          subtitleInput.style.width = fieldWidth;
        } catch (e) {
        }
        subtitleInput.value = meta.subtitle || "";
        contentEl.createDiv({ cls: "novelist-modal-divider" });
        const authorRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const authorLeft = authorRow.createDiv({ cls: "novelist-modal-left" });
        authorLeft.createEl("div", { text: "Author", cls: "novelist-modal-row-title" });
        authorLeft.createEl("div", { text: "Enter author names, separate multiple authors with commas", cls: "novelist-modal-row-sub" });
        const authorRight = authorRow.createDiv({ cls: "novelist-modal-right" });
        const authorInput = authorRight.createEl("input", { type: "text", cls: "novelist-modal-input" });
        try {
          authorInput.style.width = fieldWidth;
        } catch (e) {
        }
        authorInput.value = meta.author || "";
        contentEl.createDiv({ cls: "novelist-modal-divider" });
        const descRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const descLeft = descRow.createDiv({ cls: "novelist-modal-left" });
        descLeft.createEl("div", { text: "Description", cls: "novelist-modal-row-title" });
        descLeft.createEl("div", { text: "Please enter book description", cls: "novelist-modal-row-sub" });
        const descRight = descRow.createDiv({ cls: "novelist-modal-right" });
        const descInput = descRight.createEl("textarea", { cls: "novelist-modal-textarea" });
        try {
          descInput.style.width = fieldWidth;
          descInput.style.minHeight = "120px";
          descInput.style.maxWidth = "100%";
        } catch (e) {
        }
        descInput.value = meta.description || "";
        contentEl.createDiv({ cls: "novelist-modal-divider" });
        const targetRow = contentEl.createDiv({ cls: "novelist-modal-row" });
        const targetLeft = targetRow.createDiv({ cls: "novelist-modal-left" });
        targetLeft.createEl("div", { text: "Target word count", cls: "novelist-modal-row-title" });
        targetLeft.createEl("div", { text: "Set estimated total word count (in 1k)", cls: "novelist-modal-row-sub" });
        const targetRight = targetRow.createDiv({ cls: "novelist-modal-right" });
        const targetInput = targetRight.createEl("input", { type: "text", cls: "novelist-modal-input", placeholder: "e.g., 20 (20k) or 20000" });
        const existingTarget = (_g = (_f = (_d = (_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.targetWordCount) != null ? _d : (_c = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _c.target_total_words) != null ? _f : (_e = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _e.targetWordCount) != null ? _g : "";
        try {
          const num = Number(existingTarget) || 0;
          if (num >= 1e3) {
            targetInput.value = String(num / 1e3);
          } else {
            targetInput.value = existingTarget || "";
          }
        } catch (e) {
          targetInput.value = existingTarget || "";
        }
        try {
          targetInput.style.width = fieldWidth;
        } catch (e) {
        }
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", { text: "Cancel" });
        const saveBtn = actions.createEl("button", { text: "Save", cls: "mod-cta" });
        cancelBtn.onclick = () => this.close();
        saveBtn.onclick = async () => {
          const out = Object.assign({}, meta || {});
          out.title = titleInput.value.trim();
          out.subtitle = typeof subtitleInput !== "undefined" ? subtitleInput.value.trim() : "";
          out.author = authorInput.value.trim();
          out.description = descInput.value.trim();
          const targetRaw = targetInput.value.trim();
          const targNum = parseFloat(targetRaw) || 0;
          try {
            if (this.plugin.saveBookMeta) {
              const metaToSave = {
                title: out.title,
                subtitle: out.subtitle || "",
                author: out.author || "",
                description: out.description || "",
                targetWordCount: targNum
              };
              await this.plugin.saveBookMeta(this.book, metaToSave);
            }
          } catch (e) {
            console.warn("saveBookMeta failed", e);
          }
          let cfg2 = {};
          try {
            if (this.plugin.loadBookConfig)
              cfg2 = await this.plugin.loadBookConfig(this.book) || {};
            cfg2.basic = cfg2.basic || {};
            cfg2.stats = cfg2.stats || {};
            cfg2.basic.title = out.title || cfg2.basic.title || this.book.name;
            cfg2.basic.subtitle = out.subtitle || cfg2.basic.subtitle || "";
            cfg2.basic.author = out.author ? out.author.split(",").map((s) => s.trim()).filter(Boolean) : cfg2.basic.author || [];
            cfg2.basic.desc = out.description || cfg2.basic.desc || "";
            let normalizedTarget = 0;
            if (targNum > 0) {
              if (targNum >= 1e3)
                normalizedTarget = Math.round(targNum);
              else
                normalizedTarget = Math.round(targNum * 1e3);
            }
            cfg2.stats = cfg2.stats || {};
            cfg2.stats.target_total_words = normalizedTarget;
            cfg2.stats.last_modified = new Date().toISOString();
            if (selectedCover && selectedCover.name && selectedCover.data) {
              try {
                const destName = `${Date.now()}-${selectedCover.name}`.replace(/[^a-zA-Z0-9._-]/g, "_");
                const destPath = `${this.book.path}/misc/cover/${destName}`;
                if (this.plugin.app.vault.adapter && typeof this.plugin.app.vault.adapter.writeBinary === "function") {
                  const uint8 = new Uint8Array(selectedCover.data);
                  await this.plugin.app.vault.adapter.writeBinary(destPath, uint8);
                } else {
                  const blob = new Blob([selectedCover.data]);
                  const arrayBuf = await blob.arrayBuffer();
                  const uint8 = new Uint8Array(arrayBuf);
                  try {
                    await this.plugin.app.vault.create(destPath, uint8);
                  } catch (e) {
                    console.warn("fallback cover write failed", e);
                  }
                }
                cfg2.basic = cfg2.basic || {};
                cfg2.basic.cover = `misc/cover/${destName}`;
              } catch (e) {
                console.warn("saving selected cover failed", e);
              }
            }
            if (this.plugin.saveBookConfig)
              await this.plugin.saveBookConfig(this.book, cfg2);
          } catch (e) {
            console.warn(e);
          }
          let newTitle;
          try {
            newTitle = cfg2 && cfg2.basic && cfg2.basic.title ? cfg2.basic.title : out.title || this.book.name;
            try {
              this.book.name = newTitle;
            } catch (e) {
            }
            if (Array.isArray(this.plugin.booksIndex)) {
              const idx = this.plugin.booksIndex.findIndex((b) => b && b.path === this.book.path);
              if (idx !== -1)
                this.plugin.booksIndex[idx].name = newTitle;
            }
            try {
              if (this.plugin.activeBook && this.plugin.activeBook.path === this.book.path)
                this.plugin.activeBook.name = newTitle;
            } catch (e) {
            }
          } catch (err) {
            console.warn("updating in-memory book title failed", err);
          }
          try {
            const oldPath = this.book.path;
            const parentParts = String(oldPath).split("/").slice(0, -1);
            const parent = parentParts.join("/");
            const safeName = String(newTitle || "").replace(/[\\/\:\*\?"<>\|]/g, "_").trim();
            const newPath = parent ? `${parent}/${safeName}` : safeName;
            if (safeName && newPath !== oldPath) {
              const existing = this.plugin.app.vault.getAbstractFileByPath(newPath);
              if (!existing) {
                const folderAf = this.plugin.app.vault.getAbstractFileByPath(oldPath);
                if (folderAf) {
                  const onUnhandledRej = (ev) => {
                    try {
                      const r = ev && ev.reason;
                      if (!r)
                        return;
                      if (r && r.code === "ENOENT" && typeof r.message === "string" && r.message.includes(oldPath)) {
                        try {
                          ev.preventDefault && ev.preventDefault();
                        } catch (e) {
                        }
                      }
                    } catch (e) {
                    }
                  };
                  try {
                    if (typeof window !== "undefined" && window && window.addEventListener) {
                      window.addEventListener("unhandledrejection", onUnhandledRej);
                    }
                    try {
                      if (this.plugin.app.fileManager && typeof this.plugin.app.fileManager.renameFile === "function") {
                        await this.plugin.app.fileManager.renameFile(folderAf, newPath);
                      } else {
                        await this.plugin.app.vault.rename(folderAf, newPath);
                      }
                    } finally {
                      try {
                        await new Promise((r) => setTimeout(r, 250));
                      } catch (e) {
                      }
                    }
                    try {
                      await this.plugin.waitForFolderSync(newPath, 40);
                    } catch (e) {
                    }
                    const checkAf = this.plugin.app.vault.getAbstractFileByPath(newPath);
                    if (checkAf) {
                      try {
                        this.book.path = newPath;
                      } catch (e) {
                      }
                      if (Array.isArray(this.plugin.booksIndex)) {
                        const idx2 = this.plugin.booksIndex.findIndex((b) => b && b.path === oldPath);
                        if (idx2 !== -1) {
                          this.plugin.booksIndex[idx2].path = newPath;
                          this.plugin.booksIndex[idx2].name = newTitle;
                        }
                      }
                      if (this.plugin.activeBook && this.plugin.activeBook.path === oldPath) {
                        this.plugin.activeBook.path = newPath;
                        this.plugin.activeBook.name = newTitle;
                        try {
                          this.plugin.settings = this.plugin.settings || {};
                          this.plugin.settings.lastActiveBookPath = newPath;
                          await this.plugin.saveSettings();
                        } catch (e) {
                        }
                      }
                    } else {
                      console.warn("rename succeeded but new folder not visible yet", newPath);
                    }
                  } catch (e) {
                    console.warn("folder rename failed", e);
                  } finally {
                    try {
                      if (typeof window !== "undefined" && window && window.removeEventListener)
                        window.removeEventListener("unhandledrejection", onUnhandledRej);
                    } catch (e) {
                    }
                  }
                }
              } else {
                console.warn("target folder already exists, skipping rename", newPath);
              }
            }
          } catch (e) {
            console.warn("rename attempt failed", e);
          }
          try {
            document.dispatchEvent(new CustomEvent("novelist:book-updated", { detail: { path: this.book.path } }));
          } catch (e) {
          }
          await this.plugin.refresh();
          this.plugin.rerenderViews();
          this.close();
        };
      }
    };
  }
});

// src/modals/manageBooksModal.js
var manageBooksModal_exports = {};
__export(manageBooksModal_exports, {
  ManageBooksModal: () => ManageBooksModal
});
var Modal5, TFile5, ManageBooksModal;
var init_manageBooksModal = __esm({
  "src/modals/manageBooksModal.js"() {
    init_confirmModal();
    init_editBookModal();
    ({ Modal: Modal5, TFile: TFile5 } = require("obsidian"));
    ManageBooksModal = class extends Modal5 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Manage books" });
        const search = contentEl.createEl("input", {
          type: "text",
          placeholder: "Search books...",
          cls: "novelist-manage-search"
        });
        const list = contentEl.createDiv({ cls: "novelist-manage-list" });
        const formatTarget = (n) => {
          if (!n)
            return "\u2014";
          const num = Number(n) || 0;
          if (num >= 1e3) {
            const k = num / 1e3;
            return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
          }
          return String(num);
        };
        const renderList = async (filter) => {
          var _a, _b, _c, _d, _e, _f, _g, _h;
          list.empty();
          const seen = /* @__PURE__ */ new Set();
          for (const book of this.plugin.booksIndex) {
            if (!book || !book.path)
              continue;
            if (seen.has(book.path))
              continue;
            seen.add(book.path);
            let cfg = {};
            try {
              cfg = await this.plugin.loadBookConfig(book) || {};
            } catch (e) {
            }
            const subtitle = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.subtitle) || "";
            const authors = Array.isArray((_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.author) ? cfg.basic.author.join(", ") : ((_c = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _c.author) || "";
            const desc = ((_d = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _d.desc) || ((_e = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _e.description) || "";
            const totalWords = ((_f = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _f.total_words) || 0;
            const targetWords = Number(((_g = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _g.target_total_words) || ((_h = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _h.targetWordCount) || 0) || 0;
            const displayTitle = cfg && cfg.basic && cfg.basic.title ? cfg.basic.title : book.name || "";
            const q = filter ? String(filter).trim().toLowerCase() : "";
            if (q) {
              const fields = [displayTitle || book.name || "", subtitle || "", authors || "", desc || ""];
              const matches = fields.some((f) => {
                const s = String(f).toLowerCase();
                if (s.startsWith(q))
                  return true;
                return s.split(/\s+/).some((w) => w.startsWith(q));
              });
              if (!matches)
                continue;
            }
            const card = list.createDiv({ cls: "novelist-manage-card" });
            const left = card.createDiv({ cls: "novelist-manage-left" });
            const right = card.createDiv({ cls: "novelist-manage-right" });
            const coverWrap = left.createDiv({ cls: "novelist-manage-cover" });
            try {
              const coverFile = book.cover instanceof TFile5 ? book.cover : book.cover ? this.plugin.app.vault.getAbstractFileByPath(book.cover) : null;
              if (coverFile instanceof TFile5) {
                const url = this.plugin.app.vault.getResourcePath(coverFile);
                coverWrap.style.backgroundImage = `url("${url}")`;
              }
            } catch (e) {
            }
            try {
              const coverFile = book.cover instanceof TFile5 ? book.cover : book.cover ? this.plugin.app.vault.getAbstractFileByPath(book.cover) : null;
              if (!(coverFile instanceof TFile5)) {
                coverWrap.addClass("novelist-manage-cover-placeholder");
                try {
                  coverWrap.createSpan({ text: "TBD", cls: "novelist-manage-cover-txt" });
                } catch (e) {
                  coverWrap.textContent = "TBD";
                }
              }
            } catch (e) {
            }
            const titleRow = right.createDiv({ cls: "novelist-manage-title-row" });
            titleRow.createDiv({ text: displayTitle || book.name || "Untitled", cls: "novelist-manage-title" });
            const actions = titleRow.createDiv({ cls: "novelist-manage-actions" });
            const deleteBtn = actions.createEl("button", { text: "Delete", cls: "mod-danger" });
            const editBtn = actions.createEl("button", { text: "Edit" });
            const metaGrid = right.createDiv({ cls: "novelist-manage-meta-grid" });
            const labelsCol = metaGrid.createDiv({ cls: "novelist-manage-labels" });
            const valuesCol = metaGrid.createDiv({ cls: "novelist-manage-values" });
            labelsCol.createEl("div", { text: "Author", cls: "novelist-manage-label" });
            valuesCol.createEl("div", { text: authors || "\u2014", cls: "novelist-manage-author" });
            labelsCol.createEl("div", { text: "Description", cls: "novelist-manage-label" });
            const short = desc ? desc.length > 160 ? desc.slice(0, 157) + "\u2026" : desc : "\u2014";
            valuesCol.createEl("div", { text: short, cls: "novelist-manage-desc" });
            labelsCol.createEl("div", { text: "Progress", cls: "novelist-manage-label" });
            valuesCol.createEl("div", { text: `${totalWords} / ${formatTarget(targetWords)}`, cls: "novelist-manage-progress" });
            deleteBtn.onclick = async () => {
              const self = this;
              const modal = new ConfirmModal(this.plugin.app, {
                title: `Delete ${book.name}`,
                message: `Delete book "${book.name}" and all its files? This cannot be undone.`,
                confirmText: "Delete",
                onConfirm: async () => {
                  try {
                    await self.plugin.deleteFolderRecursive(book.path);
                  } catch (e) {
                    console.warn("delete book failed", e);
                  }
                  await self.plugin.refresh();
                  self.close();
                }
              });
              modal.open();
            };
            editBtn.onclick = () => {
              new EditBookModal(this.plugin, book).open();
            };
          }
          if (!list.children || list.children.length === 0) {
            const empty = list.createDiv({ cls: "novelist-manage-empty" });
            empty.createEl("div", { text: "No books found" });
          }
        };
        search.addEventListener("input", (e) => {
          renderList(e.target.value);
        });
        this._onBookUpdated = (ev) => {
          try {
            renderList(search.value);
          } catch (e) {
          }
        };
        document.addEventListener("novelist:book-updated", this._onBookUpdated);
        await renderList("");
      }
      onClose() {
        try {
          document.removeEventListener("novelist:book-updated", this._onBookUpdated);
        } catch (e) {
        }
      }
    };
  }
});

// src/modals/helpModal.js
var helpModal_exports = {};
__export(helpModal_exports, {
  HelpModal: () => HelpModal
});
var Modal6, HelpModal;
var init_helpModal = __esm({
  "src/modals/helpModal.js"() {
    ({ Modal: Modal6 } = require("obsidian"));
    HelpModal = class extends Modal6 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Help" });
        contentEl.createEl("p", { text: "TBD" });
      }
    };
  }
});

// src/modals/textInputModal.js
var textInputModal_exports = {};
__export(textInputModal_exports, {
  TextInputModal: () => TextInputModal
});
var Modal7, TextInputModal;
var init_textInputModal = __esm({
  "src/modals/textInputModal.js"() {
    ({ Modal: Modal7 } = require("obsidian"));
    TextInputModal = class extends Modal7 {
      constructor(app, { title, placeholder, cta, onSubmit }) {
        super(app);
        this.title = title;
        this.placeholder = placeholder;
        this.cta = cta;
        this.onSubmit = onSubmit;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: this.title });
        const input = contentEl.createEl("input", {
          type: "text",
          placeholder: this.placeholder
        });
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", {
          text: "Cancel"
        });
        const confirmBtn = actions.createEl("button", {
          text: this.cta,
          cls: "mod-cta"
        });
        cancelBtn.onclick = () => this.close();
        confirmBtn.onclick = () => {
          const value = input.value.trim();
          if (!value)
            return;
          this.onSubmit(value);
          this.close();
        };
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            confirmBtn.click();
          } else if (e.key === "Escape") {
            this.close();
          }
        });
        input.focus();
      }
    };
  }
});

// src/constants/index.js
var VIEW_TYPE = "novelist-view";
var DEFAULT_SETTINGS = {
  booksPath: "projects",
  basePath: "projects",
  // Legacy compatibility
  lastActiveBookPath: null,
  verboseLogs: false
};
var DEFAULT_BOOK_CONFIG = {
  basic: {
    title: "",
    author: [],
    subtitle: "",
    desc: "",
    uuid: "",
    created_at: new Date().toISOString()
  },
  structure: {
    tree: []
  },
  stats: {
    total_words: 0,
    target_total_words: 1e4,
    progress_by_words: 0,
    progress_by_chapter: 0,
    daily_words: {},
    writing_days: 0,
    average_daily_words: 0,
    last_writing_date: new Date().toISOString(),
    last_modified: new Date().toISOString(),
    per_chapter: {}
  },
  export: {
    default_format: "pdf",
    template: "default",
    include_cover: true
  }
};

// src/services/configService.js
var ConfigService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Load full book config from book-config.json inside misc folder
   */
  async loadBookConfig(book) {
    try {
      const filePath = `${book.path}/misc/book-config.json`;
      const f = this.app.vault.getAbstractFileByPath(filePath);
      if (!f)
        return null;
      const content = await this.app.vault.read(f);
      return JSON.parse(content);
    } catch (e) {
      if (!e || e.code === "ENOENT")
        return null;
      console.warn("loadBookConfig failed", e);
      return null;
    }
  }
  /**
   * Save full book config to book-config.json inside misc folder
   * Performs intelligent merge with existing config to avoid data loss
   */
  async saveBookConfig(book, config) {
    try {
      const filePath = `${book.path}/misc/book-config.json`;
      const miscDir = `${book.path}/misc`;
      try {
        const existingMisc = this.app.vault.getAbstractFileByPath(miscDir);
        if (!existingMisc) {
          await this.app.vault.createFolder(miscDir);
        }
      } catch (e) {
      }
      const f = this.app.vault.getAbstractFileByPath(filePath);
      let finalCfg = config || {};
      if (f) {
        try {
          const existingRaw = await this.app.vault.read(f);
          const existing = JSON.parse(existingRaw || "{}");
          const mergeObjects = (base, incoming) => {
            const out = Object.assign({}, base || {});
            if (!incoming)
              return out;
            for (const k of Object.keys(incoming)) {
              const v = incoming[k];
              if (v === void 0 || v === null)
                continue;
              if (Array.isArray(v)) {
                if (v.length > 0)
                  out[k] = v;
              } else if (typeof v === "object") {
                out[k] = mergeObjects(base ? base[k] : void 0, v);
              } else {
                if (typeof v === "string") {
                  if (v === "" && base && typeof base[k] === "string" && base[k].trim() !== "") {
                    out[k] = base[k];
                  } else {
                    out[k] = v;
                  }
                } else {
                  out[k] = v;
                }
              }
            }
            return out;
          };
          const merged = Object.assign({}, existing || {});
          merged.basic = mergeObjects(existing.basic, finalCfg.basic);
          merged.stats = mergeObjects(existing.stats, finalCfg.stats);
          for (const k of Object.keys(finalCfg)) {
            if (k !== "basic" && k !== "stats")
              merged[k] = finalCfg[k];
          }
          finalCfg = merged;
        } catch (e) {
          finalCfg = config || {};
        }
        const content = JSON.stringify(finalCfg || {}, null, 2);
        await this.app.vault.modify(f, content);
      } else {
        const content = JSON.stringify(finalCfg || {}, null, 2);
        await this.app.vault.create(filePath, content);
      }
      return true;
    } catch (e) {
      console.warn("saveBookConfig failed", e);
      return false;
    }
  }
  /**
   * Load book metadata (simplified view of config)
   */
  async loadBookMeta(book) {
    var _a, _b, _c, _d, _e, _f, _g;
    try {
      const cfg = await this.loadBookConfig(book);
      if (!cfg)
        return null;
      return {
        title: ((_a = cfg.basic) == null ? void 0 : _a.title) || "",
        author: ((_b = cfg.basic) == null ? void 0 : _b.author) || [],
        subtitle: ((_c = cfg.basic) == null ? void 0 : _c.subtitle) || "",
        description: ((_d = cfg.basic) == null ? void 0 : _d.desc) || "",
        uuid: ((_e = cfg.basic) == null ? void 0 : _e.uuid) || "",
        created_at: ((_f = cfg.basic) == null ? void 0 : _f.created_at) || new Date().toISOString(),
        target_words: ((_g = cfg.stats) == null ? void 0 : _g.target_total_words) || 0
      };
    } catch (e) {
      console.warn("loadBookMeta failed", e);
      return null;
    }
  }
  /**
   * Create a new book config with default structure
   */
  createDefaultConfig(title, author) {
    const uuid = this.generateUUID();
    const now = new Date().toISOString();
    return {
      basic: {
        title: title || "",
        author: author ? [author] : [],
        subtitle: "",
        desc: "",
        uuid,
        created_at: now
      },
      structure: {
        tree: []
      },
      stats: {
        total_words: 0,
        target_total_words: 1e4,
        progress_by_words: 0,
        progress_by_chapter: 0,
        daily_words: {},
        writing_days: 0,
        average_daily_words: 0,
        last_writing_date: now,
        last_modified: now,
        per_chapter: {}
      },
      export: {
        default_format: "pdf",
        template: "default",
        include_cover: true
      }
    };
  }
  /**
   * Generate a simple UUID
   */
  generateUUID() {
    const timestamp = Date.now().toString(16);
    const random = Math.random().toString(36).substr(2, 9);
    return `${timestamp}-${random}`;
  }
};

// src/services/treeService.js
var import_obsidian = require("obsidian");
var TreeService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Generate unique node ID
   */
  generateNodeId() {
    return `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Build tree from filesystem (sync tree structure with actual files/folders)
   * Merges with existing config to preserve order, IDs, and metadata
   */
  async buildTreeFromFilesystem(bookFolder) {
    var _a;
    try {
      const cfg = await this.configService.loadBookConfig({ path: bookFolder.path }) || {};
      const existingTree = ((_a = cfg == null ? void 0 : cfg.structure) == null ? void 0 : _a.tree) || [];
      const existingMap = /* @__PURE__ */ new Map();
      const mapNodes = (nodes2) => {
        for (const node of nodes2) {
          existingMap.set(node.path, node);
          if (node.children)
            mapNodes(node.children);
        }
      };
      mapNodes(existingTree);
      const buildNode = (item, order) => {
        var _a2, _b, _c;
        const relativePath = item.path.replace(bookFolder.path + "/", "");
        const existing = existingMap.get(relativePath);
        if (item instanceof import_obsidian.TFile) {
          return {
            id: (existing == null ? void 0 : existing.id) || this.generateNodeId(),
            title: (existing == null ? void 0 : existing.title) || item.basename,
            type: item.extension === "canvas" ? "canvas" : "file",
            path: relativePath,
            order: (_a2 = existing == null ? void 0 : existing.order) != null ? _a2 : order,
            exclude: (existing == null ? void 0 : existing.exclude) || false,
            completed: (existing == null ? void 0 : existing.completed) || false,
            created_at: (existing == null ? void 0 : existing.created_at) || new Date().toISOString(),
            last_modified: new Date().toISOString()
          };
        } else if (item instanceof import_obsidian.TFolder) {
          const folderChildren = (item.children || []).filter((child) => !(child instanceof import_obsidian.TFolder && child.name === "misc"));
          const childNodes = folderChildren.map((child) => buildNode(child, 0));
          childNodes.sort((a, b) => {
            if (a.order && b.order)
              return a.order - b.order;
            return a.title.localeCompare(b.title);
          });
          childNodes.forEach((node, idx) => node.order = idx + 1);
          const children = childNodes;
          return {
            id: (existing == null ? void 0 : existing.id) || this.generateNodeId(),
            title: (existing == null ? void 0 : existing.title) || item.name,
            type: "group",
            path: relativePath,
            order: (_b = existing == null ? void 0 : existing.order) != null ? _b : order,
            is_expanded: (_c = existing == null ? void 0 : existing.is_expanded) != null ? _c : false,
            created_at: (existing == null ? void 0 : existing.created_at) || new Date().toISOString(),
            last_modified: new Date().toISOString(),
            children
          };
        }
      };
      const tree = [];
      const fsChildren = (bookFolder.children || []).filter((child) => !(child instanceof import_obsidian.TFolder && child.name === "misc"));
      const nodes = fsChildren.map((child) => buildNode(child, 0));
      nodes.sort((a, b) => {
        if (a.order && b.order)
          return a.order - b.order;
        return a.title.localeCompare(b.title);
      });
      nodes.forEach((node, idx) => {
        node.order = idx + 1;
        tree.push(node);
      });
      console.log("Built tree from filesystem:", tree);
      return tree;
    } catch (e) {
      console.warn("buildTreeFromFilesystem failed", e);
      return [];
    }
  }
  /**
   * Reorder tree nodes after drag and drop
   * Handles physical file movement in vault when parent changes
   */
  async reorderTreeNodes(book, draggedNodeId, targetNodeId, position) {
    try {
      const cfg = await this.configService.loadBookConfig(book) || {};
      if (!cfg.structure)
        cfg.structure = {};
      if (!cfg.structure.tree)
        cfg.structure.tree = [];
      const tree = cfg.structure.tree;
      const findNode = (nodes, id, parent = null) => {
        for (let i = 0; i < nodes.length; i++) {
          if (nodes[i].id === id) {
            return { node: nodes[i], parent, index: i, siblings: nodes };
          }
          if (nodes[i].children) {
            const result = findNode(nodes[i].children, id, nodes[i]);
            if (result)
              return result;
          }
        }
        return null;
      };
      const draggedInfo = findNode(tree, draggedNodeId);
      const targetInfo = findNode(tree, targetNodeId);
      if (!draggedInfo || !targetInfo) {
        console.warn("Could not find nodes for reorder", { draggedNodeId, targetNodeId });
        return false;
      }
      draggedInfo.siblings.splice(draggedInfo.index, 1);
      if (position === "inside" && targetInfo.node.type === "group") {
        const oldPath = `${book.path}/${draggedInfo.node.path}`;
        const fileName = draggedInfo.node.path.split("/").pop();
        const newPath = `${targetInfo.node.path}/${fileName}`;
        try {
          const fileToMove = this.app.vault.getAbstractFileByPath(oldPath);
          if (fileToMove) {
            await this.app.fileManager.renameFile(fileToMove, `${book.path}/${newPath}`);
            draggedInfo.node.path = newPath;
          }
        } catch (e) {
          console.warn("Failed to move file in vault:", e);
          return false;
        }
        if (!targetInfo.node.children)
          targetInfo.node.children = [];
        targetInfo.node.children.push(draggedInfo.node);
      } else {
        const draggedParentPath = draggedInfo.node.path.split("/").slice(0, -1).join("/");
        const targetParentPath = targetInfo.node.path.split("/").slice(0, -1).join("/");
        if (draggedParentPath !== targetParentPath) {
          const oldPath = `${book.path}/${draggedInfo.node.path}`;
          const fileName = draggedInfo.node.path.split("/").pop();
          const newPath = targetParentPath ? `${targetParentPath}/${fileName}` : fileName;
          try {
            const fileToMove = this.app.vault.getAbstractFileByPath(oldPath);
            if (fileToMove) {
              await this.app.fileManager.renameFile(fileToMove, `${book.path}/${newPath}`);
              draggedInfo.node.path = newPath;
            }
          } catch (e) {
            console.warn("Failed to move file to new level:", e);
            return false;
          }
        }
        const newTargetIndex = targetInfo.siblings.findIndex((n) => n.id === targetNodeId);
        if (newTargetIndex === -1)
          return false;
        const insertIndex = position === "before" ? newTargetIndex : newTargetIndex + 1;
        targetInfo.siblings.splice(insertIndex, 0, draggedInfo.node);
      }
      const reorderNodes = (nodes) => {
        nodes.forEach((node, idx) => {
          node.order = idx + 1;
          node.last_modified = new Date().toISOString();
          if (node.children)
            reorderNodes(node.children);
        });
      };
      reorderNodes(tree);
      await this.configService.saveBookConfig(book, cfg);
      return true;
    } catch (e) {
      console.warn("reorderTreeNodes failed", e);
      return false;
    }
  }
  /**
   * Mark a chapter as complete/incomplete
   * Updates both frontmatter and config tree
   */
  async markChapterComplete(book, file, completed) {
    var _a;
    try {
      await this.app.fileManager.processFrontMatter(file, (fm) => {
        fm.is_done = completed;
      });
      const cfg = await this.configService.loadBookConfig(book) || {};
      if (!((_a = cfg.structure) == null ? void 0 : _a.tree))
        return;
      const relativePath = file.path.replace(book.path + "/", "");
      const updateNode = (nodes) => {
        for (const node of nodes) {
          if (node.path === relativePath) {
            node.completed = completed;
            node.last_modified = new Date().toISOString();
            return true;
          }
          if (node.children && updateNode(node.children)) {
            return true;
          }
        }
        return false;
      };
      if (updateNode(cfg.structure.tree)) {
        await this.configService.saveBookConfig(book, cfg);
      }
    } catch (e) {
      console.warn("markChapterComplete failed", e);
    }
  }
  /**
   * Exclude/include a chapter from stats
   * Updates both frontmatter and config tree
   */
  async excludeFromStats(book, file, exclude) {
    var _a;
    try {
      await this.app.fileManager.processFrontMatter(file, (fm) => {
        fm.exclude_from_stats = exclude;
      });
      const cfg = await this.configService.loadBookConfig(book) || {};
      if (!((_a = cfg.structure) == null ? void 0 : _a.tree))
        return;
      const relativePath = file.path.replace(book.path + "/", "");
      const updateNode = (nodes) => {
        for (const node of nodes) {
          if (node.path === relativePath) {
            node.exclude = exclude;
            node.last_modified = new Date().toISOString();
            return true;
          }
          if (node.children && updateNode(node.children)) {
            return true;
          }
        }
        return false;
      };
      if (updateNode(cfg.structure.tree)) {
        await this.configService.saveBookConfig(book, cfg);
      }
    } catch (e) {
      console.warn("excludeFromStats failed", e);
    }
  }
};

// src/services/statsService.js
var StatsService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Count words in text
   */
  countWords(text) {
    if (!text)
      return 0;
    const parts = text.replace(/\n/g, " ").split(/\s+/).filter(Boolean);
    return parts.length;
  }
  /**
   * Get today's date key (YYYY-MM-DD)
   */
  getTodayKey() {
    return new Date().toISOString().slice(0, 10);
  }
  /**
   * Collect all markdown files recursively from a folder
   */
  collectMarkdownFiles(folder) {
    const files = [];
    const collect = (item) => {
      if (item.children) {
        for (const child of item.children) {
          collect(child);
        }
      } else if (item.extension === "md") {
        files.push(item);
      }
    };
    collect(folder);
    return files;
  }
  /**
   * Compute basic stats for a book and persist into book-config.json.stats
   */
  async computeAndSaveStatsForBook(book) {
    try {
      const folder = this.app.vault.getAbstractFileByPath(book.path);
      if (!folder)
        return;
      const mdFiles = this.collectMarkdownFiles(folder).filter((f) => {
        const rel = f.path.replace(book.path + "/", "");
        if (rel.startsWith("misc/"))
          return false;
        const parts = rel.split("/");
        if (parts.length < 2)
          return false;
        return true;
      });
      const perChapter = {};
      let total = 0;
      for (const f of mdFiles) {
        try {
          const content = await this.app.vault.read(f);
          const wc = this.countWords(content);
          perChapter[f.path.replace(book.path + "/", "")] = wc;
          total += wc;
        } catch (e) {
        }
      }
      let cfg = await this.configService.loadBookConfig(book) || {};
      cfg.basic = cfg.basic || { title: book.name };
      cfg.stats = cfg.stats || {};
      const today = this.getTodayKey();
      cfg.stats.daily_words = cfg.stats.daily_words || {};
      const previousTotal = Number(cfg.stats.total_words || 0);
      const delta = Math.max(0, total - previousTotal);
      if (delta > 0) {
        cfg.stats.daily_words[today] = (cfg.stats.daily_words[today] || 0) + delta;
      }
      cfg.stats.writing_days = Object.keys(cfg.stats.daily_words).length;
      const sumDaily = Object.values(cfg.stats.daily_words).reduce((a, b) => a + b, 0);
      cfg.stats.average_daily_words = cfg.stats.writing_days > 0 ? Math.round(sumDaily / cfg.stats.writing_days) : 0;
      cfg.stats.total_words = total;
      cfg.stats.per_chapter = perChapter;
      cfg.stats.last_writing_date = today;
      cfg.stats.last_modified = new Date().toISOString();
      const target = cfg.stats.target_total_words && Number(cfg.stats.target_total_words) || 0;
      cfg.stats.progress_by_words = target > 0 ? Math.round(total / target * 1e4) / 100 : 0;
      const totalCh = Object.keys(perChapter).length;
      const doneCh = Object.values(perChapter).filter((n) => n > 0).length;
      cfg.stats.progress_by_chapter = {
        completed: doneCh,
        total: totalCh,
        percent: totalCh > 0 ? Math.round(doneCh / totalCh * 1e4) / 100 : 0
      };
      await this.configService.saveBookConfig(book, { stats: cfg.stats });
      return cfg.stats;
    } catch (e) {
      console.warn("computeAndSaveStatsForBook failed", e);
      return null;
    }
  }
  /**
   * Sync chapter structure into stats baseline.
   * - Adds missing chapters with 0 words
   * - Removes deleted chapters from stats
   * DOES NOT recompute stats.
   */
  async syncChapterStatsBaseline(book) {
    try {
      let cfg = await this.configService.loadBookConfig(book) || {};
      cfg.stats = cfg.stats || {};
      cfg.stats.per_chapter = cfg.stats.per_chapter || {};
      const folder = this.app.vault.getAbstractFileByPath(book.path);
      if (!folder)
        return;
      const mdFiles = this.collectMarkdownFiles(folder).filter((f) => {
        const rel = f.path.replace(book.path + "/", "");
        if (rel.startsWith("misc/"))
          return false;
        const parts = rel.split("/");
        if (parts.length < 2)
          return false;
        return true;
      });
      const currentPaths = new Set(mdFiles.map((f) => f.path.replace(book.path + "/", "")));
      for (const relPath of currentPaths) {
        if (!(relPath in cfg.stats.per_chapter)) {
          cfg.stats.per_chapter[relPath] = 0;
        }
      }
      for (const storedPath of Object.keys(cfg.stats.per_chapter)) {
        if (!currentPaths.has(storedPath)) {
          delete cfg.stats.per_chapter[storedPath];
        }
      }
      cfg.stats.last_modified = new Date().toISOString();
      await this.configService.saveBookConfig(book, cfg);
    } catch (e) {
      console.warn("syncChapterStatsBaseline failed", e);
    }
  }
};

// src/services/bookService.js
var import_obsidian2 = require("obsidian");
var BookService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Scan for all books in the base path
   */
  async scanBooks(basePath) {
    var _a;
    const base = this.app.vault.getAbstractFileByPath(basePath);
    if (!(base instanceof import_obsidian2.TFolder))
      return [];
    const booksIndex = [];
    const seenPaths = /* @__PURE__ */ new Set();
    for (const bookFolder of base.children) {
      if (!bookFolder || !bookFolder.path)
        continue;
      if (seenPaths.has(bookFolder.path))
        continue;
      seenPaths.add(bookFolder.path);
      if (!(bookFolder instanceof import_obsidian2.TFolder))
        continue;
      const book = {
        name: bookFolder.name,
        path: bookFolder.path,
        cover: null,
        volumes: []
      };
      try {
        const legacyMetaPath = `${bookFolder.path}/misc/metadata`;
        const legacyMetaAf = this.app.vault.getAbstractFileByPath(legacyMetaPath);
        if (legacyMetaAf) {
          await this.app.vault.delete(legacyMetaAf, true);
        }
      } catch (e) {
      }
      for (const child of bookFolder.children) {
        if (child instanceof import_obsidian2.TFolder && child.name === "misc") {
          continue;
        }
        if (child instanceof import_obsidian2.TFolder) {
          const volume = {
            name: child.name,
            path: child.path,
            chapters: [],
            collapsed: false
          };
          for (const f of child.children) {
            if (f instanceof import_obsidian2.TFile && f.extension === "md") {
              volume.chapters.push({
                name: f.basename,
                path: f.path
              });
            }
          }
          book.volumes.push(volume);
        }
      }
      try {
        const cfg = await this.configService.loadBookConfig({ path: book.path }) || {};
        const coverRel = (_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.cover;
        if (coverRel) {
          const coverPath = `${book.path}/${coverRel}`;
          const coverFile = this.app.vault.getAbstractFileByPath(coverPath);
          if (coverFile instanceof import_obsidian2.TFile) {
            book.cover = coverFile;
          }
        } else {
          const coverFolderPath = `${book.path}/misc/cover`;
          const cf = this.app.vault.getAbstractFileByPath(coverFolderPath);
          if (cf && cf.children && cf.children.length > 0) {
            const first = cf.children.find((c) => c instanceof import_obsidian2.TFile);
            if (first)
              book.cover = first;
          }
        }
      } catch (e) {
      }
      booksIndex.push(book);
    }
    booksIndex.sort((a, b) => a.name.localeCompare(b.name));
    return booksIndex;
  }
  /**
   * Create a new book with default structure
   */
  async createBook(basePath, name) {
    if (!name)
      return;
    const path = `${basePath}/${name}`;
    if (await this.app.vault.adapter.exists(path))
      return;
    await this.app.vault.createFolder(path);
    const miscPath = `${path}/misc`;
    const coverPath = `${miscPath}/cover`;
    await this.app.vault.createFolder(miscPath);
    await this.app.vault.createFolder(coverPath);
    try {
      const bookConfigPath = `${path}/misc/book-config.json`;
      const now = new Date().toISOString();
      const defaultConfig = {
        basic: {
          title: name,
          author: [],
          subtitle: "",
          desc: "",
          uuid: `${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 10)}`,
          created_at: now
        },
        structure: {
          tree: [
            { id: "preface", title: "Preface", type: "file", path: "Preface.md", order: 1, default_status: "draft", created_at: now, last_modified: now },
            { id: "moodboard", title: "Moodboard", type: "canvas", path: "Moodboard.canvas", order: 2, default_status: "draft", created_at: now, last_modified: now },
            { id: "volume1", title: "Volume 1", type: "group", path: "Volume 1", order: 3, default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "outline", title: "Outline", type: "file", path: "Outline.md", order: 4, default_status: "draft", created_at: now, last_modified: now },
            { id: "afterword", title: "Afterword", type: "file", path: "Afterword.md", order: 5, default_status: "draft", created_at: now, last_modified: now }
          ]
        },
        stats: {
          total_words: 0,
          target_total_words: 1e4,
          progress_by_words: 0,
          progress_by_chapter: 0,
          daily_words: {},
          writing_days: 0,
          average_daily_words: 0,
          last_writing_date: now,
          last_modified: now
        },
        export: {
          default_format: "pdf",
          template: "default",
          include_cover: true
        }
      };
      if (!this.app.vault.getAbstractFileByPath(bookConfigPath)) {
        await this.app.vault.create(bookConfigPath, JSON.stringify(defaultConfig, null, 2));
      }
    } catch (e) {
      console.warn("createBook: failed to create book-config.json in misc", e);
    }
    const bookFolder = this.app.vault.getAbstractFileByPath(path);
    if (bookFolder instanceof import_obsidian2.TFolder) {
      await this.ensureBookBaseStructure(bookFolder);
    }
  }
  /**
   * Ensure book has basic structure (Preface, Outline, etc.)
   */
  async ensureBookBaseStructure(bookFolder) {
    const vault = this.app.vault;
    const filesToCreate = ["Preface.md", "Outline.md", "Moodboard.canvas", "Afterword.md"];
    for (const file of filesToCreate) {
      const filePath = `${bookFolder.path}/${file}`;
      if (!vault.getAbstractFileByPath(filePath)) {
        await vault.create(filePath, "");
      }
    }
    const miscPath = `${bookFolder.path}/misc`;
    const coverPath = `${miscPath}/cover`;
    if (!vault.getAbstractFileByPath(miscPath)) {
      await vault.createFolder(miscPath);
    }
    if (!vault.getAbstractFileByPath(coverPath)) {
      await vault.createFolder(coverPath);
    }
    try {
      const bmPath = `${bookFolder.path}/misc/book-config.json`;
      if (!vault.getAbstractFileByPath(bmPath)) {
        const now = new Date().toISOString();
        const defaultConfig = {
          basic: {
            title: bookFolder.name,
            author: [],
            subtitle: "",
            desc: "",
            uuid: `${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 10)}`,
            created_at: now
          },
          structure: { tree: [] },
          stats: {
            total_words: 0,
            target_total_words: 1e4,
            progress_by_words: 0,
            progress_by_chapter: 0,
            daily_words: {},
            writing_days: 0,
            average_daily_words: 0,
            last_writing_date: now,
            last_modified: now
          },
          export: {
            default_format: "pdf",
            template: "default",
            include_cover: true
          }
        };
        await vault.create(bmPath, JSON.stringify(defaultConfig, null, 2));
      }
    } catch (e) {
      console.warn("ensureBookBaseStructure: failed to create book-config.json in misc", e);
    }
  }
  /**
   * Create a new volume (folder) in a book
   */
  async createVolume(book, name) {
    if (!name)
      return;
    const path = `${book.path}/${name}`;
    if (await this.app.vault.adapter.exists(path))
      return;
    await this.app.vault.createFolder(path);
  }
  /**
   * Create a new chapter (markdown file) in a volume
   */
  async createChapter(volume, name) {
    if (!name)
      return;
    const path = `${volume.path}/${name}.md`;
    if (await this.app.vault.adapter.exists(path))
      return;
    await this.app.vault.create(path, "");
  }
  /**
   * Check if a file is a volume folder
   */
  isVolumeFolder(file, booksIndex) {
    try {
      return booksIndex.some(
        (b) => b.volumes.some((v) => v.path === file.path)
      );
    } catch (e) {
      return false;
    }
  }
  /**
   * Check if a file is a chapter file
   */
  isChapterFile(file, booksIndex) {
    try {
      return booksIndex.some(
        (b) => b.volumes.some(
          (v) => v.chapters.some((c) => c.path === file.path)
        )
      );
    } catch (e) {
      return false;
    }
  }
};

// src/views/novelistView.js
var import_obsidian3 = require("obsidian");
var NovelistView = class extends import_obsidian3.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this._isRendering = false;
    this._renderCounter = 0;
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Novelist";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    this.render();
  }
  onClose() {
    if (this.plugin && this.plugin.novelistLeaf === this.leaf) {
      this.plugin.novelistLeaf = null;
    }
  }
  clearView() {
    try {
      this.contentEl.empty();
    } catch (e) {
    }
    this._isRendering = false;
  }
  // Render a filesystem-backed editorial tree for a book folder (Obsidian-safe)
  // Now with Book-Smith style drag & drop support
  async renderBookTree(container, bookFolder) {
    container.empty();
    const folder = bookFolder instanceof import_obsidian3.TFolder ? bookFolder : this.plugin.app.vault.getAbstractFileByPath(
      (bookFolder == null ? void 0 : bookFolder.path) || bookFolder
    );
    if (!(folder instanceof import_obsidian3.TFolder)) {
      console.error("Invalid book folder", bookFolder);
      return;
    }
    const book = this.plugin.activeBook;
    if (!book)
      return;
    let configTree = [];
    let useConfigTree = false;
    try {
      configTree = await this.plugin.buildTreeFromFilesystem(folder);
      if (configTree.length > 0) {
        const cfg = await this.plugin.loadBookConfig(book) || {};
        if (!cfg.structure)
          cfg.structure = {};
        cfg.structure.tree = configTree;
        await this.plugin.saveBookConfig(book, cfg);
        useConfigTree = true;
      }
    } catch (e) {
      console.warn("Failed to build/sync tree from filesystem", e);
    }
    let draggedElement = null;
    let draggedNodeId = null;
    const setupDragEvents = (element, nodeId, nodeType) => {
      element.setAttribute("draggable", "true");
      element.addEventListener("dragstart", (e) => {
        draggedElement = element;
        draggedNodeId = nodeId;
        element.classList.add("novelist-dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", nodeId);
      });
      element.addEventListener("dragend", (e) => {
        element.classList.remove("novelist-dragging");
        document.querySelectorAll(".novelist-dragover, .novelist-dragover-before, .novelist-dragover-after, .novelist-dragover-inside").forEach((el) => el.classList.remove("novelist-dragover", "novelist-dragover-before", "novelist-dragover-after", "novelist-dragover-inside"));
        draggedElement = null;
        draggedNodeId = null;
      });
      element.addEventListener("dragover", (e) => {
        if (!draggedElement || draggedElement === element)
          return;
        e.preventDefault();
        e.stopPropagation();
        const rect = element.getBoundingClientRect();
        const mouseY = e.clientY;
        const elementTop = rect.top;
        const elementBottom = rect.bottom;
        const elementHeight = rect.height;
        element.classList.remove("novelist-dragover-before", "novelist-dragover-after", "novelist-dragover-inside");
        if (nodeType === "group") {
          const topQuarter = elementTop + elementHeight / 4;
          const bottomHalf = elementTop + elementHeight / 2;
          if (mouseY < topQuarter) {
            element.classList.add("novelist-dragover-before");
            e.dataTransfer.dropEffect = "move";
          } else if (mouseY > bottomHalf) {
            element.classList.add("novelist-dragover-after");
            e.dataTransfer.dropEffect = "move";
          } else {
            element.classList.add("novelist-dragover-inside");
            e.dataTransfer.dropEffect = "move";
          }
        } else {
          const middle = elementTop + elementHeight / 2;
          if (mouseY < middle) {
            element.classList.add("novelist-dragover-before");
          } else {
            element.classList.add("novelist-dragover-after");
          }
          e.dataTransfer.dropEffect = "move";
        }
      });
      element.addEventListener("dragleave", (e) => {
        element.classList.remove("novelist-dragover-before", "novelist-dragover-after", "novelist-dragover-inside");
      });
      element.addEventListener("drop", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!draggedNodeId || draggedElement === element)
          return;
        const rect = element.getBoundingClientRect();
        const mouseY = e.clientY;
        const elementTop = rect.top;
        const elementBottom = rect.bottom;
        const elementHeight = rect.height;
        let position = "after";
        if (nodeType === "group") {
          const topQuarter = elementTop + elementHeight / 4;
          const bottomHalf = elementTop + elementHeight / 2;
          if (mouseY < topQuarter) {
            position = "before";
          } else if (mouseY > bottomHalf) {
            position = "after";
          } else {
            position = "inside";
          }
        } else {
          const middle = elementTop + elementHeight / 2;
          position = mouseY < middle ? "before" : "after";
        }
        const success = await this.plugin.reorderTreeNodes(book, draggedNodeId, nodeId, position);
        if (success) {
          this.plugin.rerenderViews();
        }
        element.classList.remove("novelist-dragover-before", "novelist-dragover-after", "novelist-dragover-inside");
      });
    };
    const renderNodeFromConfig = (node, parentContainer) => {
      const fullPath = `${book.path}/${node.path}`;
      const vaultItem = this.plugin.app.vault.getAbstractFileByPath(fullPath);
      if (!vaultItem) {
        console.warn("Vault item not found:", fullPath, "for node:", node);
        return;
      }
      if (node.type === "group") {
        const folderRow = parentContainer.createDiv("novelist-tree-folder tree-item is-folder");
        folderRow.dataset.path = fullPath;
        folderRow.dataset.nodeId = node.id;
        const collapse = folderRow.createSpan({ cls: "novelist-tree-toggle" });
        collapse.classList.toggle("is-open", this.plugin.expandedFolders.has(fullPath));
        const folderIcon = folderRow.createSpan({ cls: "novelist-tree-icon folder-icon" });
        try {
          (0, import_obsidian3.setIcon)(folderIcon, this.plugin.expandedFolders.has(fullPath) ? "folder-open" : "folder");
          (0, import_obsidian3.setIcon)(collapse, this.plugin.expandedFolders.has(fullPath) ? "chevron-down" : "chevron-right");
        } catch (e) {
        }
        const titleSpan = folderRow.createSpan({ text: node.title, cls: "novelist-tree-label" });
        setupDragEvents(folderRow, node.id, "group");
        try {
          folderRow.addEventListener("contextmenu", (evt) => {
            evt.preventDefault();
            this.plugin.openVolumeMenu(evt, vaultItem);
          });
        } catch (e) {
        }
        const childrenEl = parentContainer.createDiv("novelist-tree-children");
        childrenEl.classList.toggle("is-open", this.plugin.expandedFolders.has(fullPath));
        if (!this.plugin.expandedFolders.has(fullPath))
          childrenEl.style.display = "none";
        collapse.onclick = (e) => {
          e.stopPropagation();
          const isHidden = childrenEl.style.display === "none";
          childrenEl.style.display = isHidden ? "" : "none";
          collapse.classList.toggle("is-open", isHidden);
          childrenEl.classList.toggle("is-open", isHidden);
          if (isHidden)
            this.plugin.expandedFolders.add(fullPath);
          else
            this.plugin.expandedFolders.delete(fullPath);
          try {
            (0, import_obsidian3.setIcon)(folderIcon, isHidden ? "folder-open" : "folder");
            (0, import_obsidian3.setIcon)(collapse, isHidden ? "chevron-down" : "chevron-right");
          } catch (e2) {
          }
        };
        if (node.children && node.children.length > 0) {
          const sortedChildren = [...node.children].sort((a, b) => a.order - b.order);
          sortedChildren.forEach((child) => renderNodeFromConfig(child, childrenEl));
        }
      } else {
        const fileRow = parentContainer.createDiv("novelist-tree-file tree-item is-file");
        fileRow.dataset.path = fullPath;
        fileRow.dataset.nodeId = node.id;
        const icon = fileRow.createSpan({ cls: "novelist-tree-icon" });
        try {
          (0, import_obsidian3.setIcon)(icon, node.type === "canvas" ? "layout-dashboard" : "file");
        } catch (e) {
        }
        const label = fileRow.createSpan({ text: node.title, cls: "novelist-tree-label" });
        if (node.exclude) {
          label.classList.add("exclude-from-stats");
        }
        if (node.completed) {
          label.classList.add("is-done");
        }
        fileRow.onclick = (e) => {
          e.stopPropagation();
          this.plugin.app.workspace.openLinkText(fullPath, "", false);
        };
        setupDragEvents(fileRow, node.id, "file");
        try {
          fileRow.addEventListener("contextmenu", (evt) => {
            evt.preventDefault();
            this.plugin.openChapterContextMenu(evt, vaultItem);
          });
        } catch (e) {
        }
      }
    };
    if (useConfigTree && configTree.length > 0) {
      console.log("Rendering tree with", configTree.length, "root nodes");
      const sortedTree = [...configTree].sort((a, b) => a.order - b.order);
      sortedTree.forEach((node) => renderNodeFromConfig(node, container));
    } else {
      console.warn("No config tree to render, useConfigTree:", useConfigTree, "length:", configTree.length);
    }
    try {
      container.addEventListener("contextmenu", (evt) => {
        try {
          if (evt.target && evt.target.closest && evt.target.closest(".tree-item"))
            return;
          evt.preventDefault();
          this.plugin.openVolumeMenu(evt, folder, true);
        } catch (e) {
        }
      });
    } catch (e) {
    }
  }
  async renderStats(container, book) {
    try {
      if (!book || !this.plugin.loadBookConfig)
        return;
      let cfg = {};
      try {
        cfg = await this.plugin.loadBookConfig(book) || {};
      } catch (e) {
      }
      try {
        if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
          console.debug("Novelist.renderStats loaded cfg", book && book.path, { basic: cfg.basic, stats: cfg.stats });
      } catch (e) {
      }
      const stats = cfg.stats || {};
      if (!stats)
        return;
      const pad = (n) => typeof n === "number" ? n : 0;
      const formatTarget = (n) => {
        if (!n)
          return "\u2014";
        const num = Number(n) || 0;
        if (num >= 1e3) {
          const k = num / 1e3;
          return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
        }
        return String(num);
      };
      const todayKey = new Date().toISOString().slice(0, 10);
      const dailyWords = stats.daily_words || {};
      const todayCount = pad(dailyWords[todayKey]) || 0;
      const totalWords = pad(stats.total_words) || 0;
      const targetWords = pad(stats.target_total_words) || 0;
      const completionPct = typeof stats.progress_by_words !== "undefined" && stats.progress_by_words !== null ? Number(stats.progress_by_words) : targetWords > 0 ? Math.round(totalWords / targetWords * 1e4) / 100 : 0;
      const writingDays = typeof stats.writing_days === "number" ? stats.writing_days : stats.daily_words ? Object.keys(stats.daily_words).length : 0;
      const dailyAvg = typeof stats.average_daily_words === "number" ? stats.average_daily_words : writingDays > 0 ? Math.round(totalWords / writingDays) : 0;
      container.empty();
      const row = (iconName, label, value, extra) => {
        const r = container.createDiv("novelist-stat-row");
        const left = r.createDiv({ cls: "novelist-stat-left" });
        const iconSpan = left.createSpan({ cls: "novelist-stat-icon" });
        try {
          if (Array.isArray(iconName)) {
            iconName.forEach((n, i) => {
              const s = iconSpan.createSpan({ cls: `novelist-stat-icon-part part-${i}` });
              try {
                (0, import_obsidian3.setIcon)(s, n);
              } catch (e) {
              }
            });
          } else {
            try {
              (0, import_obsidian3.setIcon)(iconSpan, iconName);
            } catch (e) {
            }
          }
        } catch (e) {
        }
        left.createSpan({ text: label, cls: "novelist-stat-label" });
        r.createSpan({ text: value, cls: "novelist-stat-value" });
        if (extra && typeof extra === "function")
          extra(r);
      };
      row("pencil", "Today", `${todayCount} words`);
      row("file", "Total words", `${totalWords} / ${formatTarget(targetWords)}`);
      row("target", "Completion", `${(Math.round(completionPct * 100) / 100).toFixed(2)}%`);
      row("clock", "Writing days", `${writingDays} days`);
      row("calendar-clock", "Daily average", `${dailyAvg} words`);
    } catch (e) {
      console.warn("renderStats failed", e);
    }
  }
  async render() {
    const { NewBookModal: NewBookModal2 } = await Promise.resolve().then(() => (init_newBookModal(), newBookModal_exports));
    const { SwitchBookModal: SwitchBookModal2 } = await Promise.resolve().then(() => (init_switchBookModal(), switchBookModal_exports));
    const { ManageBooksModal: ManageBooksModal2 } = await Promise.resolve().then(() => (init_manageBooksModal(), manageBooksModal_exports));
    const { HelpModal: HelpModal2 } = await Promise.resolve().then(() => (init_helpModal(), helpModal_exports));
    const { TextInputModal: TextInputModal2 } = await Promise.resolve().then(() => (init_textInputModal(), textInputModal_exports));
    const token = ++this._renderCounter;
    this._isRendering = true;
    try {
      const el = this.contentEl;
      el.empty();
      if (this._renderCounter !== token)
        return;
      el.addClass("novelist-view");
      const topBar = el.createDiv("novelist-topbar");
      const newBtn = topBar.createEl("button", { cls: "novelist-top-btn" });
      const newIcon = newBtn.createSpan({ cls: "novelist-top-icon" });
      try {
        (0, import_obsidian3.setIcon)(newIcon, "edit");
      } catch (e) {
      }
      newBtn.createSpan({ text: "New", cls: "novelist-top-label" });
      const switchBtn = topBar.createEl("button", { cls: "novelist-top-btn" });
      const switchIcon = switchBtn.createSpan({ cls: "novelist-top-icon" });
      try {
        (0, import_obsidian3.setIcon)(switchIcon, "repeat");
      } catch (e) {
      }
      switchBtn.createSpan({ text: "Switch", cls: "novelist-top-label" });
      const manageBtn = topBar.createEl("button", { cls: "novelist-top-btn" });
      const manageIcon = manageBtn.createSpan({ cls: "novelist-top-icon" });
      try {
        (0, import_obsidian3.setIcon)(manageIcon, "library");
      } catch (e) {
      }
      manageBtn.createSpan({ text: "Manage", cls: "novelist-top-label" });
      const helpBtn = topBar.createEl("button", { cls: "novelist-help-btn" });
      const helpIcon = helpBtn.createSpan({ cls: "novelist-help-icon" });
      try {
        (0, import_obsidian3.setIcon)(helpIcon, "help");
      } catch (e) {
      }
      newBtn.onclick = () => {
        new NewBookModal2(this.plugin).open();
      };
      switchBtn.onclick = () => {
        new SwitchBookModal2(this.plugin).open();
      };
      manageBtn.onclick = () => {
        new ManageBooksModal2(this.plugin).open();
      };
      helpBtn.onclick = () => {
        new HelpModal2(this.plugin).open();
      };
      const book = this.plugin.activeBook;
      if (!book) {
        const headerEl2 = el.createDiv("novelist-book-header");
        const coverCol2 = headerEl2.createDiv("novelist-book-cover-col");
        const coverEl2 = coverCol2.createDiv("novelist-book-cover");
        coverEl2.style.background = "linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))";
        try {
          coverEl2.addClass && coverEl2.addClass("novelist-book-cover-placeholder");
        } catch (e) {
        }
        const titleBlock2 = headerEl2.createDiv("novelist-book-title-block");
        titleBlock2.createEl("div", { cls: "novelist-book-title", text: "No active book" });
        titleBlock2.createEl("div", { cls: "novelist-book-subtitle", text: "(Select or create a book)" });
        const metaBlock2 = el.createDiv("novelist-book-meta novelist-book-info");
        const authorRow2 = metaBlock2.createDiv("novelist-meta-row");
        authorRow2.createEl("div", { text: "Author", cls: "novelist-meta-label" });
        authorRow2.createEl("div", { text: "\u2014", cls: "novelist-meta-value" });
        const descRow2 = metaBlock2.createDiv("novelist-meta-row");
        descRow2.createEl("div", { text: "Description", cls: "novelist-meta-label" });
        descRow2.createEl("div", { text: "\u2014", cls: "novelist-meta-value novelist-meta-desc" });
        const structureEl2 = el.createDiv("novelist-structure");
        structureEl2.createEl("p", { text: "(No book selected)" });
        try {
          const statsEl = el.createDiv("novelist-stats");
          const makeRow = (label, value) => {
            const r = statsEl.createDiv("novelist-stat-row");
            const left = r.createDiv({ cls: "novelist-stat-left" });
            left.createSpan({ cls: "novelist-stat-icon" });
            left.createSpan({ text: label, cls: "novelist-stat-label" });
            r.createSpan({ text: value, cls: "novelist-stat-value" });
          };
          makeRow("Today", "\u2014");
          makeRow("Total words", "\u2014 / \u2014");
          makeRow("Completion", "\u2014");
          makeRow("Writing days", "\u2014");
          makeRow("Daily average", "\u2014");
        } catch (e) {
        }
        return;
      }
      const bookFolderCheck = this.plugin.app.vault.getAbstractFileByPath(book.path);
      if (!bookFolderCheck || !(bookFolderCheck instanceof import_obsidian3.TFolder)) {
        const headerEl2 = el.createDiv("novelist-book-header");
        const coverCol2 = headerEl2.createDiv("novelist-book-cover-col");
        const coverEl2 = coverCol2.createDiv("novelist-book-cover");
        coverEl2.style.background = "linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01))";
        try {
          coverEl2.addClass && coverEl2.addClass("novelist-book-cover-placeholder");
        } catch (e) {
        }
        const titleBlock2 = headerEl2.createDiv("novelist-book-title-block");
        titleBlock2.createEl("div", { cls: "novelist-book-title", text: "No active book" });
        titleBlock2.createEl("div", { cls: "novelist-book-subtitle", text: "(Book folder missing)" });
        const metaBlock2 = el.createDiv("novelist-book-meta novelist-book-info");
        const authorRow2 = metaBlock2.createDiv("novelist-meta-row");
        authorRow2.createEl("div", { text: "Author", cls: "novelist-meta-label" });
        authorRow2.createEl("div", { text: "\u2014", cls: "novelist-meta-value" });
        const descRow2 = metaBlock2.createDiv("novelist-meta-row");
        descRow2.createEl("div", { text: "Description", cls: "novelist-meta-label" });
        descRow2.createEl("div", { text: "\u2014", cls: "novelist-meta-value novelist-meta-desc" });
        const structureEl2 = el.createDiv("novelist-structure");
        structureEl2.createEl("p", { text: "(Book folder missing on disk)" });
        try {
          const statsEl = el.createDiv("novelist-stats");
          const makeRow = (label, value) => {
            const r = statsEl.createDiv("novelist-stat-row");
            const left = r.createDiv({ cls: "novelist-stat-left" });
            left.createSpan({ cls: "novelist-stat-icon" });
            left.createSpan({ text: label, cls: "novelist-stat-label" });
            r.createSpan({ text: value, cls: "novelist-stat-value" });
          };
          makeRow("Today", "\u2014");
          makeRow("Total words", "\u2014 / \u2014");
          makeRow("Completion", "\u2014");
          makeRow("Writing days", "\u2014");
          makeRow("Daily average", "\u2014");
        } catch (e) {
        }
        return;
      }
      let metadata = {};
      try {
        if (this.plugin.loadBookMeta)
          metadata = await this.plugin.loadBookMeta(book) || {};
      } catch (e) {
        metadata = {};
      }
      if (this._renderCounter !== token)
        return;
      const headerEl = el.createDiv("novelist-book-header");
      const coverCol = headerEl.createDiv("novelist-book-cover-col");
      const coverEl = coverCol.createDiv("novelist-book-cover");
      const coverPath = book.cover ? this.plugin.app.vault.getResourcePath(book.cover) : null;
      if (coverPath) {
        coverEl.style.backgroundImage = `url("${coverPath}")`;
      }
      const titleBlock = headerEl.createDiv("novelist-book-title-block");
      titleBlock.createEl("div", {
        cls: "novelist-book-title",
        text: metadata && metadata.title || book.name || "Untitled book"
      });
      const subtitleText = metadata && metadata.subtitle || "";
      if (subtitleText) {
        titleBlock.createEl("div", {
          cls: "novelist-book-subtitle",
          text: subtitleText
        });
      }
      const metaBlock = el.createDiv("novelist-book-meta novelist-book-info");
      const authorVal = metadata && metadata.author || "";
      const descVal = metadata && metadata.description || "";
      const authorRow = metaBlock.createDiv("novelist-meta-row");
      authorRow.createEl("div", { text: "Author", cls: "novelist-meta-label" });
      authorRow.createEl("div", { text: authorVal || "\u2014", cls: "novelist-meta-value" });
      const descRow = metaBlock.createDiv("novelist-meta-row");
      descRow.createEl("div", { text: "Description", cls: "novelist-meta-label" });
      descRow.createEl("div", { text: descVal || "\u2014", cls: "novelist-meta-value novelist-meta-desc" });
      if (this._renderCounter !== token)
        return;
      const structureEl = el.createDiv("novelist-structure");
      const bookFolder = this.plugin.app.vault.getAbstractFileByPath(book.path);
      if (this._renderCounter !== token)
        return;
      if (bookFolder instanceof import_obsidian3.TFolder) {
        await this.renderBookTree(structureEl, bookFolder);
      } else {
        structureEl.createEl("p", { text: "(No folder found on disk)" });
      }
      try {
        structureEl.addEventListener("contextmenu", (evt) => {
          try {
            const item = evt.target && evt.target.closest && evt.target.closest(".tree-item");
            if (item)
              return;
            evt.preventDefault();
            const menu = new import_obsidian3.Menu(this.plugin.app);
            menu.addItem(
              (it) => it.setTitle("New root canvas").setIcon("layout-dashboard").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New root canvas",
                  placeholder: "Canvas name (without .canvas)",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const raw = (value || "").trim();
                      if (!raw)
                        return;
                      const base = raw.endsWith(".canvas") ? raw.slice(0, -7) : raw;
                      let name = `${base}.canvas`;
                      let i = 1;
                      while (this.plugin.app.vault.getAbstractFileByPath(`${book.path}/${name}`)) {
                        name = `${base} ${i}.canvas`;
                        i += 1;
                      }
                      await this.plugin.app.vault.create(`${book.path}/${name}`, "");
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.addItem(
              (it) => it.setTitle("New root file").setIcon("file-plus").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New root file",
                  placeholder: "File name (without .md)",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const name = (value || "").trim();
                      if (!name)
                        return;
                      const fileName = name.endsWith(".md") ? name : `${name}.md`;
                      const path = `${book.path}/${fileName}`;
                      if (!this.plugin.app.vault.getAbstractFileByPath(path)) {
                        await this.plugin.app.vault.create(path, "");
                      }
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.addItem(
              (it) => it.setTitle("New volume").setIcon("folder-plus").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New volume",
                  placeholder: "Volume name",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const name = (value || "").trim();
                      if (!name)
                        return;
                      await this.plugin.createVolume(book, name);
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.showAtMouseEvent(evt);
          } catch (e) {
            console.error(e);
          }
        });
      } catch (e) {
      }
      if (this._renderCounter !== token)
        return;
      this.statsEl = el.createDiv("novelist-stats");
      await this.renderStats(this.statsEl, book);
      try {
        if (this.statsEl)
          this.statsEl.addEventListener("contextmenu", (evt) => {
            try {
              evt.preventDefault();
              const row = evt.target && evt.target.closest && evt.target.closest(".novelist-stat-row");
              if (row)
                return;
              const menu = new import_obsidian3.Menu(this.plugin.app);
              menu.addItem(
                (it) => it.setTitle("New root canvas").setIcon("layout-dashboard").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New root canvas",
                    placeholder: "Canvas name (without .canvas)",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const raw = (value || "").trim();
                        if (!raw)
                          return;
                        const base = raw.endsWith(".canvas") ? raw.slice(0, -7) : raw;
                        let name = `${base}.canvas`;
                        let i = 1;
                        while (this.plugin.app.vault.getAbstractFileByPath(`${book.path}/${name}`)) {
                          name = `${base} ${i}.canvas`;
                          i += 1;
                        }
                        await this.plugin.app.vault.create(`${book.path}/${name}`, "");
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.addItem(
                (it) => it.setTitle("New root file").setIcon("file-plus").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New root file",
                    placeholder: "File name (without .md)",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const name = (value || "").trim();
                        if (!name)
                          return;
                        const fileName = name.endsWith(".md") ? name : `${name}.md`;
                        const path = `${book.path}/${fileName}`;
                        if (!this.plugin.app.vault.getAbstractFileByPath(path)) {
                          await this.plugin.app.vault.create(path, "");
                        }
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.addItem(
                (it) => it.setTitle("New volume").setIcon("folder-plus").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New volume",
                    placeholder: "Volume name",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const name = (value || "").trim();
                        if (!name)
                          return;
                        await this.plugin.createVolume(book, name);
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.showAtMouseEvent(evt);
            } catch (e) {
              console.error(e);
            }
          });
      } catch (e) {
      }
    } finally {
      if (this._renderCounter === token) {
        this._isRendering = false;
      }
    }
  }
};

// src/views/novelistSettingTab.js
var import_obsidian4 = require("obsidian");
var NovelistSettingTab = class extends import_obsidian4.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const el = this.containerEl;
    el.empty();
    el.createEl("h2", { text: "Novelist Settings" });
    new import_obsidian4.Setting(el).setName("Books base path").setDesc("Folder where all books are stored").addText(
      (text) => text.setValue(this.plugin.settings.basePath).onChange(async (value) => {
        this.plugin.settings.basePath = value.trim() || "projects";
        await this.plugin.saveSettings();
        await this.plugin.refresh();
      })
    );
  }
};

// src/main.js
init_newBookModal();
init_switchBookModal();
init_manageBooksModal();
init_editBookModal();
init_helpModal();
init_textInputModal();
init_confirmModal();
var {
  Plugin,
  PluginSettingTab: PluginSettingTab2,
  Setting: Setting2,
  ItemView: ItemView2,
  TFile: TFile6,
  TFolder: TFolder4,
  Modal: Modal8,
  Menu: Menu2,
  setIcon: setIcon2
} = require("obsidian");
module.exports = class NovelistPlugin extends Plugin {
  async onload() {
    await this.loadSettings();
    this.configService = new ConfigService(this.app);
    this.treeService = new TreeService(this.app, this.configService);
    this.statsService = new StatsService(this.app, this.configService);
    this.bookService = new BookService(this.app, this.configService);
    this.booksIndex = [];
    this.activeBook = null;
    this.novelistLeaf = null;
    this.activeFile = null;
    await this.ensureBasePath();
    await this.scanBooks();
    try {
      if (this.settings && this.settings.lastActiveBookPath) {
        const byPath = this.booksIndex.find((b) => b.path === this.settings.lastActiveBookPath);
        if (byPath)
          this.activeBook = byPath;
      }
    } catch (e) {
    }
    this.expandedFolders = /* @__PURE__ */ new Set();
    this.activeFilePath = null;
    this.registerView(
      VIEW_TYPE,
      (leaf) => new NovelistView(leaf, this)
    );
    this.addRibbonIcon("book-open", "Open Novelist", () => {
      this.activateView();
    });
    this.addSettingTab(new NovelistSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("create", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("delete", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("rename", async () => {
        var _a;
        const activePath = (_a = this.activeBook) == null ? void 0 : _a.path;
        await this.refresh();
        if (activePath) {
          const book = this.booksIndex.find((b) => b.path === activePath);
          if (book) {
            this.activeBook = book;
            try {
              await this.syncChapterStatsBaseline(book);
            } catch (e) {
              console.warn("syncChapterStatsBaseline (rename) failed", e);
            }
          }
        }
      })
    );
    this._statsDebounceTimers = {};
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        try {
          this.onFileModified(file);
        } catch (e) {
          console.warn("onFileModified handler failed", e);
        }
      })
    );
    try {
      this.registerEvent(
        this.app.workspace.on("editor-change", (editor, view) => {
          try {
            const f = view == null ? void 0 : view.file;
            if (f)
              this.onFileModified(f);
          } catch (e) {
            console.warn("editor-change handler failed", e);
          }
        })
      );
    } catch (e) {
    }
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        const af = this.app.workspace.getActiveFile();
        this.activeFilePath = af ? af.path : null;
        try {
          this.updateActiveFileInViews();
        } catch (e) {
          this.rerenderViews();
        }
      })
    );
  }
  // Minimal chapter context menu (Open in new tab/pane, Mark complete, Exclude, Create copy, Rename, Delete)
  openChapterContextMenu(evt, file) {
    var _a;
    try {
      (_a = evt.preventDefault) == null ? void 0 : _a.call(evt);
      const menu = new Menu2(this.app);
      menu.addItem(
        (it) => it.setTitle("Open in new tab").setIcon("file").onClick(() => {
          (async () => {
            try {
              const leaf = this.app.workspace.getLeaf("tab");
              if (leaf && typeof leaf.openFile === "function") {
                await leaf.openFile(file);
              }
            } catch (e) {
              try {
                const leaf = this.app.workspace.getLeaf(true);
                if (leaf && typeof leaf.openFile === "function")
                  await leaf.openFile(file);
              } catch (e2) {
                console.warn(e2);
              }
            }
          })();
        })
      );
      menu.addItem(
        (it) => it.setTitle("Open in new pane").setIcon("split").onClick(() => {
          (async () => {
            try {
              const leaf = this.app.workspace.getLeaf("split");
              if (leaf && typeof leaf.openFile === "function") {
                await leaf.openFile(file);
              }
            } catch (e) {
              try {
                const leaf = this.app.workspace.getLeaf(true);
                if (leaf && typeof leaf.openFile === "function")
                  await leaf.openFile(file);
              } catch (e2) {
                console.warn(e2);
              }
            }
          })();
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle("Mark as complete").setIcon("check").onClick(() => {
          this.markChapterComplete(file);
        })
      );
      menu.addItem(
        (it) => it.setTitle("Exclude from stats").setIcon("eye-off").onClick(() => {
          this.excludeFromStats(file);
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle("Create copy").setIcon("copy").onClick(() => {
          try {
            this.app.fileManager.duplicateFile(file);
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Rename").setIcon("pencil").onClick(() => {
          try {
            this.app.fileManager.promptForFileRename(file);
          } catch (e) {
            console.warn(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Delete").setIcon("trash").onClick(async () => {
          try {
            await this.app.vault.delete(file, file instanceof TFolder4);
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.showAtMouseEvent(evt);
    } catch (e) {
      console.error(e);
    }
  }
  openVolumeMenu(evt, folder, isRoot = false) {
    var _a;
    try {
      (_a = evt.preventDefault) == null ? void 0 : _a.call(evt);
      const menu = new Menu2(this.app);
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New root canvas" : "New canvas").setIcon("layout-dashboard").onClick(async () => {
          try {
            const folderObj = folder instanceof TFolder4 ? folder : this.app.vault.getAbstractFileByPath((folder == null ? void 0 : folder.path) || folder);
            if (!(folderObj instanceof TFolder4))
              return;
            let base = "Canvas";
            let name = `${base}.canvas`;
            let i = 1;
            while (this.app.vault.getAbstractFileByPath(`${folderObj.path}/${name}`)) {
              i += 1;
              name = `${base} ${i}.canvas`;
            }
            await this.app.vault.create(`${folderObj.path}/${name}`, "");
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New root file" : "New file").setIcon("file-plus").onClick(async () => {
          try {
            await this.createNextChapterFile(folder);
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New volume" : "New folder").setIcon("folder-plus").onClick(() => {
          const modal = new TextInputModal(this.app, {
            title: "New folder",
            placeholder: "Folder name",
            cta: "Create",
            onSubmit: async (value) => {
              const name = (value || "").trim();
              if (!name)
                return;
              try {
                const dest = `${folder.path}/${name}`;
                if (!this.app.vault.getAbstractFileByPath(dest)) {
                  await this.app.vault.createFolder(dest);
                }
                await this.refresh();
                this.rerenderViews();
              } catch (e) {
                console.error(e);
              }
            }
          });
          modal.open();
        })
      );
      menu.addItem(
        (it) => it.setTitle("Create copy").setIcon("copy").onClick(() => {
          try {
            this.createCopy(folder.path);
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle("Rename").setIcon("pencil").onClick(() => {
          try {
            this.app.fileManager.promptForFileRename(folder);
          } catch (e) {
            console.warn(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Delete").setIcon("trash").onClick(async () => {
          try {
            await this.app.vault.delete(folder, folder instanceof TFolder4);
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.showAtMouseEvent(evt);
    } catch (e) {
      console.error(e);
    }
  }
  // Helper: open a file in the current leaf
  openFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      this.app.workspace.openLinkText(file.path, "", false);
    }
  }
  // Helper: open file in a new tab (open in new leaf)
  openFileInNewTab(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      try {
        this.app.workspace.openLinkText(file.path, "", true);
      } catch (e) {
        const leaf = this.app.workspace.getLeaf(true);
        leaf.openFile(file);
      }
    }
  }
  // Helper: open file in a new split/pane
  openFileInNewPane(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      try {
        const leaf = this.app.workspace.getLeaf(true);
        leaf.openFile(file);
      } catch (e) {
        console.warn(e);
      }
    }
  }
  renamePath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file) {
      try {
        this.app.fileManager.promptForFileRename(file);
      } catch (e) {
        console.warn(e);
      }
    }
  }
  async deletePath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file)
      return;
    try {
      await this.app.vault.delete(file, file instanceof TFolder4);
      await this.refresh();
      this.rerenderViews();
    } catch (e) {
      console.error(e);
    }
  }
  createCopy(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file)
      return;
    try {
      if (file instanceof TFile6) {
        this.app.fileManager.duplicateFile(file);
      } else if (file instanceof TFolder4) {
        const parentPath = file.path.split("/").slice(0, -1).join("/") || "";
        const baseName = `${file.name} Copy`;
        let destPath = `${parentPath}/${baseName}`.replace(/\/+/g, "/");
        let i = 1;
        while (this.app.vault.getAbstractFileByPath(destPath)) {
          destPath = `${parentPath}/${baseName} ${i}`;
          i++;
        }
        const createFolderAndCopy = async (src, dest) => {
          await this.app.vault.createFolder(dest);
          const folder = this.app.vault.getAbstractFileByPath(src);
          if (!(folder instanceof TFolder4))
            return;
          for (const child of folder.children) {
            const childDest = `${dest}/${child.name}`;
            if (child instanceof TFile6) {
              const content = await this.app.vault.read(child);
              await this.app.vault.create(childDest, content);
            } else if (child instanceof TFolder4) {
              await createFolderAndCopy(child.path, childDest);
            }
          }
        };
        createFolderAndCopy(file.path, destPath).then(async () => {
          await this.refresh();
          this.rerenderViews();
        });
      }
    } catch (e) {
      console.error(e);
    }
  }
  async createNextChapterFile(folder) {
    var _a;
    try {
      const folderObj = folder instanceof TFolder4 ? folder : this.app.vault.getAbstractFileByPath((folder == null ? void 0 : folder.path) || folder);
      if (!(folderObj instanceof TFolder4))
        return;
      const existing = ((_a = folderObj.children) != null ? _a : []).filter((c) => c instanceof TFile6 && c.extension === "md").map((f) => f.basename);
      let max = 0;
      for (const name of existing) {
        const match = name.match(/^Chapter (\d+)$/i);
        if (match) {
          const n = parseInt(match[1], 10);
          if (!isNaN(n))
            max = Math.max(max, n);
        }
      }
      const next = max + 1;
      const fileName = `Chapter ${next}.md`;
      const path = `${folderObj.path}/${fileName}`;
      if (this.app.vault.getAbstractFileByPath(path))
        return;
      await this.app.vault.create(path, "");
      try {
        const book = this.booksIndex.find((b) => path.startsWith(b.path));
        if (book)
          await this.syncChapterStatsBaseline(book);
      } catch (e) {
        console.warn("syncChapterStatsBaseline (createNextChapterFile) failed", e);
      }
    } catch (e) {
      console.error(e);
    }
  }
  // Helper: create sub-volume (folder) under a given folder path via modal
  createSubVolume(parentFolderPath) {
    const modal = new TextInputModal(this.app, {
      title: "New folder",
      placeholder: "Folder name",
      cta: "Create",
      onSubmit: async (value) => {
        if (!value)
          return;
        const folderObj = { path: parentFolderPath };
        await this.createVolume(folderObj, value);
        await this.refresh();
        this.rerenderViews();
      }
    });
    modal.open();
  }
  /* Reusable activator: always reuse the same leaf (singleton view) */
  async activateView() {
    if (this.novelistLeaf) {
      try {
        this.app.workspace.revealLeaf(this.novelistLeaf);
        return;
      } catch (e) {
        this.novelistLeaf = null;
      }
    }
    const leaf = this.app.workspace.getLeaf(false);
    await leaf.setViewState({
      type: VIEW_TYPE,
      active: true
    });
    this.novelistLeaf = leaf;
  }
  async refresh() {
    await this.scanBooks();
    this.rerenderViews();
  }
  async ensureBasePath() {
    const base = this.settings.basePath || "projects";
    if (!await this.app.vault.adapter.exists(base)) {
      await this.app.vault.createFolder(base);
    }
  }
  /* ===============================================================
   * SCAN BOOKS (filesystem source of truth)
   * =============================================================== */
  async scanBooks() {
    var _a, _b;
    const basePath = this.settings.basePath || "projects";
    this.booksIndex = await this.bookService.scanBooks(basePath);
    if (!this.activeBook && this.booksIndex.length > 0) {
      this.activeBook = this.booksIndex[0];
    }
    this.activeBook = (_b = (_a = this.booksIndex.find(
      (b) => {
        var _a2;
        return b.path === ((_a2 = this.activeBook) == null ? void 0 : _a2.path);
      }
    )) != null ? _a : this.booksIndex[0]) != null ? _b : null;
  }
  /* ===============================================================
   * CREATE METHODS
   * =============================================================== */
  async createBook(name) {
    const basePath = this.settings.basePath || "projects";
    return this.bookService.createBook(basePath, name);
  }
  async ensureBookBaseStructure(bookFolder) {
    return this.bookService.ensureBookBaseStructure(bookFolder);
  }
  async createVolume(book, name) {
    return this.bookService.createVolume(book, name);
  }
  async createChapter(volume, name) {
    const result = await this.bookService.createChapter(volume, name);
    try {
      const book = this.booksIndex.find((b) => `${volume.path}/${name}.md`.startsWith(b.path));
      if (book)
        await this.syncChapterStatsBaseline(book);
    } catch (e) {
      console.warn("syncChapterStatsBaseline (createChapter) failed", e);
    }
    return result;
  }
  /* Helpers for native file-menu integration */
  isVolumeFolder(file) {
    try {
      return this.booksIndex.some(
        (b) => b.volumes.some((v) => v.path === file.path)
      );
    } catch (e) {
      return false;
    }
  }
  isChapterFile(file) {
    try {
      return this.booksIndex.some(
        (b) => b.volumes.some(
          (v) => v.chapters.some((c) => c.path === file.path)
        )
      );
    } catch (e) {
      return false;
    }
  }
  async deleteVolume(folder) {
    const af = this.app.vault.getAbstractFileByPath(folder.path) || folder;
    await this.app.vault.delete(af, true);
    await this.refresh();
  }
  async deleteChapter(file) {
    const af = this.app.vault.getAbstractFileByPath(file.path) || file;
    await this.app.vault.delete(af);
    await this.refresh();
    try {
      const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
      if (book)
        await this.syncChapterStatsBaseline(book);
    } catch (e) {
      console.warn("syncChapterStatsBaseline (deleteChapter) failed", e);
    }
  }
  // Delete a folder and all its children recursively using Vault API
  async deleteFolderRecursive(path) {
    try {
      const af = this.app.vault.getAbstractFileByPath(path);
      if (!af)
        return;
      if (af instanceof TFile6) {
        await this.app.vault.delete(af);
        return;
      }
      try {
        if (typeof this.app.vault.delete === "function") {
          await this.app.vault.delete(af, true);
          return;
        }
      } catch (e) {
        console.warn("vault.delete recursive attempt failed, falling back", e);
      }
      if (af.children && af.children.length > 0) {
        const children = Array.from(af.children);
        for (const c of children) {
          if (c instanceof TFile6) {
            try {
              await this.app.vault.delete(c);
            } catch (e) {
              console.warn("delete child file failed", c.path, e);
            }
          } else {
            await this.deleteFolderRecursive(c.path);
          }
        }
      }
      try {
        await this.app.vault.delete(af);
      } catch (e) {
        try {
          if (this.app.vault.adapter && typeof this.app.vault.adapter.rmdir === "function") {
            await this.app.vault.adapter.rmdir(path);
          }
        } catch (e2) {
          console.warn("deleteFolderRecursive: failed to remove folder", path, e2);
        }
      }
      try {
        const maxRetries = 20;
        let retries = maxRetries;
        while (retries-- > 0) {
          const test = this.plugin ? this.app.vault.getAbstractFileByPath(path) : this.app.vault.getAbstractFileByPath(path);
          if (!test)
            break;
          await new Promise((r) => setTimeout(r, 100));
        }
      } catch (e) {
      }
    } catch (e) {
      console.warn("deleteFolderRecursive failed", path, e);
    }
  }
  async markChapterComplete(file) {
    await this.treeService.markChapterComplete(file);
    await this.refresh();
  }
  async excludeFromStats(file) {
    await this.treeService.excludeFromStats(file);
    await this.refresh();
  }
  async loadSettings() {
    this.settings = Object.assign(
      {},
      DEFAULT_SETTINGS,
      await this.loadData()
    );
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Delegate to ConfigService
  async loadBookConfig(book) {
    return this.configService.loadBookConfig(book);
  }
  // Delegate to ConfigService
  async saveBookConfig(book, config) {
    return this.configService.saveBookConfig(book, config);
  }
  // Delegate to ConfigService
  async loadBookMeta(book) {
    return this.configService.loadBookMeta(book);
  }
  async waitForFolderSync(path, retries = 20) {
    const delay = (ms) => new Promise((r) => setTimeout(r, ms));
    while (retries-- > 0) {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (folder && folder.children && folder.children.length > 0)
        return;
      await delay(50);
    }
  }
  rerenderViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      try {
        if (view && typeof view.render === "function") {
          view.render();
        }
      } catch (e) {
        console.warn("render failed", e);
      }
    }
  }
  updateActiveFileInViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      try {
        if (!view || !view.contentEl)
          continue;
        const root = view.contentEl;
        const items = root.querySelectorAll(".tree-item");
        items.forEach((el) => {
          try {
            const p = el.getAttribute("data-path");
            if (p && p === this.activeFilePath)
              el.classList.add("is-active");
            else
              el.classList.remove("is-active");
          } catch (e) {
          }
        });
      } catch (e) {
        console.warn("updateActiveFileInViews failed", e);
      }
    }
  }
  // Update only the stats block in existing Novelist views to avoid full re-renders
  async updateStatsInViews(book) {
    try {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
      for (const leaf of leaves) {
        const view = leaf.view;
        try {
          if (!view || !view.statsEl)
            continue;
          if (!book || !view.plugin || !view.plugin.activeBook)
            continue;
          if (view.plugin.activeBook.path !== book.path)
            continue;
          if (typeof view.renderStats === "function") {
            await view.renderStats(view.statsEl, book);
          }
        } catch (e) {
        }
      }
    } catch (e) {
      console.warn("updateStatsInViews failed", e);
    }
  }
  // Handle modified files  debounce per-book to avoid excessive work
  async onFileModified(file) {
    try {
      if (!file || !file.path)
        return;
      if (file.extension !== "md" && !file.path.endsWith(".md"))
        return;
      const book = this.booksIndex.find((b) => file.path === b.path || file.path.startsWith(b.path + "/"));
      if (!book)
        return;
      const key = book.path;
      if (this._statsDebounceTimers[key])
        clearTimeout(this._statsDebounceTimers[key]);
      this._statsDebounceTimers[key] = setTimeout(() => {
        this.computeAndSaveStatsForBook(book).catch((e) => console.warn("computeAndSaveStatsForBook failed", e));
        delete this._statsDebounceTimers[key];
      }, 400);
    } catch (e) {
      console.warn("onFileModified error", e);
    }
  }
  // Walk folder recursively to collect markdown TFile objects
  _collectMarkdownFiles(folder) {
    const out = [];
    if (!folder || !folder.children)
      return out;
    for (const c of folder.children) {
      if (c instanceof TFile6 && c.name && c.name.toLowerCase().endsWith(".md"))
        out.push(c);
      else if (c.children) {
        out.push(...this._collectMarkdownFiles(c));
      }
    }
    return out;
  }
  // Count words in text
  _countWords(text) {
    if (!text)
      return 0;
    const parts = text.replace(/\n/g, " ").split(/\s+/).filter(Boolean);
    return parts.length;
  }
  _getTodayKey() {
    return new Date().toISOString().slice(0, 10);
  }
  // Delegate to StatsService
  async computeAndSaveStatsForBook(book) {
    const stats = await this.statsService.computeAndSaveStatsForBook(book);
    if (stats) {
      await this.updateStatsInViews(book);
    }
    return stats;
  }
  // Delegate to StatsService
  async syncChapterStatsBaseline(book) {
    return this.statsService.syncChapterStatsBaseline(book);
  }
  /* ===============================================================
   * TREE MANAGEMENT HELPERS (Book-Smith pattern)
   * =============================================================== */
  // Generate unique node ID
  generateNodeId() {
    return `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  async buildTreeFromFilesystem(bookFolder) {
    return this.treeService.buildTreeFromFilesystem(bookFolder);
  }
  async reorderTreeNodes(book, draggedNodeId, targetNodeId, position) {
    return this.treeService.reorderTreeNodes(book, draggedNodeId, targetNodeId, position);
  }
};
