/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// src/constants/index.js
var VIEW_TYPE, WRITER_TOOLS_VIEW_TYPE, PROJECT_TYPES, DEFAULT_SETTINGS, DEFAULT_BOOK_CONFIG;
var init_constants = __esm({
  "src/constants/index.js"() {
    VIEW_TYPE = "folio-view";
    WRITER_TOOLS_VIEW_TYPE = "folio-writer-tools";
    PROJECT_TYPES = {
      BOOK: "book",
      SCRIPT: "script",
      FILM: "film",
      ESSAY: "essay"
    };
    DEFAULT_SETTINGS = {
      booksPath: "projects",
      basePath: "projects",
      // Legacy compatibility
      lastActiveBookPath: null,
      verboseLogs: false,
      defaultAuthor: "",
      defaultProjectType: "book",
      projectTemplates: [
        {
          id: "book",
          name: "Book",
          icon: "book",
          order: 1,
          description: "Novel or written work",
          structure: [
            { title: "Moodboard", type: "canvas", icon: "layout-dashboard" },
            { title: "Preface", type: "file", icon: "file" },
            { title: "Outline", type: "file", icon: "list" },
            { title: "Volume 1", type: "folder", icon: "folder-open", children: [
              { title: "Chapter 1", type: "file", icon: "file" }
            ] },
            { title: "Afterword", type: "file", icon: "file" }
          ]
        },
        {
          id: "script",
          name: "TV Show",
          icon: "tv",
          order: 2,
          description: "Series with episodes and sequences",
          structure: [
            {
              title: "Show Dossier",
              type: "folder",
              icon: "folder-open",
              children: [
                { title: "Concept", type: "folder", icon: "lightbulb", children: [
                  { title: "Logline", type: "file", icon: "file" },
                  { title: "Synopsis", type: "file", icon: "file" }
                ] },
                { title: "Structure", type: "folder", icon: "list-tree", children: [
                  { title: "Beat Sheet", type: "file", icon: "file" }
                ] },
                { title: "Faces", type: "folder", icon: "users", children: [
                  { title: "Character 1", type: "file", icon: "file" }
                ] },
                { title: "Places", type: "folder", icon: "map-pin", children: [
                  { title: "Location 1", type: "file", icon: "file" }
                ] },
                { title: "Objects", type: "folder", icon: "box", children: [
                  { title: "Prop 1", type: "file", icon: "file" }
                ] },
                { title: "Documentation", type: "folder", icon: "archive", children: [
                  { title: "Research", type: "file", icon: "file" }
                ] }
              ]
            },
            { title: "Episode 1", type: "folder", icon: "clapperboard", children: [
              { title: "Scene 1", type: "file", icon: "file" }
            ] }
          ]
        },
        {
          id: "film",
          name: "Film",
          icon: "clapperboard",
          order: 3,
          description: "Feature film or short",
          structure: [
            { title: "Moodboard", type: "canvas", icon: "layout-dashboard" },
            { title: "Outline", type: "file", icon: "list" },
            { title: "Sequence 1", type: "folder", icon: "film", children: [
              { title: "Scene 1", type: "file", icon: "file" }
            ] }
          ]
        },
        {
          id: "essay",
          name: "Essay",
          icon: "newspaper",
          order: 4,
          description: "Essay or short nonfiction piece",
          structure: [
            {
              title: "Research",
              type: "folder",
              icon: "archive",
              children: [
                { title: "Document 1", type: "file", icon: "file" }
              ]
            },
            { title: "Outline", type: "file", icon: "list" },
            { title: "Manuscript", type: "file", icon: "scroll-text" }
          ]
        }
      ]
    };
    DEFAULT_BOOK_CONFIG = {
      basic: {
        title: "",
        author: [],
        subtitle: "",
        desc: "",
        uuid: "",
        created_at: new Date().toISOString(),
        projectType: "book"
        // Default project type
      },
      structure: {
        tree: []
      },
      stats: {
        total_words: 0,
        target_total_words: 1e4,
        progress_by_words: 0,
        progress_by_chapter: 0,
        daily_words: {},
        writing_days: 0,
        average_daily_words: 0,
        last_writing_date: new Date().toISOString(),
        last_modified: new Date().toISOString(),
        per_chapter: {}
      },
      export: {
        default_format: "pdf",
        template: "default",
        include_cover: true
      }
    };
  }
});

// src/modals/projectTypeSelectorModal.js
var import_obsidian3, ProjectTypeSelectorModal;
var init_projectTypeSelectorModal = __esm({
  "src/modals/projectTypeSelectorModal.js"() {
    import_obsidian3 = require("obsidian");
    ProjectTypeSelectorModal = class extends import_obsidian3.Modal {
      constructor(app, onSelect, templates = null) {
        super(app);
        this.onSelect = onSelect;
        this.templates = templates;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.addClass("folio-project-type-selector-modal");
        contentEl.createEl("h2", { text: "Select Project Type" });
        const optionsContainer = contentEl.createDiv({ cls: "folio-project-type-options" });
        const templates = this.templates || [
          { id: "book", name: "Book", icon: "book", order: 1, description: "Novel or written work" },
          { id: "script", name: "TV Show", icon: "tv", order: 2, description: "Series with episodes and sequences" },
          { id: "film", name: "Film", icon: "clapperboard", order: 3, description: "Feature film or short" },
          { id: "essay", name: "Essay", icon: "newspaper", order: 4, description: "Essay or short nonfiction piece" }
        ];
        templates.sort((a, b) => a.order - b.order).forEach((template) => {
          this.createProjectOption(optionsContainer, {
            title: template.name,
            description: template.description || "",
            icon: template.icon || "file",
            value: template.id
          });
        });
      }
      createProjectOption(container, { title, description, icon, value }) {
        const option = container.createDiv({ cls: "folio-project-type-option" });
        const iconEl = option.createDiv({ cls: "folio-project-type-icon" });
        (0, import_obsidian3.setIcon)(iconEl, icon);
        const content = option.createDiv({ cls: "folio-project-type-content" });
        content.createEl("div", { text: title, cls: "folio-project-type-title" });
        content.createEl("div", { text: description, cls: "folio-project-type-description" });
        option.addEventListener("click", () => {
          this.onSelect(value);
          this.close();
        });
      }
      onClose() {
        const { contentEl } = this;
        contentEl.empty();
      }
    };
  }
});

// src/modals/newBookModal.js
var newBookModal_exports = {};
__export(newBookModal_exports, {
  NewBookModal: () => NewBookModal
});
var Modal2, TFile3, NewBookModal;
var init_newBookModal = __esm({
  "src/modals/newBookModal.js"() {
    init_constants();
    init_projectTypeSelectorModal();
    ({ Modal: Modal2, TFile: TFile3 } = require("obsidian"));
    NewBookModal = class extends Modal2 {
      constructor(plugin) {
        var _a;
        super(plugin.app);
        this.plugin = plugin;
        const defaultType = (_a = plugin.settings) == null ? void 0 : _a.defaultProjectType;
        this.selectedProjectType = defaultType || null;
      }
      async onOpen() {
        var _a, _b;
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Create new project" });
        const makeDivider = () => contentEl.createDiv({ cls: "folio-modal-divider" });
        makeDivider();
        const typeRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const typeLeft = typeRow.createDiv({ cls: "folio-modal-left" });
        typeLeft.createEl("div", { text: "Project Type", cls: "folio-modal-row-title" });
        typeLeft.createEl("div", { text: "Select the type of project", cls: "folio-modal-row-sub" });
        const typeRight = typeRow.createDiv({ cls: "folio-modal-right" });
        const templates = ((_a = this.plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
        const typeNames = {};
        templates.forEach((t) => {
          const emoji = { book: "\u{1F4D8}", script: "\u{1F4FA}", film: "\u{1F3AC}", essay: "\u{1F4F0}" }[t.id] || "\u{1F4C4}";
          typeNames[t.id] = `${emoji} ${t.name}`;
        });
        if (!typeNames[PROJECT_TYPES.BOOK])
          typeNames[PROJECT_TYPES.BOOK] = "\u{1F4D8} Book";
        if (!typeNames[PROJECT_TYPES.SCRIPT])
          typeNames[PROJECT_TYPES.SCRIPT] = "\u{1F4FA} TV Show";
        if (!typeNames[PROJECT_TYPES.FILM])
          typeNames[PROJECT_TYPES.FILM] = "\u{1F3AC} Film";
        if (!typeNames[PROJECT_TYPES.ESSAY])
          typeNames[PROJECT_TYPES.ESSAY] = "\u{1F4F0} Essay";
        const typeButton = typeRight.createEl("button", { text: "Select", cls: "folio-project-type-button" });
        const updateButtonText = () => {
          typeButton.textContent = typeNames[this.selectedProjectType] || "Select type";
        };
        typeButton.onclick = () => {
          const modal = new ProjectTypeSelectorModal(this.app, (projectType) => {
            this.selectedProjectType = projectType;
            updateButtonText();
          }, templates.length > 0 ? templates : null);
          modal.open();
        };
        updateButtonText();
        makeDivider();
        const coverRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const coverLeft = coverRow.createDiv({ cls: "folio-modal-left" });
        coverLeft.createEl("div", { text: "Cover", cls: "folio-modal-row-title" });
        coverLeft.createEl("div", { text: "Select cover image (optional)", cls: "folio-modal-row-sub" });
        const coverRight = coverRow.createDiv({ cls: "folio-modal-right" });
        const coverBtn = coverRight.createEl("button", { text: "Select Image" });
        this._selectedCover = null;
        coverBtn.onclick = () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.style.display = "none";
          input.onchange = async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file)
              return;
            try {
              const reader = new FileReader();
              reader.onload = (ev) => {
                const ab = ev.target.result;
                this._selectedCover = { name: file.name, data: ab };
                coverBtn.textContent = "Select Image";
              };
              reader.readAsArrayBuffer(file);
            } catch (err) {
              console.warn("cover selection failed", err);
            }
          };
          document.body.appendChild(input);
          input.click();
          document.body.removeChild(input);
        };
        makeDivider();
        const titleRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const titleLeft = titleRow.createDiv({ cls: "folio-modal-left" });
        titleLeft.createEl("div", { text: "Title", cls: "folio-modal-row-title" });
        titleLeft.createEl("div", { text: "Please enter project title", cls: "folio-modal-row-sub" });
        const titleRight = titleRow.createDiv({ cls: "folio-modal-right" });
        const fieldWidth = "min(320px, 60%)";
        const titleInput = titleRight.createEl("input", { type: "text", placeholder: "Project title", cls: "folio-modal-input" });
        try {
          titleInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const subRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const subLeft = subRow.createDiv({ cls: "folio-modal-left" });
        subLeft.createEl("div", { text: "Subtitle", cls: "folio-modal-row-title" });
        subLeft.createEl("div", { text: "Optional", cls: "folio-modal-row-sub" });
        const subRight = subRow.createDiv({ cls: "folio-modal-right" });
        const subtitleInput = subRight.createEl("input", { type: "text", placeholder: "Subtitle", cls: "folio-modal-input" });
        try {
          subtitleInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const targetRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const targetLeft = targetRow.createDiv({ cls: "folio-modal-left" });
        targetLeft.createEl("div", { text: "Target word count", cls: "folio-modal-row-title" });
        targetLeft.createEl("div", { text: "Set estimated total word count (in 1k)", cls: "folio-modal-row-sub" });
        const targetRight = targetRow.createDiv({ cls: "folio-modal-right" });
        const targetInput = targetRight.createEl("input", { type: "text", placeholder: "e.g., 20 (20k) or 20000", cls: "folio-modal-input" });
        try {
          targetInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const authorRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const authorLeft = authorRow.createDiv({ cls: "folio-modal-left" });
        authorLeft.createEl("div", { text: "Author", cls: "folio-modal-row-title" });
        authorLeft.createEl("div", { text: "Enter author names, separate multiple authors with commas", cls: "folio-modal-row-sub" });
        const authorRight = authorRow.createDiv({ cls: "folio-modal-right" });
        const authorInput = authorRight.createEl("input", { type: "text", placeholder: "Author", cls: "folio-modal-input" });
        const defaultAuthor = ((_b = this.plugin.settings) == null ? void 0 : _b.defaultAuthor) || "";
        if (defaultAuthor) {
          authorInput.value = defaultAuthor;
        }
        try {
          authorInput.style.width = fieldWidth;
        } catch (e) {
        }
        makeDivider();
        const descRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const descLeft = descRow.createDiv({ cls: "folio-modal-left" });
        descLeft.createEl("div", { text: "Description", cls: "folio-modal-row-title" });
        descLeft.createEl("div", { text: "Please enter book description", cls: "folio-modal-row-sub" });
        const descRight = descRow.createDiv({ cls: "folio-modal-right" });
        const descInput = descRight.createEl("textarea", { placeholder: "Book description", cls: "folio-modal-textarea" });
        try {
          descInput.style.width = fieldWidth;
          descInput.style.minHeight = "120px";
        } catch (e) {
        }
        makeDivider();
        const actions = contentEl.createDiv({ cls: "folio-modal-actions" });
        const createBtn = actions.createEl("button", { text: "Create", cls: "mod-cta folio-modal-create" });
        createBtn.onclick = async () => {
          const title = titleInput.value.trim();
          if (!title)
            return;
          let projectType = this.selectedProjectType;
          if (!projectType) {
            const btnText = typeButton.textContent || "";
            if (btnText.includes("Essay"))
              projectType = PROJECT_TYPES.ESSAY;
            else if (btnText.includes("TV Show") || btnText.includes("TV"))
              projectType = PROJECT_TYPES.SCRIPT;
            else if (btnText.includes("Film"))
              projectType = PROJECT_TYPES.FILM;
            else
              projectType = PROJECT_TYPES.BOOK;
          }
          console.debug && console.debug("Creating project with type:", projectType);
          const selectedTemplate = templates.find((t) => t.id === projectType);
          const templateStructure = (selectedTemplate == null ? void 0 : selectedTemplate.structure) || null;
          const subtitleVal = subtitleInput.value.trim();
          const authorVal = authorInput.value.trim();
          const descVal = descInput.value.trim();
          const targetValRaw = targetInput.value;
          const targetValNum = parseFloat(targetValRaw) || 0;
          this.close();
          await this.plugin.createBook(title, projectType, templateStructure);
          const basePath = this.plugin.settings && this.plugin.settings.basePath ? String(this.plugin.settings.basePath).replace(/\/+/g, "/") : "projects";
          const bookPath = `${basePath}/${title}`.replace(/\/+/g, "/");
          try {
            if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
              console.debug("NewBookModal.create captured", { title, projectType, subtitleVal, authorVal, descVal, targetValNum, bookPath });
          } catch (e) {
          }
          await this.plugin.waitForFolderSync(bookPath);
          await this.plugin.refresh();
          const book = this.plugin.booksIndex.find((b) => b.path === bookPath) || this.plugin.booksIndex.find((b) => b.name === title);
          if (book) {
            try {
              let cfg = {};
              if (this.plugin.loadBookConfig)
                cfg = await this.plugin.loadBookConfig(book) || {};
              cfg.basic = cfg.basic || {};
              cfg.basic.title = title;
              cfg.basic.subtitle = subtitleVal || "";
              cfg.basic.author = authorVal ? authorVal.split(",").map((s) => s.trim()).filter(Boolean) : cfg.basic.author || [];
              cfg.basic.desc = descVal || "";
              cfg.basic.created_at = cfg.basic.created_at || new Date().toISOString();
              cfg.stats = cfg.stats || {};
              const targ = targetValNum || 0;
              if (targ > 0) {
                cfg.stats.target_total_words = targ >= 1e3 ? Math.round(targ) : Math.round(targ * 1e3);
              } else {
                cfg.stats.target_total_words = cfg.stats.target_total_words || 0;
              }
              if (this._selectedCover && this._selectedCover.name && this._selectedCover.data) {
                try {
                  const destName = `${Date.now()}-${this._selectedCover.name}`.replace(/[^a-zA-Z0-9._-]/g, "_");
                  const destPath = `${book.path}/misc/cover/${destName}`;
                  if (this.plugin.app.vault.adapter && typeof this.plugin.app.vault.adapter.writeBinary === "function") {
                    const uint8 = new Uint8Array(this._selectedCover.data);
                    await this.plugin.app.vault.adapter.writeBinary(destPath, uint8);
                  } else {
                    const blob = new Blob([this._selectedCover.data]);
                    const arrayBuf = await blob.arrayBuffer();
                    const uint8 = new Uint8Array(arrayBuf);
                    try {
                      await this.plugin.app.vault.create(destPath, uint8);
                    } catch (e) {
                      console.warn("fallback cover write failed", e);
                    }
                  }
                  cfg.basic.cover = `misc/cover/${destName}`;
                } catch (e) {
                  console.warn("saving selected cover failed", e);
                }
              }
              if (this.plugin.saveBookConfig) {
                await this.plugin.saveBookConfig(book, cfg);
                try {
                  if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
                    console.debug("NewBookModal saved initial config for", book.path, { basic: cfg.basic });
                } catch (e) {
                }
              }
            } catch (e) {
              console.warn(e);
            }
            if (!templateStructure || templateStructure.length === 0) {
              if (projectType === PROJECT_TYPES.SCRIPT) {
                const episodeName = "Episode 1";
                const sequenceName = "Sequence 1";
                const sceneName = "Scene 1";
                await this.plugin.createVolume(book, episodeName);
                await this.plugin.createVolume({ path: `${book.path}/${episodeName}` }, sequenceName);
                await this.plugin.createChapter({ path: `${book.path}/${episodeName}/${sequenceName}` }, sceneName, projectType);
              } else if (projectType === PROJECT_TYPES.FILM) {
              } else if (projectType === PROJECT_TYPES.ESSAY) {
              } else {
                const volumeName = "Volume 1";
                const chapterName = "Chapter 1";
                await this.plugin.createVolume(book, volumeName);
                await this.plugin.createChapter({ path: `${book.path}/${volumeName}` }, chapterName, projectType);
              }
            }
            await this.plugin.refresh();
            const updatedBook = this.plugin.booksIndex.find((b) => b.path === book.path);
            if (updatedBook) {
              this.plugin.activeBook = updatedBook;
              try {
                this.plugin.settings = this.plugin.settings || {};
                this.plugin.settings.lastActiveBookPath = updatedBook.path;
                await this.plugin.saveSettings();
              } catch (e) {
                console.warn("failed to persist lastActiveBookPath", e);
              }
            }
          }
          this.plugin.rerenderViews();
        };
        titleInput.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            e.preventDefault();
            createBtn.click();
          } else if (e.key === "Escape") {
            this.close();
          }
        });
        titleInput.focus();
      }
    };
  }
});

// src/modals/switchBookModal.js
var switchBookModal_exports = {};
__export(switchBookModal_exports, {
  SwitchBookModal: () => SwitchBookModal
});
function getProjectTypeIcon(plugin, projectType) {
  var _a;
  const templates = ((_a = plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
  const template = templates.find((t) => t.id === projectType);
  if (template == null ? void 0 : template.icon)
    return template.icon;
  if (projectType === PROJECT_TYPES.BOOK)
    return "book";
  if (projectType === PROJECT_TYPES.SCRIPT)
    return "tv";
  if (projectType === PROJECT_TYPES.FILM)
    return "clapperboard";
  if (projectType === PROJECT_TYPES.ESSAY)
    return "newspaper";
  return "book";
}
var Modal3, setIcon2, SwitchBookModal;
var init_switchBookModal = __esm({
  "src/modals/switchBookModal.js"() {
    init_constants();
    ({ Modal: Modal3, setIcon: setIcon2 } = require("obsidian"));
    SwitchBookModal = class extends Modal3 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Switch project" });
        const search = contentEl.createEl("input", {
          type: "text",
          placeholder: "Search books...",
          cls: "folio-manage-search"
        });
        const list = contentEl.createDiv({ cls: "folio-manage-list" });
        const formatTarget = (n) => {
          if (!n)
            return "\u2014";
          const num = Number(n) || 0;
          if (num >= 1e3) {
            const k = num / 1e3;
            return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
          }
          return String(num);
        };
        const renderList = async (filter) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m;
          list.empty();
          const seen = /* @__PURE__ */ new Set();
          for (const book of this.plugin.booksIndex) {
            if (!book || !book.path)
              continue;
            if (seen.has(book.path))
              continue;
            seen.add(book.path);
            let cfg = {};
            try {
              cfg = await this.plugin.loadBookConfig(book) || {};
            } catch (e) {
            }
            const subtitle = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.subtitle) || "";
            const authors = Array.isArray((_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.author) ? cfg.basic.author.join(", ") : ((_c = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _c.author) || "";
            const desc = ((_d = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _d.desc) || ((_e = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _e.description) || "";
            const totalWords = ((_f = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _f.total_words) || 0;
            const targetWords = Number(((_g = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _g.target_total_words) || ((_h = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _h.targetWordCount) || 0) || 0;
            let displayTitle = cfg && cfg.basic && cfg.basic.title ? cfg.basic.title : book.name || "";
            const q = filter ? String(filter).trim().toLowerCase() : "";
            if (q) {
              const fields = [displayTitle || book.name || "", subtitle || "", authors || "", desc || ""];
              const matches = fields.some((f) => {
                const s = String(f).toLowerCase();
                if (s.startsWith(q))
                  return true;
                return s.split(/\s+/).some((w) => w.startsWith(q));
              });
              if (!matches)
                continue;
            }
            const row = list.createDiv({ cls: "folio-switch-book-row" });
            const leftCol = row.createDiv({ cls: "folio-switch-left" });
            const rightCol = row.createDiv({ cls: "folio-switch-right" });
            const titleRow = leftCol.createDiv({ cls: "folio-switch-title-row" });
            const iconEl = titleRow.createSpan({ cls: "folio-switch-icon" });
            const projectType = ((_i = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _i.projectType) || PROJECT_TYPES.BOOK;
            const iconName = getProjectTypeIcon(this.plugin, projectType);
            setIcon2(iconEl, iconName);
            titleRow.createSpan({ text: displayTitle || book.name || "Untitled", cls: "folio-switch-title" });
            if (subtitle) {
              titleRow.createSpan({ text: " - ", cls: "folio-switch-dash" });
              titleRow.createSpan({ text: subtitle, cls: "folio-switch-subtitle" });
            }
            const progressPct = targetWords > 0 ? Math.round(Number(totalWords) / Number(targetWords) * 100) : "\u2014";
            let createdDate = "\u2014";
            let lastMod = "\u2014";
            try {
              const created = ((_j = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _j.created_at) || ((_k = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _k.created_at) || "";
              if (created)
                createdDate = new Date(created).toLocaleString();
            } catch (e) {
            }
            try {
              const lm = ((_l = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _l.last_modified) || ((_m = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _m.lastModified) || "";
              if (lm)
                lastMod = new Date(lm).toLocaleString();
            } catch (e) {
            }
            leftCol.createDiv({ text: `Author: ${authors || "\u2014"} | Progress: ${progressPct}% | Words: ${formatTarget(totalWords)}`, cls: "folio-switch-meta" });
            leftCol.createDiv({ text: `Created: ${createdDate}`, cls: "folio-switch-meta-second" });
            leftCol.createDiv({ text: `Last modified: ${lastMod}`, cls: "folio-switch-meta-second" });
            const selectBtn = rightCol.createEl("button", { text: "Select", cls: "mod-cta" });
            selectBtn.onclick = async () => {
              this.plugin.activeBook = book;
              try {
                this.plugin.settings.lastActiveBookPath = book.path;
                await this.plugin.saveSettings();
              } catch (e) {
                console.warn("Failed to persist lastActiveBookPath", e);
              }
              this.plugin.rerenderViews();
              this.close();
            };
            row.onclick = () => selectBtn.click();
          }
        };
        search.addEventListener("input", (e) => {
          renderList(e.target.value);
        });
        await renderList("");
      }
    };
  }
});

// src/modals/confirmModal.js
var Modal4, ConfirmModal;
var init_confirmModal = __esm({
  "src/modals/confirmModal.js"() {
    ({ Modal: Modal4 } = require("obsidian"));
    ConfirmModal = class extends Modal4 {
      constructor(app, { title, message, confirmText, onConfirm }) {
        super(app);
        this.title = title;
        this.message = message;
        this.confirmText = confirmText || "Confirm";
        this.onConfirm = onConfirm;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: this.title });
        contentEl.createEl("p", { text: this.message });
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", { text: "Cancel" });
        const confirmBtn = actions.createEl("button", {
          text: this.confirmText,
          cls: "mod-warning"
        });
        cancelBtn.onclick = () => this.close();
        confirmBtn.onclick = async () => {
          await this.onConfirm();
          this.close();
        };
      }
    };
  }
});

// src/modals/editBookModal.js
var Modal5, TFile4, EditBookModal;
var init_editBookModal = __esm({
  "src/modals/editBookModal.js"() {
    ({ Modal: Modal5, TFile: TFile4 } = require("obsidian"));
    EditBookModal = class extends Modal5 {
      constructor(plugin, book) {
        super(plugin.app);
        this.plugin = plugin;
        this.book = book;
      }
      async onOpen() {
        var _a, _b, _c, _d, _e, _f, _g;
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Edit book" });
        let meta = {};
        let cfg = {};
        try {
          if (this.plugin.loadBookConfig)
            cfg = await this.plugin.loadBookConfig(this.book) || {};
        } catch (e) {
        }
        if (cfg && cfg.basic) {
          meta.title = cfg.basic.title || this.book.name || "";
          meta.subtitle = cfg.basic.subtitle || "";
          meta.author = Array.isArray(cfg.basic.author) ? cfg.basic.author.join(", ") : cfg.basic.author || "";
          meta.description = cfg.basic.desc || cfg.basic.description || "";
        } else {
          try {
            if (this.plugin.loadBookMeta)
              meta = await this.plugin.loadBookMeta(this.book) || {};
          } catch (e) {
          }
          try {
            if (!meta || Object.keys(meta).length === 0) {
              const fm = await this.plugin.readBookMetadata(this.book);
              if (fm)
                meta = Object.assign({}, meta, fm);
            }
          } catch (e) {
          }
        }
        const fieldWidth = "min(320px, 60%)";
        let selectedCover = null;
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const coverRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const coverLeft = coverRow.createDiv({ cls: "folio-modal-left" });
        coverLeft.createEl("div", { text: "Cover", cls: "folio-modal-row-title" });
        coverLeft.createEl("div", { text: "Select image (optional)", cls: "folio-modal-row-sub" });
        const coverRight = coverRow.createDiv({ cls: "folio-modal-right" });
        const coverBtn = coverRight.createEl("button", { text: "Select Image" });
        try {
          const existingCover = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.cover) || "";
          if (existingCover) {
            const baseName = existingCover.split("/").pop();
            selectedCover = { name: baseName, data: null };
          }
        } catch (e) {
        }
        coverBtn.onclick = () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = "image/*";
          input.style.display = "none";
          input.onchange = async (e) => {
            const file = e.target.files && e.target.files[0];
            if (!file)
              return;
            try {
              const reader = new FileReader();
              reader.onload = (ev) => {
                const ab = ev.target.result;
                selectedCover = { name: file.name, data: ab };
                coverBtn.textContent = "Select Image";
              };
              reader.readAsArrayBuffer(file);
            } catch (err) {
              console.warn("cover selection failed", err);
            }
          };
          document.body.appendChild(input);
          input.click();
          document.body.removeChild(input);
        };
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const titleRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const titleLeft = titleRow.createDiv({ cls: "folio-modal-left" });
        titleLeft.createEl("div", { text: "Title", cls: "folio-modal-row-title" });
        titleLeft.createEl("div", { text: "Please enter book title", cls: "folio-modal-row-sub" });
        const titleRight = titleRow.createDiv({ cls: "folio-modal-right" });
        const titleInput = titleRight.createEl("input", { type: "text", cls: "folio-modal-input" });
        try {
          titleInput.style.width = fieldWidth;
        } catch (e) {
        }
        titleInput.value = meta.title || this.book.name || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const subRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const subLeft = subRow.createDiv({ cls: "folio-modal-left" });
        subLeft.createEl("div", { text: "Subtitle", cls: "folio-modal-row-title" });
        subLeft.createEl("div", { text: "Optional", cls: "folio-modal-row-sub" });
        const subRight = subRow.createDiv({ cls: "folio-modal-right" });
        const subtitleInput = subRight.createEl("input", { type: "text", cls: "folio-modal-input" });
        try {
          subtitleInput.style.width = fieldWidth;
        } catch (e) {
        }
        subtitleInput.value = meta.subtitle || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const authorRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const authorLeft = authorRow.createDiv({ cls: "folio-modal-left" });
        authorLeft.createEl("div", { text: "Author", cls: "folio-modal-row-title" });
        authorLeft.createEl("div", { text: "Enter author names, separate multiple authors with commas", cls: "folio-modal-row-sub" });
        const authorRight = authorRow.createDiv({ cls: "folio-modal-right" });
        const authorInput = authorRight.createEl("input", { type: "text", cls: "folio-modal-input" });
        try {
          authorInput.style.width = fieldWidth;
        } catch (e) {
        }
        authorInput.value = meta.author || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const descRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const descLeft = descRow.createDiv({ cls: "folio-modal-left" });
        descLeft.createEl("div", { text: "Description", cls: "folio-modal-row-title" });
        descLeft.createEl("div", { text: "Please enter book description", cls: "folio-modal-row-sub" });
        const descRight = descRow.createDiv({ cls: "folio-modal-right" });
        const descInput = descRight.createEl("textarea", { cls: "folio-modal-textarea" });
        try {
          descInput.style.width = fieldWidth;
          descInput.style.minHeight = "120px";
          descInput.style.maxWidth = "100%";
        } catch (e) {
        }
        descInput.value = meta.description || "";
        contentEl.createDiv({ cls: "folio-modal-divider" });
        const targetRow = contentEl.createDiv({ cls: "folio-modal-row" });
        const targetLeft = targetRow.createDiv({ cls: "folio-modal-left" });
        targetLeft.createEl("div", { text: "Target word count", cls: "folio-modal-row-title" });
        targetLeft.createEl("div", { text: "Set estimated total word count (in 1k)", cls: "folio-modal-row-sub" });
        const targetRight = targetRow.createDiv({ cls: "folio-modal-right" });
        const targetInput = targetRight.createEl("input", { type: "text", cls: "folio-modal-input", placeholder: "e.g., 20 (20k) or 20000" });
        const existingTarget = (_g = (_f = (_d = (_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.targetWordCount) != null ? _d : (_c = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _c.target_total_words) != null ? _f : (_e = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _e.targetWordCount) != null ? _g : "";
        try {
          const num = Number(existingTarget) || 0;
          if (num >= 1e3) {
            targetInput.value = String(num / 1e3);
          } else {
            targetInput.value = existingTarget || "";
          }
        } catch (e) {
          targetInput.value = existingTarget || "";
        }
        try {
          targetInput.style.width = fieldWidth;
        } catch (e) {
        }
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", { text: "Cancel" });
        const saveBtn = actions.createEl("button", { text: "Save", cls: "mod-cta" });
        cancelBtn.onclick = () => this.close();
        saveBtn.onclick = async () => {
          const out = Object.assign({}, meta || {});
          out.title = titleInput.value.trim();
          out.subtitle = typeof subtitleInput !== "undefined" ? subtitleInput.value.trim() : "";
          out.author = authorInput.value.trim();
          out.description = descInput.value.trim();
          const targetRaw = targetInput.value.trim();
          const targNum = parseFloat(targetRaw) || 0;
          try {
            if (this.plugin.saveBookMeta) {
              const metaToSave = {
                title: out.title,
                subtitle: out.subtitle || "",
                author: out.author || "",
                description: out.description || "",
                targetWordCount: targNum
              };
              await this.plugin.saveBookMeta(this.book, metaToSave);
            }
          } catch (e) {
            console.warn("saveBookMeta failed", e);
          }
          let cfg2 = {};
          try {
            if (this.plugin.loadBookConfig)
              cfg2 = await this.plugin.loadBookConfig(this.book) || {};
            cfg2.basic = cfg2.basic || {};
            cfg2.stats = cfg2.stats || {};
            cfg2.basic.title = out.title || cfg2.basic.title || this.book.name;
            cfg2.basic.subtitle = out.subtitle || cfg2.basic.subtitle || "";
            cfg2.basic.author = out.author ? out.author.split(",").map((s) => s.trim()).filter(Boolean) : cfg2.basic.author || [];
            cfg2.basic.desc = out.description || cfg2.basic.desc || "";
            let normalizedTarget = 0;
            if (targNum > 0) {
              if (targNum >= 1e3)
                normalizedTarget = Math.round(targNum);
              else
                normalizedTarget = Math.round(targNum * 1e3);
            }
            cfg2.stats = cfg2.stats || {};
            cfg2.stats.target_total_words = normalizedTarget;
            cfg2.stats.last_modified = new Date().toISOString();
            if (selectedCover && selectedCover.name && selectedCover.data) {
              try {
                const destName = `${Date.now()}-${selectedCover.name}`.replace(/[^a-zA-Z0-9._-]/g, "_");
                const destPath = `${this.book.path}/misc/cover/${destName}`;
                if (this.plugin.app.vault.adapter && typeof this.plugin.app.vault.adapter.writeBinary === "function") {
                  const uint8 = new Uint8Array(selectedCover.data);
                  await this.plugin.app.vault.adapter.writeBinary(destPath, uint8);
                } else {
                  const blob = new Blob([selectedCover.data]);
                  const arrayBuf = await blob.arrayBuffer();
                  const uint8 = new Uint8Array(arrayBuf);
                  try {
                    await this.plugin.app.vault.create(destPath, uint8);
                  } catch (e) {
                    console.warn("fallback cover write failed", e);
                  }
                }
                cfg2.basic = cfg2.basic || {};
                cfg2.basic.cover = `misc/cover/${destName}`;
              } catch (e) {
                console.warn("saving selected cover failed", e);
              }
            }
            if (this.plugin.saveBookConfig)
              await this.plugin.saveBookConfig(this.book, cfg2);
          } catch (e) {
            console.warn(e);
          }
          let newTitle;
          try {
            newTitle = cfg2 && cfg2.basic && cfg2.basic.title ? cfg2.basic.title : out.title || this.book.name;
            try {
              this.book.name = newTitle;
            } catch (e) {
            }
            if (Array.isArray(this.plugin.booksIndex)) {
              const idx = this.plugin.booksIndex.findIndex((b) => b && b.path === this.book.path);
              if (idx !== -1)
                this.plugin.booksIndex[idx].name = newTitle;
            }
            try {
              if (this.plugin.activeBook && this.plugin.activeBook.path === this.book.path)
                this.plugin.activeBook.name = newTitle;
            } catch (e) {
            }
          } catch (err) {
            console.warn("updating in-memory book title failed", err);
          }
          try {
            const oldPath = this.book.path;
            const parentParts = String(oldPath).split("/").slice(0, -1);
            const parent = parentParts.join("/");
            const safeName = String(newTitle || "").replace(/[\\/\:\*\?"<>\|]/g, "_").trim();
            const newPath = parent ? `${parent}/${safeName}` : safeName;
            if (safeName && newPath !== oldPath) {
              const existing = this.plugin.app.vault.getAbstractFileByPath(newPath);
              if (!existing) {
                const folderAf = this.plugin.app.vault.getAbstractFileByPath(oldPath);
                if (folderAf) {
                  const onUnhandledRej = (ev) => {
                    try {
                      const r = ev && ev.reason;
                      if (!r)
                        return;
                      if (r && r.code === "ENOENT" && typeof r.message === "string" && r.message.includes(oldPath)) {
                        try {
                          ev.preventDefault && ev.preventDefault();
                        } catch (e) {
                        }
                      }
                    } catch (e) {
                    }
                  };
                  try {
                    if (typeof window !== "undefined" && window && window.addEventListener) {
                      window.addEventListener("unhandledrejection", onUnhandledRej);
                    }
                    try {
                      if (this.plugin.app.fileManager && typeof this.plugin.app.fileManager.renameFile === "function") {
                        await this.plugin.app.fileManager.renameFile(folderAf, newPath);
                      } else {
                        await this.plugin.app.vault.rename(folderAf, newPath);
                      }
                    } finally {
                      try {
                        await new Promise((r) => setTimeout(r, 250));
                      } catch (e) {
                      }
                    }
                    try {
                      await this.plugin.waitForFolderSync(newPath, 40);
                    } catch (e) {
                    }
                    const checkAf = this.plugin.app.vault.getAbstractFileByPath(newPath);
                    if (checkAf) {
                      try {
                        this.book.path = newPath;
                      } catch (e) {
                      }
                      if (Array.isArray(this.plugin.booksIndex)) {
                        const idx2 = this.plugin.booksIndex.findIndex((b) => b && b.path === oldPath);
                        if (idx2 !== -1) {
                          this.plugin.booksIndex[idx2].path = newPath;
                          this.plugin.booksIndex[idx2].name = newTitle;
                        }
                      }
                      if (this.plugin.activeBook && this.plugin.activeBook.path === oldPath) {
                        this.plugin.activeBook.path = newPath;
                        this.plugin.activeBook.name = newTitle;
                        try {
                          this.plugin.settings = this.plugin.settings || {};
                          this.plugin.settings.lastActiveBookPath = newPath;
                          await this.plugin.saveSettings();
                        } catch (e) {
                        }
                      }
                    } else {
                      console.warn("rename succeeded but new folder not visible yet", newPath);
                    }
                  } catch (e) {
                    console.warn("folder rename failed", e);
                  } finally {
                    try {
                      if (typeof window !== "undefined" && window && window.removeEventListener)
                        window.removeEventListener("unhandledrejection", onUnhandledRej);
                    } catch (e) {
                    }
                  }
                }
              } else {
                console.warn("target folder already exists, skipping rename", newPath);
              }
            }
          } catch (e) {
            console.warn("rename attempt failed", e);
          }
          try {
            document.dispatchEvent(new CustomEvent("novelist:book-updated", { detail: { path: this.book.path } }));
          } catch (e) {
          }
          await this.plugin.refresh();
          this.plugin.rerenderViews();
          this.close();
        };
      }
    };
  }
});

// src/modals/manageBooksModal.js
var manageBooksModal_exports = {};
__export(manageBooksModal_exports, {
  ManageBooksModal: () => ManageBooksModal
});
function getProjectTypeIcon2(plugin, projectType) {
  var _a;
  const templates = ((_a = plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
  const template = templates.find((t) => t.id === projectType);
  if (template == null ? void 0 : template.icon)
    return template.icon;
  if (projectType === PROJECT_TYPES.BOOK)
    return "book";
  if (projectType === PROJECT_TYPES.SCRIPT)
    return "tv";
  if (projectType === PROJECT_TYPES.FILM)
    return "clapperboard";
  if (projectType === PROJECT_TYPES.ESSAY)
    return "newspaper";
  return "book";
}
var Modal6, TFile5, setIcon3, ManageBooksModal;
var init_manageBooksModal = __esm({
  "src/modals/manageBooksModal.js"() {
    init_constants();
    init_confirmModal();
    init_editBookModal();
    ({ Modal: Modal6, TFile: TFile5, setIcon: setIcon3 } = require("obsidian"));
    ManageBooksModal = class extends Modal6 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      async onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        this.modalEl.style.width = "750px";
        this.modalEl.style.maxWidth = "90vw";
        contentEl.createEl("h2", { text: "Manage projects" });
        const search = contentEl.createEl("input", {
          type: "text",
          placeholder: "Search books...",
          cls: "folio-manage-search"
        });
        const list = contentEl.createDiv({ cls: "folio-manage-list" });
        const formatTarget = (n) => {
          if (!n)
            return "\u2014";
          const num = Number(n) || 0;
          if (num >= 1e3) {
            const k = num / 1e3;
            return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
          }
          return String(num);
        };
        const renderList = async (filter) => {
          var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;
          list.empty();
          const seen = /* @__PURE__ */ new Set();
          for (const book of this.plugin.booksIndex) {
            if (!book || !book.path)
              continue;
            if (seen.has(book.path))
              continue;
            seen.add(book.path);
            let cfg = {};
            try {
              cfg = await this.plugin.loadBookConfig(book) || {};
            } catch (e) {
            }
            const subtitle = ((_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.subtitle) || "";
            const authors = Array.isArray((_b = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _b.author) ? cfg.basic.author.join(", ") : ((_c = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _c.author) || "";
            const desc = ((_d = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _d.desc) || ((_e = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _e.description) || "";
            const totalWords = ((_f = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _f.total_words) || 0;
            const targetWords = Number(((_g = cfg == null ? void 0 : cfg.stats) == null ? void 0 : _g.target_total_words) || ((_h = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _h.targetWordCount) || 0) || 0;
            const displayTitle = cfg && cfg.basic && cfg.basic.title ? cfg.basic.title : book.name || "";
            const q = filter ? String(filter).trim().toLowerCase() : "";
            if (q) {
              const fields = [displayTitle || book.name || "", subtitle || "", authors || "", desc || ""];
              const matches = fields.some((f) => {
                const s = String(f).toLowerCase();
                if (s.startsWith(q))
                  return true;
                return s.split(/\s+/).some((w) => w.startsWith(q));
              });
              if (!matches)
                continue;
            }
            const card = list.createDiv({ cls: "folio-manage-card" });
            const left = card.createDiv({ cls: "folio-manage-left" });
            const right = card.createDiv({ cls: "folio-manage-right" });
            const coverWrap = left.createDiv({ cls: "folio-manage-cover" });
            try {
              const coverFile = book.cover instanceof TFile5 ? book.cover : book.cover ? this.plugin.app.vault.getAbstractFileByPath(book.cover) : null;
              if (coverFile instanceof TFile5) {
                const url = this.plugin.app.vault.getResourcePath(coverFile);
                coverWrap.style.backgroundImage = `url("${url}")`;
              }
            } catch (e) {
            }
            try {
              const coverFile = book.cover instanceof TFile5 ? book.cover : book.cover ? this.plugin.app.vault.getAbstractFileByPath(book.cover) : null;
              if (!(coverFile instanceof TFile5)) {
                coverWrap.addClass("folio-manage-cover-placeholder");
                const iconEl = coverWrap.createDiv({ cls: "folio-manage-cover-icon" });
                const projectType2 = ((_i = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _i.projectType) || PROJECT_TYPES.BOOK;
                const iconName = getProjectTypeIcon2(this.plugin, projectType2);
                setIcon3(iconEl, iconName);
              }
            } catch (e) {
            }
            const titleRow = right.createDiv({ cls: "folio-manage-title-row" });
            titleRow.createDiv({ text: displayTitle || book.name || "Untitled", cls: "folio-manage-title" });
            const actions = titleRow.createDiv({ cls: "folio-manage-actions" });
            const deleteBtn = actions.createEl("button", { text: "Delete", cls: "mod-danger" });
            const editBtn = actions.createEl("button", { text: "Edit" });
            const metaGrid = right.createDiv({ cls: "folio-manage-meta-grid" });
            const labelsCol = metaGrid.createDiv({ cls: "folio-manage-labels" });
            const valuesCol = metaGrid.createDiv({ cls: "folio-manage-values" });
            const projectType = ((_j = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _j.projectType) || PROJECT_TYPES.BOOK;
            const typeLabel = projectType === PROJECT_TYPES.BOOK ? "Book" : projectType === PROJECT_TYPES.SCRIPT ? "TV Show" : projectType === PROJECT_TYPES.FILM ? "Film" : projectType === PROJECT_TYPES.ESSAY ? "Essay" : "Book";
            labelsCol.createEl("div", { text: "Type", cls: "folio-manage-label" });
            valuesCol.createEl("div", { text: typeLabel, cls: "folio-manage-author" });
            labelsCol.createEl("div", { text: "Author", cls: "folio-manage-label" });
            valuesCol.createEl("div", { text: authors || "\u2014", cls: "folio-manage-author" });
            labelsCol.createEl("div", { text: "Description", cls: "folio-manage-label" });
            const truncateToWords = (text, wordLimit) => {
              if (!text)
                return "\u2014";
              const words = text.trim().split(/\s+/);
              if (words.length <= wordLimit)
                return text;
              return words.slice(0, wordLimit).join(" ") + "...";
            };
            const short = truncateToWords(desc, 5);
            valuesCol.createEl("div", { text: short, cls: "folio-manage-desc" });
            labelsCol.createEl("div", { text: "Progress", cls: "folio-manage-label" });
            valuesCol.createEl("div", { text: `${totalWords} / ${formatTarget(targetWords)}`, cls: "folio-manage-progress" });
            deleteBtn.onclick = async () => {
              const self = this;
              const modal = new ConfirmModal(this.plugin.app, {
                title: `Delete ${book.name}`,
                message: `Delete book "${book.name}" and all its files? This cannot be undone.`,
                confirmText: "Delete",
                onConfirm: async () => {
                  try {
                    await self.plugin.deleteFolderRecursive(book.path);
                  } catch (e) {
                    console.warn("delete book failed", e);
                  }
                  await self.plugin.refresh();
                  self.close();
                }
              });
              modal.open();
            };
            editBtn.onclick = () => {
              new EditBookModal(this.plugin, book).open();
            };
          }
          if (!list.children || list.children.length === 0) {
            const empty = list.createDiv({ cls: "folio-manage-empty" });
            empty.createEl("div", { text: "No books found" });
          }
        };
        search.addEventListener("input", (e) => {
          renderList(e.target.value);
        });
        this._onBookUpdated = (ev) => {
          try {
            renderList(search.value);
          } catch (e) {
          }
        };
        document.addEventListener("novelist:book-updated", this._onBookUpdated);
        await renderList("");
      }
      onClose() {
        try {
          document.removeEventListener("novelist:book-updated", this._onBookUpdated);
        } catch (e) {
        }
      }
    };
  }
});

// src/modals/helpModal.js
var helpModal_exports = {};
__export(helpModal_exports, {
  HelpModal: () => HelpModal
});
var Modal7, HelpModal;
var init_helpModal = __esm({
  "src/modals/helpModal.js"() {
    ({ Modal: Modal7 } = require("obsidian"));
    HelpModal = class extends Modal7 {
      constructor(plugin) {
        super(plugin.app);
        this.plugin = plugin;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: "Help" });
        contentEl.createEl("p", { text: "TBD" });
      }
    };
  }
});

// src/modals/textInputModal.js
var textInputModal_exports = {};
__export(textInputModal_exports, {
  TextInputModal: () => TextInputModal
});
var Modal8, TextInputModal;
var init_textInputModal = __esm({
  "src/modals/textInputModal.js"() {
    ({ Modal: Modal8 } = require("obsidian"));
    TextInputModal = class extends Modal8 {
      constructor(app, { title, placeholder, cta, onSubmit }) {
        super(app);
        this.title = title;
        this.placeholder = placeholder;
        this.cta = cta;
        this.onSubmit = onSubmit;
      }
      onOpen() {
        const { contentEl } = this;
        contentEl.empty();
        contentEl.createEl("h2", { text: this.title });
        const input = contentEl.createEl("input", {
          type: "text",
          placeholder: this.placeholder
        });
        const actions = contentEl.createDiv({ cls: "modal-button-container" });
        const cancelBtn = actions.createEl("button", {
          text: "Cancel"
        });
        const confirmBtn = actions.createEl("button", {
          text: this.cta,
          cls: "mod-cta"
        });
        cancelBtn.onclick = () => this.close();
        confirmBtn.onclick = () => {
          const value = input.value.trim();
          if (!value)
            return;
          this.onSubmit(value);
          this.close();
        };
        input.addEventListener("keydown", (e) => {
          if (e.key === "Enter") {
            confirmBtn.click();
          } else if (e.key === "Escape") {
            this.close();
          }
        });
        input.focus();
      }
    };
  }
});

// src/services/configService.js
init_constants();
var ConfigService = class {
  constructor(app) {
    this.app = app;
  }
  /**
   * Load full project config from book-config.json inside misc folder
   */
  async loadProjectConfig(project) {
    try {
      let filePath = `${project.path}/misc/project-config.json`;
      let f = this.app.vault.getAbstractFileByPath(filePath);
      if (!f) {
        filePath = `${project.path}/misc/book-config.json`;
        f = this.app.vault.getAbstractFileByPath(filePath);
      }
      if (!f)
        return null;
      const content = await this.app.vault.read(f);
      return JSON.parse(content);
    } catch (e) {
      if (!e || e.code === "ENOENT")
        return null;
      console.warn("loadProjectConfig failed", e);
      return null;
    }
  }
  // Alias for backwards compatibility
  async loadBookConfig(book) {
    return this.loadProjectConfig(book);
  }
  /**
   * Save full project config to book-config.json inside misc folder
   * Performs intelligent merge with existing config to avoid data loss
   */
  async saveProjectConfig(project, config) {
    try {
      const filePath = `${project.path}/misc/project-config.json`;
      const miscDir = `${project.path}/misc`;
      const legacyPath = `${project.path}/misc/book-config.json`;
      const legacyFile = this.app.vault.getAbstractFileByPath(legacyPath);
      if (legacyFile) {
        const newFile = this.app.vault.getAbstractFileByPath(filePath);
        if (!newFile) {
          await this.app.vault.rename(legacyFile, filePath);
        }
      }
      try {
        const existingMisc = this.app.vault.getAbstractFileByPath(miscDir);
        if (!existingMisc) {
          await this.app.vault.createFolder(miscDir);
        }
      } catch (e) {
      }
      const f = this.app.vault.getAbstractFileByPath(filePath);
      let finalCfg = config || {};
      if (f) {
        try {
          const existingRaw = await this.app.vault.read(f);
          const existing = JSON.parse(existingRaw || "{}");
          const mergeObjects = (base, incoming) => {
            const out = Object.assign({}, base || {});
            if (!incoming)
              return out;
            for (const k of Object.keys(incoming)) {
              const v = incoming[k];
              if (v === void 0 || v === null)
                continue;
              if (Array.isArray(v)) {
                if (v.length > 0)
                  out[k] = v;
              } else if (typeof v === "object") {
                out[k] = mergeObjects(base ? base[k] : void 0, v);
              } else {
                if (typeof v === "string") {
                  if (v === "" && base && typeof base[k] === "string" && base[k].trim() !== "") {
                    out[k] = base[k];
                  } else {
                    out[k] = v;
                  }
                } else {
                  out[k] = v;
                }
              }
            }
            return out;
          };
          const merged = Object.assign({}, existing || {});
          merged.basic = mergeObjects(existing.basic, finalCfg.basic);
          merged.stats = mergeObjects(existing.stats, finalCfg.stats);
          for (const k of Object.keys(finalCfg)) {
            if (k !== "basic" && k !== "stats")
              merged[k] = finalCfg[k];
          }
          finalCfg = merged;
        } catch (e) {
          finalCfg = config || {};
        }
        const content = JSON.stringify(finalCfg || {}, null, 2);
        await this.app.vault.modify(f, content);
      } else {
        const content = JSON.stringify(finalCfg || {}, null, 2);
        await this.app.vault.create(filePath, content);
      }
      return true;
    } catch (e) {
      console.warn("saveProjectConfig failed", e);
      return false;
    }
  }
  // Alias for backwards compatibility
  async saveBookConfig(book, config) {
    return this.saveProjectConfig(book, config);
  }
  /**
   * Load project metadata (simplified view of config)
   */
  async loadProjectMeta(project) {
    var _a, _b, _c, _d, _e, _f, _g, _h;
    try {
      const cfg = await this.loadProjectConfig(project);
      if (!cfg)
        return null;
      return {
        title: ((_a = cfg.basic) == null ? void 0 : _a.title) || "",
        author: ((_b = cfg.basic) == null ? void 0 : _b.author) || [],
        subtitle: ((_c = cfg.basic) == null ? void 0 : _c.subtitle) || "",
        description: ((_d = cfg.basic) == null ? void 0 : _d.desc) || "",
        uuid: ((_e = cfg.basic) == null ? void 0 : _e.uuid) || "",
        created_at: ((_f = cfg.basic) == null ? void 0 : _f.created_at) || new Date().toISOString(),
        target_words: ((_g = cfg.stats) == null ? void 0 : _g.target_total_words) || 0,
        projectType: ((_h = cfg.basic) == null ? void 0 : _h.projectType) || "book"
      };
    } catch (e) {
      console.warn("loadBookMeta failed", e);
      return null;
    }
  }
  /**
   * Create a new book config with default structure
   */
  createDefaultConfig(title, author) {
    const uuid = this.generateUUID();
    const now = new Date().toISOString();
    return {
      basic: {
        title: title || "",
        author: author ? [author] : [],
        subtitle: "",
        desc: "",
        uuid,
        created_at: now
      },
      structure: {
        tree: []
      },
      stats: {
        total_words: 0,
        target_total_words: 1e4,
        progress_by_words: 0,
        progress_by_chapter: 0,
        daily_words: {},
        writing_days: 0,
        average_daily_words: 0,
        last_writing_date: now,
        last_modified: now,
        per_chapter: {}
      },
      export: {
        default_format: "pdf",
        template: "default",
        include_cover: true
      }
    };
  }
  /**
   * Generate a simple UUID
   */
  generateUUID() {
    const timestamp = Date.now().toString(16);
    const random = Math.random().toString(36).substr(2, 9);
    return `${timestamp}-${random}`;
  }
};

// src/services/treeService.js
var import_obsidian = require("obsidian");
var TreeService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Generate unique node ID
   */
  generateNodeId() {
    return `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  /**
   * Build tree from filesystem (sync tree structure with actual files/folders)
   * Merges with existing config to preserve order, IDs, and metadata
   */
  async buildTreeFromFilesystem(bookFolder) {
    var _a;
    try {
      const cfg = await this.configService.loadBookConfig({ path: bookFolder.path }) || {};
      const existingTree = ((_a = cfg == null ? void 0 : cfg.structure) == null ? void 0 : _a.tree) || [];
      const existingMap = /* @__PURE__ */ new Map();
      const mapNodes = (nodes2) => {
        for (const node of nodes2) {
          existingMap.set(node.path, node);
          if (node.children)
            mapNodes(node.children);
        }
      };
      mapNodes(existingTree);
      const buildNode = (item, order) => {
        var _a2, _b, _c;
        const relativePath = item.path.replace(bookFolder.path + "/", "");
        const existing = existingMap.get(relativePath);
        if (item instanceof import_obsidian.TFile) {
          const node = {
            id: (existing == null ? void 0 : existing.id) || this.generateNodeId(),
            title: (existing == null ? void 0 : existing.title) || item.basename,
            type: item.extension === "canvas" ? "canvas" : "file",
            path: relativePath,
            order: (_a2 = existing == null ? void 0 : existing.order) != null ? _a2 : order,
            exclude: (existing == null ? void 0 : existing.exclude) || false,
            include: (existing == null ? void 0 : existing.include) || false,
            completed: (existing == null ? void 0 : existing.completed) || false,
            created_at: (existing == null ? void 0 : existing.created_at) || new Date().toISOString(),
            last_modified: new Date().toISOString()
          };
          if (existing == null ? void 0 : existing.icon)
            node.icon = existing.icon;
          return node;
        } else if (item instanceof import_obsidian.TFolder) {
          const folderChildren = (item.children || []).filter((child) => !(child instanceof import_obsidian.TFolder && child.name === "misc"));
          const childNodes = folderChildren.map((child) => buildNode(child, 0));
          const knownFolderOrder = {
            "concept": 1,
            "structure": 2,
            "faces": 3,
            "places": 4,
            "objects": 5,
            "documentation": 6,
            "research": 1,
            "show dossier": 1,
            "episode 1": 2
          };
          childNodes.sort((a, b) => {
            if (a.order && b.order)
              return a.order - b.order;
            const aKnown = knownFolderOrder[a.title.toLowerCase()];
            const bKnown = knownFolderOrder[b.title.toLowerCase()];
            if (aKnown && bKnown)
              return aKnown - bKnown;
            if (aKnown)
              return -1;
            if (bKnown)
              return 1;
            return a.title.localeCompare(b.title);
          });
          childNodes.forEach((node2, idx) => node2.order = idx + 1);
          const children = childNodes;
          const node = {
            id: (existing == null ? void 0 : existing.id) || this.generateNodeId(),
            title: (existing == null ? void 0 : existing.title) || item.name,
            type: "group",
            path: relativePath,
            order: (_b = existing == null ? void 0 : existing.order) != null ? _b : order,
            is_expanded: (_c = existing == null ? void 0 : existing.is_expanded) != null ? _c : false,
            created_at: (existing == null ? void 0 : existing.created_at) || new Date().toISOString(),
            last_modified: new Date().toISOString(),
            children
          };
          if (existing == null ? void 0 : existing.icon)
            node.icon = existing.icon;
          return node;
        }
      };
      const tree = [];
      const fsChildren = (bookFolder.children || []).filter((child) => !(child instanceof import_obsidian.TFolder && child.name === "misc"));
      const nodes = fsChildren.map((child) => buildNode(child, 0));
      const knownRootOrder = {
        "show dossier": 1,
        "episode 1": 2,
        "moodboard": 1,
        "preface": 2,
        "outline": 3,
        "volume 1": 4,
        "afterword": 5,
        "sequence 1": 3,
        "research": 1,
        "manuscript": 3
      };
      nodes.sort((a, b) => {
        if (a.order && b.order)
          return a.order - b.order;
        const aKnown = knownRootOrder[a.title.toLowerCase()];
        const bKnown = knownRootOrder[b.title.toLowerCase()];
        if (aKnown && bKnown)
          return aKnown - bKnown;
        if (aKnown)
          return -1;
        if (bKnown)
          return 1;
        return a.title.localeCompare(b.title);
      });
      let nextOrder = Math.max(0, ...nodes.map((n) => n.order || 0)) + 1;
      nodes.forEach((node) => {
        if (!node.order || node.order === 0) {
          node.order = nextOrder++;
        }
        tree.push(node);
      });
      console.log("Built tree from filesystem:", tree);
      return tree;
    } catch (e) {
      console.warn("buildTreeFromFilesystem failed", e);
      return [];
    }
  }
  /**
   * Reorder tree nodes after drag and drop
   * Handles physical file movement in vault when parent changes
   */
  async reorderTreeNodes(book, draggedNodeId, targetNodeId, position) {
    try {
      const cfg = await this.configService.loadBookConfig(book) || {};
      if (!cfg.structure)
        cfg.structure = {};
      if (!cfg.structure.tree)
        cfg.structure.tree = [];
      const tree = cfg.structure.tree;
      const findNode = (nodes, id, parent = null) => {
        for (let i = 0; i < nodes.length; i++) {
          if (nodes[i].id === id) {
            return { node: nodes[i], parent, index: i, siblings: nodes };
          }
          if (nodes[i].children) {
            const result = findNode(nodes[i].children, id, nodes[i]);
            if (result)
              return result;
          }
        }
        return null;
      };
      const draggedInfo = findNode(tree, draggedNodeId);
      const targetInfo = findNode(tree, targetNodeId);
      if (!draggedInfo || !targetInfo) {
        console.warn("Could not find nodes for reorder", { draggedNodeId, targetNodeId });
        return false;
      }
      draggedInfo.siblings.splice(draggedInfo.index, 1);
      if (position === "inside" && targetInfo.node.type === "group") {
        const oldPath = `${book.path}/${draggedInfo.node.path}`;
        const fileName = draggedInfo.node.path.split("/").pop();
        const newPath = `${targetInfo.node.path}/${fileName}`;
        try {
          const fileToMove = this.app.vault.getAbstractFileByPath(oldPath);
          if (fileToMove) {
            await this.app.fileManager.renameFile(fileToMove, `${book.path}/${newPath}`);
            draggedInfo.node.path = newPath;
          }
        } catch (e) {
          console.warn("Failed to move file in vault:", e);
          return false;
        }
        if (!targetInfo.node.children)
          targetInfo.node.children = [];
        targetInfo.node.children.push(draggedInfo.node);
      } else {
        const draggedParentPath = draggedInfo.node.path.split("/").slice(0, -1).join("/");
        const targetParentPath = targetInfo.node.path.split("/").slice(0, -1).join("/");
        if (draggedParentPath !== targetParentPath) {
          const oldPath = `${book.path}/${draggedInfo.node.path}`;
          const fileName = draggedInfo.node.path.split("/").pop();
          const newPath = targetParentPath ? `${targetParentPath}/${fileName}` : fileName;
          try {
            const fileToMove = this.app.vault.getAbstractFileByPath(oldPath);
            if (fileToMove) {
              await this.app.fileManager.renameFile(fileToMove, `${book.path}/${newPath}`);
              draggedInfo.node.path = newPath;
            }
          } catch (e) {
            console.warn("Failed to move file to new level:", e);
            return false;
          }
        }
        const newTargetIndex = targetInfo.siblings.findIndex((n) => n.id === targetNodeId);
        if (newTargetIndex === -1)
          return false;
        const insertIndex = position === "before" ? newTargetIndex : newTargetIndex + 1;
        targetInfo.siblings.splice(insertIndex, 0, draggedInfo.node);
      }
      const reorderNodes = (nodes) => {
        nodes.forEach((node, idx) => {
          node.order = idx + 1;
          node.last_modified = new Date().toISOString();
          if (node.children)
            reorderNodes(node.children);
        });
      };
      reorderNodes(tree);
      await this.configService.saveBookConfig(book, cfg);
      return true;
    } catch (e) {
      console.warn("reorderTreeNodes failed", e);
      return false;
    }
  }
  /**
   * Toggle exclude/include from stats for a file or folder
   * Updates both frontmatter and config tree
   * For folders, recursively updates all children
   */
  async toggleExcludeFromStats(book, file, exclude) {
    return this.setStatsOverride(book, file, { exclude });
  }
  /**
   * Set explicit include/exclude overrides for stats
   * include/exclude are explicit overrides (exclude wins at compute time)
   */
  async setStatsOverride(book, file, { include, exclude } = {}) {
    var _a;
    try {
      const isFolder = file.children !== void 0;
      if (isFolder) {
        if (typeof exclude === "boolean") {
          await this.excludeFolderFromStats(book, file, exclude);
        }
      } else {
        if (typeof exclude === "boolean") {
          await this.app.fileManager.processFrontMatter(file, (fm) => {
            fm.exclude_from_stats = exclude;
          });
        }
      }
      const cfg = await this.configService.loadBookConfig(book) || {};
      if (!((_a = cfg.structure) == null ? void 0 : _a.tree))
        return;
      const relativePath = file.path.replace(book.path + "/", "");
      const updateNode = (nodes) => {
        for (const node of nodes) {
          if (node.path === relativePath) {
            if (typeof exclude === "boolean") {
              node.exclude = exclude;
              if (exclude)
                node.include = false;
            }
            if (typeof include === "boolean") {
              node.include = include;
              if (include)
                node.exclude = false;
            }
            node.last_modified = new Date().toISOString();
            if (isFolder && node.children) {
              if (typeof exclude === "boolean") {
                this.markAllChildrenExcluded(node.children, exclude);
              }
            }
            return true;
          }
          if (node.children && updateNode(node.children)) {
            return true;
          }
        }
        return false;
      };
      if (updateNode(cfg.structure.tree)) {
        await this.configService.saveBookConfig(book, cfg);
      }
    } catch (e) {
      console.warn("setStatsOverride failed", e);
    }
  }
  /**
   * Helper: Mark all children nodes as excluded/included in config
   */
  markAllChildrenExcluded(children, exclude) {
    for (const node of children) {
      node.exclude = exclude;
      node.last_modified = new Date().toISOString();
      if (node.children) {
        this.markAllChildrenExcluded(node.children, exclude);
      }
    }
  }
  /**
   * Helper: Recursively exclude all files in a folder from stats
   */
  async excludeFolderFromStats(book, folder, exclude) {
    for (const child of folder.children || []) {
      if (child.children !== void 0) {
        await this.excludeFolderFromStats(book, child, exclude);
      } else if (child.extension === "md") {
        try {
          await this.app.fileManager.processFrontMatter(child, (fm) => {
            fm.exclude_from_stats = exclude;
          });
        } catch (e) {
          console.warn("Failed to update frontmatter for", child.path, e);
        }
      }
    }
  }
};

// src/services/statsService.js
init_constants();
var StatsService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Count words in text
   */
  countWords(text) {
    if (!text)
      return 0;
    let content = text;
    const frontmatterRegex = /^---\s*\n[\s\S]*?\n---\s*\n/;
    content = content.replace(frontmatterRegex, "");
    content = content.replace(/^#{1,6}\s+/gm, "").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/\*([^*]+)\*/g, "$1").replace(/\_\_([^_]+)\_\_/g, "$1").replace(/\_([^_]+)\_/g, "$1").replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/^>\s+/gm, "");
    const parts = content.replace(/\n/g, " ").split(/\s+/).filter(Boolean);
    return parts.length;
  }
  /**
   * Get today's date key (YYYY-MM-DD)
   */
  getTodayKey() {
    return new Date().toISOString().slice(0, 10);
  }
  /**
   * Build sets of explicit include/exclude paths from the config tree
   * Includes children when a parent folder is included/excluded
   */
  buildStatsOverrideSets(configTree) {
    const excludedPaths = /* @__PURE__ */ new Set();
    const includedPaths = /* @__PURE__ */ new Set();
    const traverse = (nodes, parentExcluded = false, parentIncluded = false) => {
      for (const node of nodes) {
        const isExcluded = parentExcluded || node.exclude;
        const isIncluded = parentIncluded || node.include;
        if (node.type !== "group") {
          if (isExcluded) {
            excludedPaths.add(node.path);
          }
          if (isIncluded) {
            includedPaths.add(node.path);
          }
        }
        if (node.children) {
          traverse(node.children, isExcluded, isIncluded);
        }
      }
    };
    traverse(configTree || []);
    return { excludedPaths, includedPaths };
  }
  /**
   * Collect all markdown files recursively from a folder
   */
  collectMarkdownFiles(folder) {
    const files = [];
    const collect = (item) => {
      if (item.children) {
        for (const child of item.children) {
          collect(child);
        }
      } else if (item.extension === "md") {
        files.push(item);
      }
    };
    collect(folder);
    return files;
  }
  /**
   * Stats rules for built-in project types
   * Custom project types default to include-all
   * @param {string} projectType
   */
  getStatsRulesForProjectType(projectType) {
    const builtInTypes = new Set(Object.values(PROJECT_TYPES));
    if (!builtInTypes.has(projectType)) {
      return { includeAllByDefault: true, includePrefixes: [] };
    }
    switch (projectType) {
      case PROJECT_TYPES.SCRIPT:
      case PROJECT_TYPES.FILM:
        return { includeAllByDefault: true, includePrefixes: ["scene"] };
      case PROJECT_TYPES.ESSAY:
        return { includeAllByDefault: true, includePrefixes: ["manuscript"] };
      case PROJECT_TYPES.BOOK:
      default:
        return { includeAllByDefault: false, includePrefixes: ["chapter"] };
    }
  }
  /**
   * Decide if a file should count toward stats
   * Explicit exclude overrides explicit include; default rules apply last.
   * @param {TFile} file
   * @param {string} bookPath
   * @param {string} projectType
   * @param {{ includeAllByDefault: boolean, includePrefixes: string[] }} rules
   * @param {{ excludedPaths: Set<string>, includedPaths: Set<string> }} overrides
   */
  shouldCountFileForStats(file, bookPath, projectType, rules, overrides) {
    var _a, _b;
    const rel = file.path.replace(bookPath + "/", "");
    if (rel.startsWith("misc/"))
      return false;
    if ((_a = overrides == null ? void 0 : overrides.excludedPaths) == null ? void 0 : _a.has(rel))
      return false;
    if ((_b = overrides == null ? void 0 : overrides.includedPaths) == null ? void 0 : _b.has(rel))
      return true;
    if (rules == null ? void 0 : rules.includeAllByDefault)
      return true;
    const name = (file.basename || "").toLowerCase();
    const prefixes = (rules == null ? void 0 : rules.includePrefixes) || [];
    return prefixes.some((prefix) => name.startsWith(prefix));
  }
  /**
   * Filter files based on project type rules and overrides
   * 
   * @param {Array} files - Array of TFile objects
   * @param {string} bookPath - The book's root path
   * @param {string} projectType - The project type
   * @param {{ excludedPaths: Set<string>, includedPaths: Set<string> }} overrides
   */
  filterFilesByProjectType(files, bookPath, projectType, overrides) {
    const rules = this.getStatsRulesForProjectType(projectType);
    return files.filter((f) => {
      return this.shouldCountFileForStats(f, bookPath, projectType, rules, overrides);
    });
  }
  /**
   * Compute basic stats for a book and persist into book-config.json.stats
   */
  async computeAndSaveStatsForBook(book) {
    var _a, _b;
    try {
      const folder = this.app.vault.getAbstractFileByPath(book.path);
      if (!folder)
        return;
      let cfg = await this.configService.loadBookConfig(book) || {};
      const projectType = ((_a = cfg.basic) == null ? void 0 : _a.projectType) || PROJECT_TYPES.BOOK;
      const overrides = this.buildStatsOverrideSets(((_b = cfg.structure) == null ? void 0 : _b.tree) || []);
      const allMdFiles = this.collectMarkdownFiles(folder);
      const mdFiles = this.filterFilesByProjectType(allMdFiles, book.path, projectType, overrides);
      const perChapter = {};
      let total = 0;
      for (const f of mdFiles) {
        try {
          const content = await this.app.vault.read(f);
          const wc = this.countWords(content);
          perChapter[f.path.replace(book.path + "/", "")] = wc;
          total += wc;
        } catch (e) {
        }
      }
      cfg.basic = cfg.basic || { title: book.name };
      cfg.stats = cfg.stats || {};
      const today = this.getTodayKey();
      cfg.stats.daily_words = cfg.stats.daily_words || {};
      const previousTotal = Number(cfg.stats.total_words || 0);
      const delta = Math.max(0, total - previousTotal);
      if (delta > 0) {
        cfg.stats.daily_words[today] = (cfg.stats.daily_words[today] || 0) + delta;
      }
      cfg.stats.writing_days = Object.keys(cfg.stats.daily_words).length;
      const sumDaily = Object.values(cfg.stats.daily_words).reduce((a, b) => a + b, 0);
      cfg.stats.average_daily_words = cfg.stats.writing_days > 0 ? Math.round(sumDaily / cfg.stats.writing_days) : 0;
      cfg.stats.total_words = total;
      cfg.stats.per_chapter = perChapter;
      cfg.stats.last_writing_date = today;
      cfg.stats.last_modified = new Date().toISOString();
      const target = cfg.stats.target_total_words && Number(cfg.stats.target_total_words) || 0;
      cfg.stats.progress_by_words = target > 0 ? Math.round(total / target * 1e4) / 100 : 0;
      const totalCh = Object.keys(perChapter).length;
      const doneCh = Object.values(perChapter).filter((n) => n > 0).length;
      cfg.stats.progress_by_chapter = {
        completed: doneCh,
        total: totalCh,
        percent: totalCh > 0 ? Math.round(doneCh / totalCh * 1e4) / 100 : 0
      };
      await this.configService.saveBookConfig(book, { stats: cfg.stats });
      return cfg.stats;
    } catch (e) {
      console.warn("computeAndSaveStatsForBook failed", e);
      return null;
    }
  }
  /**
   * Sync chapter structure into stats baseline.
   * - Adds missing chapters with 0 words
   * - Removes deleted chapters from stats
   * - Removes excluded chapters from stats
   * DOES NOT recompute stats.
   */
  async syncChapterStatsBaseline(book) {
    var _a, _b;
    try {
      let cfg = await this.configService.loadBookConfig(book) || {};
      cfg.stats = cfg.stats || {};
      cfg.stats.per_chapter = cfg.stats.per_chapter || {};
      const projectType = ((_a = cfg.basic) == null ? void 0 : _a.projectType) || PROJECT_TYPES.BOOK;
      const overrides = this.buildStatsOverrideSets(((_b = cfg.structure) == null ? void 0 : _b.tree) || []);
      const folder = this.app.vault.getAbstractFileByPath(book.path);
      if (!folder)
        return;
      const allMdFiles = this.collectMarkdownFiles(folder);
      const mdFiles = this.filterFilesByProjectType(allMdFiles, book.path, projectType, overrides);
      const currentPaths = new Set(mdFiles.map((f) => f.path.replace(book.path + "/", "")));
      for (const relPath of currentPaths) {
        if (!(relPath in cfg.stats.per_chapter)) {
          cfg.stats.per_chapter[relPath] = 0;
        }
      }
      for (const storedPath of Object.keys(cfg.stats.per_chapter)) {
        if (!currentPaths.has(storedPath)) {
          delete cfg.stats.per_chapter[storedPath];
        }
      }
      cfg.stats.last_modified = new Date().toISOString();
      await this.configService.saveBookConfig(book, cfg);
    } catch (e) {
      console.warn("syncChapterStatsBaseline failed", e);
    }
  }
};

// src/services/bookService.js
var import_obsidian2 = require("obsidian");
init_constants();

// src/templates/project/book.js
function bookChapterTemplate({ title }) {
  return `---
projectType: book
---

`;
}

// src/templates/project/script.js
function scriptChapterTemplate({ title }) {
  return `---
projectType: script
cssclasses: md-screenplay
---

`;
}

// src/services/bookService.js
var BookService = class {
  constructor(app, configService) {
    this.app = app;
    this.configService = configService;
  }
  /**
   * Scan for all books in the base path
   */
  async scanBooks(basePath) {
    var _a;
    const base = this.app.vault.getAbstractFileByPath(basePath);
    if (!(base instanceof import_obsidian2.TFolder))
      return [];
    const booksIndex = [];
    const seenPaths = /* @__PURE__ */ new Set();
    for (const bookFolder of base.children) {
      if (!bookFolder || !bookFolder.path)
        continue;
      if (seenPaths.has(bookFolder.path))
        continue;
      seenPaths.add(bookFolder.path);
      if (!(bookFolder instanceof import_obsidian2.TFolder))
        continue;
      const book = {
        name: bookFolder.name,
        path: bookFolder.path,
        cover: null,
        volumes: []
      };
      try {
        const legacyMetaPath = `${bookFolder.path}/misc/metadata`;
        const legacyMetaAf = this.app.vault.getAbstractFileByPath(legacyMetaPath);
        if (legacyMetaAf) {
          await this.app.vault.delete(legacyMetaAf, true);
        }
      } catch (e) {
      }
      for (const child of bookFolder.children) {
        if (child instanceof import_obsidian2.TFolder && child.name === "misc") {
          continue;
        }
        if (child instanceof import_obsidian2.TFolder) {
          const volume = {
            name: child.name,
            path: child.path,
            chapters: [],
            collapsed: false
          };
          for (const f of child.children) {
            if (f instanceof import_obsidian2.TFile && f.extension === "md") {
              volume.chapters.push({
                name: f.basename,
                path: f.path
              });
            }
          }
          book.volumes.push(volume);
        }
      }
      try {
        const cfg = await this.configService.loadBookConfig({ path: book.path }) || {};
        const coverRel = (_a = cfg == null ? void 0 : cfg.basic) == null ? void 0 : _a.cover;
        if (coverRel) {
          const coverPath = `${book.path}/${coverRel}`;
          const coverFile = this.app.vault.getAbstractFileByPath(coverPath);
          if (coverFile instanceof import_obsidian2.TFile) {
            book.cover = coverFile;
          }
        } else {
          const coverFolderPath = `${book.path}/misc/cover`;
          const cf = this.app.vault.getAbstractFileByPath(coverFolderPath);
          if (cf && cf.children && cf.children.length > 0) {
            const first = cf.children.find((c) => c instanceof import_obsidian2.TFile);
            if (first)
              book.cover = first;
          }
        }
      } catch (e) {
      }
      booksIndex.push(book);
    }
    booksIndex.sort((a, b) => a.name.localeCompare(b.name));
    return booksIndex;
  }
  /**
   * Create a new book with structure from template
   */
  async createBook(basePath, name, projectType = "book", templateStructure = null) {
    if (!name)
      return;
    const path = `${basePath}/${name}`;
    if (await this.app.vault.adapter.exists(path))
      return;
    await this.app.vault.createFolder(path);
    const miscPath = `${path}/misc`;
    const coverPath = `${miscPath}/cover`;
    await this.app.vault.createFolder(miscPath);
    await this.app.vault.createFolder(coverPath);
    try {
      const bookConfigPath = `${path}/misc/project-config.json`;
      const now = new Date().toISOString();
      const defaultTree = templateStructure ? this.buildTreeFromTemplateStructure(templateStructure, "", now) : this.getDefaultTreeForProjectType(projectType, now);
      const defaultConfig = {
        basic: {
          title: name,
          author: [],
          subtitle: "",
          desc: "",
          uuid: `${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 10)}`,
          created_at: now,
          projectType
          // Save project type
        },
        structure: {
          tree: defaultTree
        },
        stats: {
          total_words: 0,
          target_total_words: 1e4,
          progress_by_words: 0,
          progress_by_chapter: 0,
          daily_words: {},
          writing_days: 0,
          average_daily_words: 0,
          last_writing_date: now,
          last_modified: now
        },
        export: {
          default_format: "pdf",
          template: "default",
          include_cover: true
        }
      };
      if (!this.app.vault.getAbstractFileByPath(bookConfigPath)) {
        await this.app.vault.create(bookConfigPath, JSON.stringify(defaultConfig, null, 2));
      }
    } catch (e) {
      console.warn("createBook: failed to create project-config.json in misc", e);
    }
    const bookFolder = this.app.vault.getAbstractFileByPath(path);
    if (bookFolder instanceof import_obsidian2.TFolder) {
      if (templateStructure && templateStructure.length > 0) {
        await this.createStructureFromTemplate(bookFolder, templateStructure, projectType);
      } else {
        if (projectType === PROJECT_TYPES.SCRIPT) {
          await this.ensureScriptStructure(bookFolder);
        } else if (projectType === PROJECT_TYPES.FILM) {
          await this.ensureFilmStructure(bookFolder);
        } else if (projectType === PROJECT_TYPES.ESSAY) {
          await this.ensureEssayStructure(bookFolder);
        } else {
          await this.ensureBookBaseStructure(bookFolder);
        }
      }
    }
  }
  /**
   * Build tree config from simple template structure
   */
  buildTreeFromTemplateStructure(structure, parentPath, now) {
    let order = 1;
    return structure.map((item) => {
      const itemPath = parentPath ? `${parentPath}/${item.title}` : item.title;
      const id = `${item.title.toLowerCase().replace(/\s+/g, "-")}-${Date.now()}-${Math.random().toString(36).substr(2, 5)}`;
      if (item.type === "folder") {
        const filePath = itemPath;
        const node = {
          id,
          title: item.title,
          type: "group",
          path: filePath,
          order: order++,
          default_status: "draft",
          is_expanded: false,
          created_at: now,
          last_modified: now,
          children: item.children ? this.buildTreeFromTemplateStructure(item.children, filePath, now) : []
        };
        if (item.icon)
          node.icon = item.icon;
        return node;
      } else if (item.type === "canvas") {
        const node = {
          id,
          title: item.title,
          type: "canvas",
          path: `${itemPath}.canvas`,
          order: order++,
          default_status: "draft",
          created_at: now,
          last_modified: now
        };
        if (item.icon)
          node.icon = item.icon;
        return node;
      } else {
        const node = {
          id,
          title: item.title,
          type: "file",
          path: `${itemPath}.md`,
          order: order++,
          default_status: "draft",
          created_at: now,
          last_modified: now
        };
        if (item.icon)
          node.icon = item.icon;
        return node;
      }
    });
  }
  /**
   * Create actual files and folders from template structure
   */
  async createStructureFromTemplate(bookFolder, structure, projectType) {
    const vault = this.app.vault;
    const createItems = async (items, parentPath) => {
      for (const item of items) {
        const itemPath = `${parentPath}/${item.title}`;
        if (item.type === "folder") {
          if (!vault.getAbstractFileByPath(itemPath)) {
            await vault.createFolder(itemPath);
          }
          if (item.children && item.children.length > 0) {
            await createItems(item.children, itemPath);
          }
        } else if (item.type === "canvas") {
          const canvasPath = `${itemPath}.canvas`;
          if (!vault.getAbstractFileByPath(canvasPath)) {
            await vault.create(canvasPath, '{"nodes":[],"edges":[]}');
          }
        } else {
          const filePath = `${itemPath}.md`;
          if (!vault.getAbstractFileByPath(filePath)) {
            const frontmatter = `---
projectType: ${projectType}
---

`;
            await vault.create(filePath, frontmatter);
          }
        }
      }
    };
    await createItems(structure, bookFolder.path);
  }
  /**
   * Get default tree structure for project type (legacy fallback)
   */
  getDefaultTreeForProjectType(projectType, now) {
    if (projectType === PROJECT_TYPES.SCRIPT) {
      return [
        {
          id: "series-framework",
          title: "Show Dossier",
          type: "group",
          path: "Show Dossier",
          order: 1,
          icon: "folder-open",
          default_status: "draft",
          is_expanded: false,
          created_at: now,
          last_modified: now,
          children: [
            { id: "concept", title: "Concept", type: "group", path: "Show Dossier/Concept", order: 1, icon: "lightbulb", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "structure", title: "Structure", type: "group", path: "Show Dossier/Structure", order: 2, icon: "list-tree", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "faces", title: "Faces", type: "group", path: "Show Dossier/Faces", order: 3, icon: "users", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "places", title: "Places", type: "group", path: "Show Dossier/Places", order: 4, icon: "map-pin", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "objects", title: "Objects", type: "group", path: "Show Dossier/Objects", order: 5, icon: "box", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
            { id: "documentation", title: "Documentation", type: "group", path: "Show Dossier/Documentation", order: 6, icon: "archive", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] }
          ]
        },
        { id: "episode1", title: "Episode 1", type: "group", path: "Episode 1", order: 2, icon: "clapperboard", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] }
      ];
    } else if (projectType === PROJECT_TYPES.FILM) {
      return [
        { id: "moodboard", title: "Moodboard", type: "canvas", path: "Moodboard.canvas", order: 1, icon: "layout-dashboard", default_status: "draft", created_at: now, last_modified: now },
        { id: "outline", title: "Outline", type: "file", path: "Outline.md", order: 2, icon: "list", default_status: "draft", created_at: now, last_modified: now },
        { id: "sequence1", title: "Sequence 1", type: "group", path: "Sequence 1", order: 3, icon: "film", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] }
      ];
    } else if (projectType === PROJECT_TYPES.ESSAY) {
      return [
        {
          id: "research",
          title: "Research",
          type: "group",
          path: "Research",
          order: 1,
          icon: "archive",
          default_status: "draft",
          is_expanded: false,
          created_at: now,
          last_modified: now,
          children: [
            { id: "document1", title: "Document 1", type: "file", path: "Research/Document 1.md", order: 1, icon: "file", default_status: "draft", created_at: now, last_modified: now }
          ]
        },
        { id: "outline", title: "Outline", type: "file", path: "Outline.md", order: 2, icon: "list", default_status: "draft", created_at: now, last_modified: now },
        { id: "manuscript", title: "Manuscript", type: "file", path: "Manuscript.md", order: 3, icon: "scroll-text", default_status: "draft", created_at: now, last_modified: now }
      ];
    } else {
      return [
        { id: "moodboard", title: "Moodboard", type: "canvas", path: "Moodboard.canvas", order: 1, icon: "layout-dashboard", default_status: "draft", created_at: now, last_modified: now },
        { id: "preface", title: "Preface", type: "file", path: "Preface.md", order: 2, icon: "file", default_status: "draft", created_at: now, last_modified: now },
        { id: "outline", title: "Outline", type: "file", path: "Outline.md", order: 3, icon: "list", default_status: "draft", created_at: now, last_modified: now },
        { id: "volume1", title: "Volume 1", type: "group", path: "Volume 1", order: 4, icon: "folder-open", default_status: "draft", is_expanded: false, created_at: now, last_modified: now, children: [] },
        { id: "afterword", title: "Afterword", type: "file", path: "Afterword.md", order: 5, icon: "file", default_status: "draft", created_at: now, last_modified: now }
      ];
    }
  }
  /**
   * Ensure essay project has minimal structure: Research folder, Document 1.md, Outline.md, Manuscript.md
   */
  async ensureEssayStructure(bookFolder) {
    const vault = this.app.vault;
    const researchPath = `${bookFolder.path}/Research`;
    if (!vault.getAbstractFileByPath(researchPath)) {
      await vault.createFolder(researchPath);
    }
    const document1Path = `${researchPath}/Document 1.md`;
    if (!vault.getAbstractFileByPath(document1Path)) {
      await vault.create(document1Path, `---
projectType: essay
---

`);
    }
    const outlinePath = `${bookFolder.path}/Outline.md`;
    if (!vault.getAbstractFileByPath(outlinePath)) {
      await vault.create(outlinePath, `---
projectType: essay
---

`);
    }
    const manuscriptPath = `${bookFolder.path}/Manuscript.md`;
    if (!vault.getAbstractFileByPath(manuscriptPath)) {
      await vault.create(manuscriptPath, `---
projectType: essay
---

`);
    }
  }
  /**
   * Ensure script project has screenplay-specific structure
   */
  async ensureScriptStructure(bookFolder) {
    const vault = this.app.vault;
    const biblePath = `${bookFolder.path}/Show Dossier`;
    if (!vault.getAbstractFileByPath(biblePath)) {
      await vault.createFolder(biblePath);
    }
    const conceptPath = `${biblePath}/Concept`;
    const structurePath = `${biblePath}/Structure`;
    const facesPath = `${biblePath}/Faces`;
    const placesPath = `${biblePath}/Places`;
    const objectsPath = `${biblePath}/Objects`;
    const documentationPath = `${biblePath}/Documentation`;
    if (!vault.getAbstractFileByPath(conceptPath)) {
      await vault.createFolder(conceptPath);
    }
    if (!vault.getAbstractFileByPath(structurePath)) {
      await vault.createFolder(structurePath);
    }
    if (!vault.getAbstractFileByPath(facesPath)) {
      await vault.createFolder(facesPath);
    }
    if (!vault.getAbstractFileByPath(placesPath)) {
      await vault.createFolder(placesPath);
    }
    if (!vault.getAbstractFileByPath(objectsPath)) {
      await vault.createFolder(objectsPath);
    }
    if (!vault.getAbstractFileByPath(documentationPath)) {
      await vault.createFolder(documentationPath);
    }
    const conceptFiles = ["Logline.md", "Synopsis.md"];
    for (const file of conceptFiles) {
      const filePath = `${conceptPath}/${file}`;
      if (!vault.getAbstractFileByPath(filePath)) {
        await vault.create(filePath, `---
projectType: script
---

`);
      }
    }
    const beatSheetPath = `${structurePath}/Beat Sheet.md`;
    if (!vault.getAbstractFileByPath(beatSheetPath)) {
      await vault.create(beatSheetPath, `---
projectType: script
---

`);
    }
    const researchPath = `${documentationPath}/Research.md`;
    if (!vault.getAbstractFileByPath(researchPath)) {
      await vault.create(researchPath, `---
projectType: script
---

`);
    }
    const character1Path = `${facesPath}/Character 1.md`;
    if (!vault.getAbstractFileByPath(character1Path)) {
      await vault.create(character1Path, `---
projectType: script
---

`);
    }
    const location1Path = `${placesPath}/Location 1.md`;
    if (!vault.getAbstractFileByPath(location1Path)) {
      await vault.create(location1Path, `---
projectType: script
---

`);
    }
    const prop1Path = `${objectsPath}/Prop 1.md`;
    if (!vault.getAbstractFileByPath(prop1Path)) {
      await vault.create(prop1Path, `---
projectType: script
---

`);
    }
    const episode1Path = `${bookFolder.path}/Episode 1`;
    if (!vault.getAbstractFileByPath(episode1Path)) {
      await vault.createFolder(episode1Path);
    }
    const scene1Path = `${episode1Path}/Scene 1.md`;
    if (!vault.getAbstractFileByPath(scene1Path)) {
      await vault.create(scene1Path, `---
projectType: script
---

`);
    }
  }
  /**
   * Ensure film project has simplified structure
   */
  async ensureFilmStructure(bookFolder) {
    const vault = this.app.vault;
    const moodboardPath = `${bookFolder.path}/Moodboard.canvas`;
    if (!vault.getAbstractFileByPath(moodboardPath)) {
      await vault.create(moodboardPath, '{"nodes":[],"edges":[]}');
    }
    const outlinePath = `${bookFolder.path}/Outline.md`;
    if (!vault.getAbstractFileByPath(outlinePath)) {
      await vault.create(outlinePath, `---
projectType: film
---

`);
    }
    const sequence1Path = `${bookFolder.path}/Sequence 1`;
    if (!vault.getAbstractFileByPath(sequence1Path)) {
      await vault.createFolder(sequence1Path);
    }
    const scene1Path = `${sequence1Path}/Scene 1.md`;
    if (!vault.getAbstractFileByPath(scene1Path)) {
      await vault.create(scene1Path, `---
projectType: film
---

`);
    }
  }
  /**
   * Ensure book has basic structure (Preface, Outline, etc.)
   */
  async ensureBookBaseStructure(bookFolder) {
    const vault = this.app.vault;
    const filesToCreate = ["Preface.md", "Outline.md", "Moodboard.canvas", "Afterword.md"];
    for (const file of filesToCreate) {
      const filePath = `${bookFolder.path}/${file}`;
      if (!vault.getAbstractFileByPath(filePath)) {
        await vault.create(filePath, "");
      }
    }
    const miscPath = `${bookFolder.path}/misc`;
    const coverPath = `${miscPath}/cover`;
    if (!vault.getAbstractFileByPath(miscPath)) {
      await vault.createFolder(miscPath);
    }
    if (!vault.getAbstractFileByPath(coverPath)) {
      await vault.createFolder(coverPath);
    }
    try {
      const bmPath = `${bookFolder.path}/misc/project-config.json`;
      const legacyPath = `${bookFolder.path}/misc/book-config.json`;
      const hasNew = vault.getAbstractFileByPath(bmPath);
      const hasLegacy = vault.getAbstractFileByPath(legacyPath);
      if (!hasNew && !hasLegacy) {
        const now = new Date().toISOString();
        const defaultConfig = {
          basic: {
            title: bookFolder.name,
            author: [],
            subtitle: "",
            desc: "",
            uuid: `${Date.now().toString(16)}-${Math.random().toString(16).slice(2, 10)}`,
            created_at: now
          },
          structure: { tree: [] },
          stats: {
            total_words: 0,
            target_total_words: 1e4,
            progress_by_words: 0,
            progress_by_chapter: 0,
            daily_words: {},
            writing_days: 0,
            average_daily_words: 0,
            last_writing_date: now,
            last_modified: now
          },
          export: {
            default_format: "pdf",
            template: "default",
            include_cover: true
          }
        };
        await vault.create(bmPath, JSON.stringify(defaultConfig, null, 2));
      }
    } catch (e) {
      console.warn("ensureBookBaseStructure: failed to create project-config.json in misc", e);
    }
  }
  /**
   * Create a new volume (folder) in a book
   */
  async createVolume(book, name) {
    if (!name)
      return;
    const path = `${book.path}/${name}`;
    if (await this.app.vault.adapter.exists(path))
      return;
    await this.app.vault.createFolder(path);
  }
  /**
   * Create a new chapter (markdown file) in a volume
   */
  async createChapter(volume, name, projectType = "book") {
    if (!name)
      return;
    const path = `${volume.path}/${name}.md`;
    if (await this.app.vault.adapter.exists(path))
      return;
    const template = projectType === PROJECT_TYPES.SCRIPT ? scriptChapterTemplate : bookChapterTemplate;
    const content = template({ title: name });
    await this.app.vault.create(path, content);
  }
  /**
   * Check if a file is a volume folder
   */
  isVolumeFolder(file, booksIndex) {
    try {
      return booksIndex.some(
        (b) => b.volumes.some((v) => v.path === file.path)
      );
    } catch (e) {
      return false;
    }
  }
  /**
   * Check if a file is a chapter file
   */
  isChapterFile(file, booksIndex) {
    try {
      return booksIndex.some(
        (b) => b.volumes.some(
          (v) => v.chapters.some((c) => c.path === file.path)
        )
      );
    } catch (e) {
      return false;
    }
  }
};

// src/main.js
init_constants();

// src/views/folioView.js
var import_obsidian4 = require("obsidian");
init_constants();
function getProjectTypeIcon3(plugin, projectType) {
  var _a;
  const templates = ((_a = plugin.settings) == null ? void 0 : _a.projectTemplates) || [];
  const template = templates.find((t) => t.id === projectType);
  if (template == null ? void 0 : template.icon)
    return template.icon;
  if (projectType === PROJECT_TYPES.BOOK)
    return "book";
  if (projectType === PROJECT_TYPES.SCRIPT)
    return "tv";
  if (projectType === PROJECT_TYPES.FILM)
    return "clapperboard";
  if (projectType === PROJECT_TYPES.ESSAY)
    return "newspaper";
  return "book";
}
var FolioView = class extends import_obsidian4.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this._isRendering = false;
    this._renderCounter = 0;
  }
  getViewType() {
    return VIEW_TYPE;
  }
  getDisplayText() {
    return "Folio";
  }
  getIcon() {
    return "book-open";
  }
  async onOpen() {
    this.render();
  }
  onClose() {
    if (this.plugin && this.plugin.novelistLeaf === this.leaf) {
      this.plugin.novelistLeaf = null;
    }
  }
  clearView() {
    try {
      this.contentEl.empty();
    } catch (e) {
    }
    this._isRendering = false;
  }
  // Render a filesystem-backed editorial tree for a book folder (Obsidian-safe)
  // Now with Book-Smith style drag & drop support
  // Get custom icon for specific folder/file names
  getCustomIcon(title, isExpanded = false, nodeType = "file") {
    const lowerTitle = title.toLowerCase();
    if (lowerTitle === "outline")
      return "list";
    if (lowerTitle === "moodboard")
      return "layout-dashboard";
    if (lowerTitle === "manuscript")
      return "scroll-text";
    if (lowerTitle === "preface" || lowerTitle === "afterword")
      return "file";
    if (lowerTitle === "logline" || lowerTitle === "synopsis" || lowerTitle === "beat sheet")
      return "file";
    if (lowerTitle === "document 1" || lowerTitle.startsWith("document "))
      return "file";
    if (lowerTitle === "chapter 1" || lowerTitle.startsWith("chapter "))
      return "file";
    if (lowerTitle === "scene 1" || lowerTitle.startsWith("scene "))
      return "file";
    if (lowerTitle === "show dossier")
      return "folder-open";
    if (lowerTitle === "episode 1" || lowerTitle.startsWith("episode "))
      return "clapperboard";
    if (lowerTitle === "sequence 1" || lowerTitle.startsWith("sequence "))
      return "film";
    if (lowerTitle === "volume 1" || lowerTitle.startsWith("volume "))
      return "folder-open";
    if (lowerTitle === "concept")
      return "lightbulb";
    if (lowerTitle === "faces")
      return "users";
    if (lowerTitle === "places")
      return "map-pin";
    if (lowerTitle === "objects")
      return "box";
    if (lowerTitle === "structure")
      return "list-tree";
    if (lowerTitle === "documentation" || lowerTitle === "research")
      return "archive";
    if (nodeType === "file")
      return "file";
    return isExpanded ? "folder-open" : "folder";
  }
  async renderBookTree(container, bookFolder) {
    container.empty();
    const folder = bookFolder instanceof import_obsidian4.TFolder ? bookFolder : this.plugin.app.vault.getAbstractFileByPath(
      (bookFolder == null ? void 0 : bookFolder.path) || bookFolder
    );
    if (!(folder instanceof import_obsidian4.TFolder)) {
      console.error("Invalid book folder", bookFolder);
      return;
    }
    const book = this.plugin.activeBook;
    if (!book)
      return;
    let configTree = [];
    let useConfigTree = false;
    try {
      configTree = await this.plugin.buildTreeFromFilesystem(folder);
      if (configTree.length > 0) {
        const cfg = await this.plugin.loadBookConfig(book) || {};
        if (!cfg.structure)
          cfg.structure = {};
        cfg.structure.tree = configTree;
        await this.plugin.saveBookConfig(book, cfg);
        useConfigTree = true;
      }
    } catch (e) {
      console.warn("Failed to build/sync tree from filesystem", e);
    }
    let draggedElement = null;
    let draggedNodeId = null;
    const setupDragEvents = (element, nodeId, nodeType) => {
      element.setAttribute("draggable", "true");
      element.addEventListener("dragstart", (e) => {
        draggedElement = element;
        draggedNodeId = nodeId;
        element.classList.add("folio-dragging");
        e.dataTransfer.effectAllowed = "move";
        e.dataTransfer.setData("text/plain", nodeId);
      });
      element.addEventListener("dragend", (e) => {
        element.classList.remove("folio-dragging");
        document.querySelectorAll(".folio-dragover, .folio-dragover-before, .folio-dragover-after, .folio-dragover-inside").forEach((el) => el.classList.remove("folio-dragover", "folio-dragover-before", "folio-dragover-after", "folio-dragover-inside"));
        draggedElement = null;
        draggedNodeId = null;
      });
      element.addEventListener("dragover", (e) => {
        if (!draggedElement || draggedElement === element)
          return;
        e.preventDefault();
        e.stopPropagation();
        const rect = element.getBoundingClientRect();
        const mouseY = e.clientY;
        const elementTop = rect.top;
        const elementBottom = rect.bottom;
        const elementHeight = rect.height;
        element.classList.remove("folio-dragover-before", "folio-dragover-after", "folio-dragover-inside");
        if (nodeType === "group") {
          const topQuarter = elementTop + elementHeight / 4;
          const bottomHalf = elementTop + elementHeight / 2;
          if (mouseY < topQuarter) {
            element.classList.add("folio-dragover-before");
            e.dataTransfer.dropEffect = "move";
          } else if (mouseY > bottomHalf) {
            element.classList.add("folio-dragover-after");
            e.dataTransfer.dropEffect = "move";
          } else {
            element.classList.add("folio-dragover-inside");
            e.dataTransfer.dropEffect = "move";
          }
        } else {
          const middle = elementTop + elementHeight / 2;
          if (mouseY < middle) {
            element.classList.add("folio-dragover-before");
          } else {
            element.classList.add("folio-dragover-after");
          }
          e.dataTransfer.dropEffect = "move";
        }
      });
      element.addEventListener("dragleave", (e) => {
        element.classList.remove("folio-dragover-before", "folio-dragover-after", "folio-dragover-inside");
      });
      element.addEventListener("drop", async (e) => {
        e.preventDefault();
        e.stopPropagation();
        if (!draggedNodeId || draggedElement === element)
          return;
        const rect = element.getBoundingClientRect();
        const mouseY = e.clientY;
        const elementTop = rect.top;
        const elementBottom = rect.bottom;
        const elementHeight = rect.height;
        let position = "after";
        if (nodeType === "group") {
          const topQuarter = elementTop + elementHeight / 4;
          const bottomHalf = elementTop + elementHeight / 2;
          if (mouseY < topQuarter) {
            position = "before";
          } else if (mouseY > bottomHalf) {
            position = "after";
          } else {
            position = "inside";
          }
        } else {
          const middle = elementTop + elementHeight / 2;
          position = mouseY < middle ? "before" : "after";
        }
        const success = await this.plugin.reorderTreeNodes(book, draggedNodeId, nodeId, position);
        if (success) {
          this.plugin.rerenderViews();
        }
        element.classList.remove("folio-dragover-before", "folio-dragover-after", "folio-dragover-inside");
      });
    };
    const renderNodeFromConfig = (node, parentContainer) => {
      const fullPath = `${book.path}/${node.path}`;
      const vaultItem = this.plugin.app.vault.getAbstractFileByPath(fullPath);
      if (!vaultItem) {
        console.warn("Vault item not found:", fullPath, "for node:", node);
        return;
      }
      if (node.type === "group") {
        const folderRow = parentContainer.createDiv("folio-tree-folder tree-item is-folder");
        folderRow.dataset.path = fullPath;
        folderRow.dataset.nodeId = node.id;
        const collapse = folderRow.createSpan({ cls: "folio-tree-toggle" });
        collapse.classList.toggle("is-open", this.plugin.expandedFolders.has(fullPath));
        const folderIcon = folderRow.createSpan({ cls: "folio-tree-icon folder-icon" });
        try {
          const isExpanded = this.plugin.expandedFolders.has(fullPath);
          const iconName = node.icon || this.getCustomIcon(node.title, isExpanded, "folder");
          (0, import_obsidian4.setIcon)(folderIcon, iconName);
          (0, import_obsidian4.setIcon)(collapse, isExpanded ? "chevron-down" : "chevron-right");
        } catch (e) {
        }
        const titleSpan = folderRow.createSpan({ text: node.title, cls: "folio-tree-label" });
        if (node.exclude) {
          titleSpan.classList.add("exclude-from-stats");
        }
        setupDragEvents(folderRow, node.id, "group");
        try {
          folderRow.addEventListener("contextmenu", (evt) => {
            evt.preventDefault();
            this.plugin.openVolumeMenu(evt, vaultItem, false, node);
          });
        } catch (e) {
        }
        const childrenEl = parentContainer.createDiv("folio-tree-children");
        childrenEl.classList.toggle("is-open", this.plugin.expandedFolders.has(fullPath));
        if (!this.plugin.expandedFolders.has(fullPath))
          childrenEl.style.display = "none";
        collapse.onclick = (e) => {
          e.stopPropagation();
          const isHidden = childrenEl.style.display === "none";
          childrenEl.style.display = isHidden ? "" : "none";
          collapse.classList.toggle("is-open", isHidden);
          childrenEl.classList.toggle("is-open", isHidden);
          if (isHidden)
            this.plugin.expandedFolders.add(fullPath);
          else
            this.plugin.expandedFolders.delete(fullPath);
          try {
            const iconName = node.icon || this.getCustomIcon(node.title, isHidden, "folder");
            (0, import_obsidian4.setIcon)(folderIcon, iconName);
            (0, import_obsidian4.setIcon)(collapse, isHidden ? "chevron-down" : "chevron-right");
          } catch (e2) {
          }
        };
        if (node.children && node.children.length > 0) {
          const sortedChildren = [...node.children].sort((a, b) => a.order - b.order);
          sortedChildren.forEach((child) => renderNodeFromConfig(child, childrenEl));
        }
      } else {
        const fileRow = parentContainer.createDiv("folio-tree-file tree-item is-file");
        fileRow.dataset.path = fullPath;
        fileRow.dataset.nodeId = node.id;
        const icon = fileRow.createSpan({ cls: "folio-tree-icon" });
        try {
          const defaultIcon = node.type === "canvas" ? "layout-dashboard" : this.getCustomIcon(node.title, false, "file");
          (0, import_obsidian4.setIcon)(icon, node.icon || defaultIcon);
        } catch (e) {
        }
        const label = fileRow.createSpan({ text: node.title, cls: "folio-tree-label" });
        if (node.exclude) {
          label.classList.add("exclude-from-stats");
        }
        if (node.completed) {
          label.classList.add("is-done");
        }
        fileRow.onclick = (e) => {
          e.stopPropagation();
          this.plugin.app.workspace.openLinkText(fullPath, "", false);
        };
        setupDragEvents(fileRow, node.id, "file");
        try {
          fileRow.addEventListener("contextmenu", (evt) => {
            evt.preventDefault();
            this.plugin.openChapterContextMenu(evt, vaultItem, node);
          });
        } catch (e) {
        }
      }
    };
    if (useConfigTree && configTree.length > 0) {
      console.log("Rendering tree with", configTree.length, "root nodes");
      const sortedTree = [...configTree].sort((a, b) => a.order - b.order);
      sortedTree.forEach((node) => renderNodeFromConfig(node, container));
    } else {
      console.warn("No config tree to render, useConfigTree:", useConfigTree, "length:", configTree.length);
    }
    try {
      container.addEventListener("contextmenu", (evt) => {
        try {
          if (evt.target && evt.target.closest && evt.target.closest(".tree-item"))
            return;
          evt.preventDefault();
          this.plugin.openVolumeMenu(evt, folder, true);
        } catch (e) {
        }
      });
    } catch (e) {
    }
  }
  async renderStats(container, book) {
    try {
      if (!book || !this.plugin.loadBookConfig)
        return;
      let cfg = {};
      try {
        cfg = await this.plugin.loadBookConfig(book) || {};
      } catch (e) {
      }
      try {
        if (this.plugin && this.plugin.settings && this.plugin.settings.verboseLogs)
          console.debug("Folio.renderStats loaded cfg", book && book.path, { basic: cfg.basic, stats: cfg.stats });
      } catch (e) {
      }
      const stats = cfg.stats || {};
      if (!stats)
        return;
      const pad = (n) => typeof n === "number" ? n : 0;
      const formatTarget = (n) => {
        if (!n)
          return "\u2014";
        const num = Number(n) || 0;
        if (num >= 1e3) {
          const k = num / 1e3;
          return k % 1 === 0 ? `${Math.round(k)}K` : `${Math.round(k * 10) / 10}K`;
        }
        return String(num);
      };
      const todayKey = new Date().toISOString().slice(0, 10);
      const dailyWords = stats.daily_words || {};
      const todayCount = pad(dailyWords[todayKey]) || 0;
      const totalWords = pad(stats.total_words) || 0;
      const targetWords = pad(stats.target_total_words) || 0;
      const completionPct = typeof stats.progress_by_words !== "undefined" && stats.progress_by_words !== null ? Number(stats.progress_by_words) : targetWords > 0 ? Math.round(totalWords / targetWords * 1e4) / 100 : 0;
      const writingDays = typeof stats.writing_days === "number" ? stats.writing_days : stats.daily_words ? Object.keys(stats.daily_words).length : 0;
      const dailyAvg = typeof stats.average_daily_words === "number" ? stats.average_daily_words : writingDays > 0 ? Math.round(totalWords / writingDays) : 0;
      container.empty();
      const row = (iconName, label, value, extra) => {
        const r = container.createDiv("folio-stat-row");
        const left = r.createDiv({ cls: "folio-stat-left" });
        const iconSpan = left.createSpan({ cls: "folio-stat-icon" });
        try {
          if (Array.isArray(iconName)) {
            iconName.forEach((n, i) => {
              const s = iconSpan.createSpan({ cls: `folio-stat-icon-part part-${i}` });
              try {
                (0, import_obsidian4.setIcon)(s, n);
              } catch (e) {
              }
            });
          } else {
            try {
              (0, import_obsidian4.setIcon)(iconSpan, iconName);
            } catch (e) {
            }
          }
        } catch (e) {
        }
        left.createSpan({ text: label, cls: "folio-stat-label" });
        r.createSpan({ text: value, cls: "folio-stat-value" });
        if (extra && typeof extra === "function")
          extra(r);
      };
      row("pencil", "Today", `${todayCount} words`);
      row("file", "Total words", `${totalWords} / ${formatTarget(targetWords)}`);
      row("target", "Completion", `${(Math.round(completionPct * 100) / 100).toFixed(2)}%`);
      row("clock", "Writing days", `${writingDays} days`);
      row("calendar-clock", "Daily average", `${dailyAvg} words`);
    } catch (e) {
      console.warn("renderStats failed", e);
    }
  }
  async render() {
    const { NewBookModal: NewBookModal2 } = await Promise.resolve().then(() => (init_newBookModal(), newBookModal_exports));
    const { SwitchBookModal: SwitchBookModal2 } = await Promise.resolve().then(() => (init_switchBookModal(), switchBookModal_exports));
    const { ManageBooksModal: ManageBooksModal2 } = await Promise.resolve().then(() => (init_manageBooksModal(), manageBooksModal_exports));
    const { HelpModal: HelpModal2 } = await Promise.resolve().then(() => (init_helpModal(), helpModal_exports));
    const { TextInputModal: TextInputModal2 } = await Promise.resolve().then(() => (init_textInputModal(), textInputModal_exports));
    const token = ++this._renderCounter;
    this._isRendering = true;
    try {
      const el = this.contentEl;
      el.empty();
      if (this._renderCounter !== token)
        return;
      el.addClass("folio-view");
      const topBar = el.createDiv("folio-topbar");
      const newBtn = topBar.createEl("button", { cls: "folio-top-btn" });
      const newIcon = newBtn.createSpan({ cls: "folio-top-icon" });
      try {
        (0, import_obsidian4.setIcon)(newIcon, "edit");
      } catch (e) {
      }
      newBtn.createSpan({ text: "New Project", cls: "folio-top-label" });
      const switchBtn = topBar.createEl("button", { cls: "folio-top-btn" });
      const switchIcon = switchBtn.createSpan({ cls: "folio-top-icon" });
      try {
        (0, import_obsidian4.setIcon)(switchIcon, "repeat");
      } catch (e) {
      }
      switchBtn.createSpan({ text: "Switch", cls: "folio-top-label" });
      const manageBtn = topBar.createEl("button", { cls: "folio-top-btn" });
      const manageIcon = manageBtn.createSpan({ cls: "folio-top-icon" });
      try {
        (0, import_obsidian4.setIcon)(manageIcon, "library");
      } catch (e) {
      }
      manageBtn.createSpan({ text: "Manage", cls: "folio-top-label" });
      const helpBtn = topBar.createEl("button", { cls: "folio-help-btn" });
      const helpIcon = helpBtn.createSpan({ cls: "folio-help-icon" });
      try {
        (0, import_obsidian4.setIcon)(helpIcon, "help");
      } catch (e) {
      }
      newBtn.onclick = () => {
        new NewBookModal2(this.plugin).open();
      };
      switchBtn.onclick = () => {
        new SwitchBookModal2(this.plugin).open();
      };
      manageBtn.onclick = () => {
        new ManageBooksModal2(this.plugin).open();
      };
      helpBtn.onclick = () => {
        new HelpModal2(this.plugin).open();
      };
      const book = this.plugin.activeBook;
      if (!book) {
        const headerEl2 = el.createDiv("folio-book-header");
        const coverCol2 = headerEl2.createDiv("folio-book-cover-col");
        const coverEl2 = coverCol2.createDiv("folio-book-cover");
        coverEl2.addClass("folio-book-cover-placeholder");
        try {
          const iconEl = coverEl2.createDiv({ cls: "folio-book-cover-icon" });
          (0, import_obsidian4.setIcon)(iconEl, "square-plus");
        } catch (e) {
        }
        const titleBlock2 = headerEl2.createDiv("folio-book-title-block");
        titleBlock2.createEl("div", { cls: "folio-book-title", text: "No active project" });
        titleBlock2.createEl("div", { cls: "folio-book-subtitle", text: "(Select or create a project)" });
        const metaBlock2 = el.createDiv("folio-book-meta folio-book-info");
        const authorRow2 = metaBlock2.createDiv("folio-meta-row");
        authorRow2.createEl("div", { text: "Author", cls: "folio-meta-label" });
        authorRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value" });
        const descRow2 = metaBlock2.createDiv("folio-meta-row");
        descRow2.createEl("div", { text: "Description", cls: "folio-meta-label" });
        descRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value folio-meta-desc" });
        const structureEl2 = el.createDiv("folio-structure");
        structureEl2.createEl("p", { text: "(No project selected)" });
        try {
          const statsEl = el.createDiv("folio-stats");
          const makeRow = (label, value) => {
            const r = statsEl.createDiv("folio-stat-row");
            const left = r.createDiv({ cls: "folio-stat-left" });
            left.createSpan({ cls: "folio-stat-icon" });
            left.createSpan({ text: label, cls: "folio-stat-label" });
            r.createSpan({ text: value, cls: "folio-stat-value" });
          };
          makeRow("Today", "\u2014");
          makeRow("Total words", "\u2014 / \u2014");
          makeRow("Completion", "\u2014");
          makeRow("Writing days", "\u2014");
          makeRow("Daily average", "\u2014");
        } catch (e) {
        }
        return;
      }
      const bookFolderCheck = this.plugin.app.vault.getAbstractFileByPath(book.path);
      if (!bookFolderCheck || !(bookFolderCheck instanceof import_obsidian4.TFolder)) {
        const headerEl2 = el.createDiv("folio-book-header");
        const coverCol2 = headerEl2.createDiv("folio-book-cover-col");
        const coverEl2 = coverCol2.createDiv("folio-book-cover");
        coverEl2.addClass("folio-book-cover-placeholder");
        try {
          const iconEl = coverEl2.createDiv({ cls: "folio-book-cover-icon" });
          (0, import_obsidian4.setIcon)(iconEl, "square-plus");
        } catch (e) {
        }
        const titleBlock2 = headerEl2.createDiv("folio-book-title-block");
        titleBlock2.createEl("div", { cls: "folio-book-title", text: "No active project" });
        titleBlock2.createEl("div", { cls: "folio-book-subtitle", text: "(Project folder missing)" });
        const metaBlock2 = el.createDiv("folio-book-meta folio-book-info");
        const authorRow2 = metaBlock2.createDiv("folio-meta-row");
        authorRow2.createEl("div", { text: "Author", cls: "folio-meta-label" });
        authorRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value" });
        const descRow2 = metaBlock2.createDiv("folio-meta-row");
        descRow2.createEl("div", { text: "Description", cls: "folio-meta-label" });
        descRow2.createEl("div", { text: "\u2014", cls: "folio-meta-value folio-meta-desc" });
        const structureEl2 = el.createDiv("folio-structure");
        structureEl2.createEl("p", { text: "(Book folder missing on disk)" });
        try {
          const statsEl = el.createDiv("folio-stats");
          const makeRow = (label, value) => {
            const r = statsEl.createDiv("folio-stat-row");
            const left = r.createDiv({ cls: "folio-stat-left" });
            left.createSpan({ cls: "folio-stat-icon" });
            left.createSpan({ text: label, cls: "folio-stat-label" });
            r.createSpan({ text: value, cls: "folio-stat-value" });
          };
          makeRow("Today", "\u2014");
          makeRow("Total words", "\u2014 / \u2014");
          makeRow("Completion", "\u2014");
          makeRow("Writing days", "\u2014");
          makeRow("Daily average", "\u2014");
        } catch (e) {
        }
        return;
      }
      let metadata = {};
      try {
        if (this.plugin.loadBookMeta)
          metadata = await this.plugin.loadBookMeta(book) || {};
      } catch (e) {
        metadata = {};
      }
      if (this._renderCounter !== token)
        return;
      const headerEl = el.createDiv("folio-book-header");
      const coverCol = headerEl.createDiv("folio-book-cover-col");
      const coverEl = coverCol.createDiv("folio-book-cover");
      const coverPath = book.cover ? this.plugin.app.vault.getResourcePath(book.cover) : null;
      if (coverPath) {
        coverEl.style.backgroundImage = `url("${coverPath}")`;
      } else {
        try {
          coverEl.addClass("folio-book-cover-placeholder");
          const iconEl = coverEl.createDiv({ cls: "folio-book-cover-icon" });
          const projectType = (metadata == null ? void 0 : metadata.projectType) || PROJECT_TYPES.BOOK;
          const iconName = getProjectTypeIcon3(this.plugin, projectType);
          (0, import_obsidian4.setIcon)(iconEl, iconName);
        } catch (e) {
        }
      }
      const titleBlock = headerEl.createDiv("folio-book-title-block");
      titleBlock.createEl("div", {
        cls: "folio-book-title",
        text: metadata && metadata.title || book.name || "Untitled book"
      });
      const subtitleText = metadata && metadata.subtitle || "";
      if (subtitleText) {
        titleBlock.createEl("div", {
          cls: "folio-book-subtitle",
          text: subtitleText
        });
      }
      const metaBlock = el.createDiv("folio-book-meta folio-book-info");
      const authorVal = metadata && metadata.author || "";
      const descVal = metadata && metadata.description || "";
      const authorRow = metaBlock.createDiv("folio-meta-row");
      authorRow.createEl("div", { text: "Author", cls: "folio-meta-label" });
      authorRow.createEl("div", { text: authorVal || "\u2014", cls: "folio-meta-value" });
      const descRow = metaBlock.createDiv("folio-meta-row");
      descRow.createEl("div", { text: "Description", cls: "folio-meta-label" });
      descRow.createEl("div", { text: descVal || "\u2014", cls: "folio-meta-value folio-meta-desc" });
      if (this._renderCounter !== token)
        return;
      const structureEl = el.createDiv("folio-structure");
      const bookFolder = this.plugin.app.vault.getAbstractFileByPath(book.path);
      if (this._renderCounter !== token)
        return;
      if (bookFolder instanceof import_obsidian4.TFolder) {
        await this.renderBookTree(structureEl, bookFolder);
      } else {
        structureEl.createEl("p", { text: "(No folder found on disk)" });
      }
      try {
        structureEl.addEventListener("contextmenu", (evt) => {
          try {
            const item = evt.target && evt.target.closest && evt.target.closest(".tree-item");
            if (item)
              return;
            evt.preventDefault();
            const menu = new import_obsidian4.Menu(this.plugin.app);
            menu.addItem(
              (it) => it.setTitle("New root canvas").setIcon("layout-dashboard").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New root canvas",
                  placeholder: "Canvas name (without .canvas)",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const raw = (value || "").trim();
                      if (!raw)
                        return;
                      const base = raw.endsWith(".canvas") ? raw.slice(0, -7) : raw;
                      let name = `${base}.canvas`;
                      let i = 1;
                      while (this.plugin.app.vault.getAbstractFileByPath(`${book.path}/${name}`)) {
                        name = `${base} ${i}.canvas`;
                        i += 1;
                      }
                      await this.plugin.app.vault.create(`${book.path}/${name}`, "");
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.addItem(
              (it) => it.setTitle("New root file").setIcon("file-plus").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New root file",
                  placeholder: "File name (without .md)",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const name = (value || "").trim();
                      if (!name)
                        return;
                      const fileName = name.endsWith(".md") ? name : `${name}.md`;
                      const path = `${book.path}/${fileName}`;
                      if (!this.plugin.app.vault.getAbstractFileByPath(path)) {
                        await this.plugin.app.vault.create(path, "");
                      }
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.addItem(
              (it) => it.setTitle("New volume").setIcon("folder-plus").onClick(() => {
                const modal = new TextInputModal2(this.plugin.app, {
                  title: "New volume",
                  placeholder: "Volume name",
                  cta: "Create",
                  onSubmit: async (value) => {
                    try {
                      const name = (value || "").trim();
                      if (!name)
                        return;
                      await this.plugin.createVolume(book, name);
                      await this.plugin.refresh();
                      this.plugin.rerenderViews();
                    } catch (e) {
                      console.error(e);
                    }
                  }
                });
                modal.open();
              })
            );
            menu.showAtMouseEvent(evt);
          } catch (e) {
            console.error(e);
          }
        });
      } catch (e) {
      }
      if (this._renderCounter !== token)
        return;
      this.statsEl = el.createDiv("folio-stats");
      await this.renderStats(this.statsEl, book);
      try {
        if (this.statsEl)
          this.statsEl.addEventListener("contextmenu", (evt) => {
            try {
              evt.preventDefault();
              const row = evt.target && evt.target.closest && evt.target.closest(".folio-stat-row");
              if (row)
                return;
              const menu = new import_obsidian4.Menu(this.plugin.app);
              menu.addItem(
                (it) => it.setTitle("New root canvas").setIcon("layout-dashboard").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New root canvas",
                    placeholder: "Canvas name (without .canvas)",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const raw = (value || "").trim();
                        if (!raw)
                          return;
                        const base = raw.endsWith(".canvas") ? raw.slice(0, -7) : raw;
                        let name = `${base}.canvas`;
                        let i = 1;
                        while (this.plugin.app.vault.getAbstractFileByPath(`${book.path}/${name}`)) {
                          name = `${base} ${i}.canvas`;
                          i += 1;
                        }
                        await this.plugin.app.vault.create(`${book.path}/${name}`, "");
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.addItem(
                (it) => it.setTitle("New root file").setIcon("file-plus").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New root file",
                    placeholder: "File name (without .md)",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const name = (value || "").trim();
                        if (!name)
                          return;
                        const fileName = name.endsWith(".md") ? name : `${name}.md`;
                        const path = `${book.path}/${fileName}`;
                        if (!this.plugin.app.vault.getAbstractFileByPath(path)) {
                          await this.plugin.app.vault.create(path, "");
                        }
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.addItem(
                (it) => it.setTitle("New volume").setIcon("folder-plus").onClick(() => {
                  const modal = new TextInputModal2(this.plugin.app, {
                    title: "New volume",
                    placeholder: "Volume name",
                    cta: "Create",
                    onSubmit: async (value) => {
                      try {
                        const name = (value || "").trim();
                        if (!name)
                          return;
                        await this.plugin.createVolume(book, name);
                        await this.plugin.refresh();
                        this.plugin.rerenderViews();
                      } catch (e) {
                        console.error(e);
                      }
                    }
                  });
                  modal.open();
                })
              );
              menu.showAtMouseEvent(evt);
            } catch (e) {
              console.error(e);
            }
          });
      } catch (e) {
      }
    } finally {
      if (this._renderCounter === token) {
        this._isRendering = false;
      }
    }
  }
};

// src/views/writerToolsView.js
var import_obsidian6 = require("obsidian");

// src/modals/focusModeStatsModal.js
var import_obsidian5 = require("obsidian");
var FocusModeStatsModal = class extends import_obsidian5.Modal {
  constructor(plugin, project) {
    super(plugin.app);
    this.plugin = plugin;
    this.project = project;
  }
  setProject(project) {
    this.project = project;
  }
  async onOpen() {
    await this.render();
  }
  async refresh() {
    await this.render();
  }
  formatDate(value) {
    if (!value)
      return "\u2014";
    const date = new Date(value);
    if (Number.isNaN(date.getTime()))
      return "\u2014";
    return date.toLocaleDateString();
  }
  formatValue(value) {
    if (value === void 0 || value === null || value === "")
      return "\u2014";
    return value;
  }
  buildPieChart(container, title, slices, options = {}) {
    const size = options.size || 140;
    const radius = size / 2;
    const chartWrap = container.createDiv({ cls: "focus-mode-chart" });
    chartWrap.createDiv({ cls: "focus-mode-chart-title", text: title });
    const resolveColor = (value) => {
      if (!value)
        return value;
      const match = value.match(/^var\((--[^)]+)\)/);
      if (!match)
        return value;
      const varName = match[1];
      const computed = getComputedStyle(this.modalEl || document.body).getPropertyValue(varName).trim();
      return computed || value;
    };
    const resolvedSlices = slices.map((slice) => ({
      ...slice,
      color: resolveColor(slice.color)
    }));
    const borderColor = resolveColor("var(--background-modifier-border)");
    const total = resolvedSlices.reduce((sum, slice) => sum + slice.value, 0);
    if (!total) {
      const empty = chartWrap.createDiv({ cls: "focus-mode-chart-empty", text: "No data to display" });
      empty.setAttribute("aria-label", `${title}: no data`);
      return;
    }
    const svgNS = "http://www.w3.org/2000/svg";
    const svg = document.createElementNS(svgNS, "svg");
    svg.setAttribute("class", "focus-mode-chart-svg");
    svg.setAttribute("width", `${size}`);
    svg.setAttribute("height", `${size}`);
    svg.setAttribute("viewBox", `0 0 ${size} ${size}`);
    svg.setAttribute("role", "img");
    svg.setAttribute("aria-label", `${title} pie chart`);
    chartWrap.appendChild(svg);
    const center = radius;
    let cumulative = 0;
    const nonZeroSlices = resolvedSlices.filter((slice) => slice.value > 0);
    if (nonZeroSlices.length === 1) {
      const circle = document.createElementNS(svgNS, "circle");
      circle.setAttribute("cx", `${center}`);
      circle.setAttribute("cy", `${center}`);
      circle.setAttribute("r", `${center}`);
      circle.setAttribute("fill", nonZeroSlices[0].color);
      circle.setAttribute("stroke", borderColor);
      circle.setAttribute("stroke-width", "1");
      svg.appendChild(circle);
      circle.style.fill = nonZeroSlices[0].color;
    } else {
      const polarToCartesian = (cx, cy, r, angle) => {
        const radians = (angle - 90) * (Math.PI / 180);
        return {
          x: cx + r * Math.cos(radians),
          y: cy + r * Math.sin(radians)
        };
      };
      const describeArc = (cx, cy, r, startAngle, endAngle) => {
        const start = polarToCartesian(cx, cy, r, endAngle);
        const end = polarToCartesian(cx, cy, r, startAngle);
        const largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";
        return [
          `M ${cx} ${cy}`,
          `L ${start.x} ${start.y}`,
          `A ${r} ${r} 0 ${largeArcFlag} 0 ${end.x} ${end.y}`,
          "Z"
        ].join(" ");
      };
      resolvedSlices.forEach((slice) => {
        if (slice.value <= 0)
          return;
        const startAngle = cumulative;
        const endAngle = cumulative + slice.value / total * 360;
        cumulative = endAngle;
        const path = document.createElementNS(svgNS, "path");
        path.setAttribute("d", describeArc(center, center, center, startAngle, endAngle));
        path.setAttribute("fill", slice.color);
        path.setAttribute("stroke", borderColor);
        path.setAttribute("stroke-width", "1");
        svg.appendChild(path);
        path.style.fill = slice.color;
        path.setAttribute("aria-label", `${slice.label}: ${slice.value}`);
      });
    }
    const legend = chartWrap.createDiv({ cls: "focus-mode-chart-legend" });
    slices.forEach((slice) => {
      const legendItem = legend.createDiv({ cls: "focus-mode-chart-legend-item" });
      legendItem.createSpan({ cls: "focus-mode-chart-legend-swatch" }).style.backgroundColor = slice.color;
      legendItem.createSpan({ cls: "focus-mode-chart-legend-label", text: `${slice.label}: ${slice.value}` });
    });
  }
  async render() {
    var _a;
    const { contentEl } = this;
    this._renderToken = (this._renderToken || 0) + 1;
    const token = this._renderToken;
    const header = contentEl.createDiv({ cls: "focus-mode-stats-modal-header" });
    header.createDiv({ cls: "focus-mode-stats-modal-title", text: "Focus mode stats" });
    const headerActions = header.createDiv({ cls: "focus-mode-stats-modal-actions" });
    headerActions.createEl("button", { cls: "focus-mode-stats-modal-btn", text: "Older sessions" });
    if (!this.project) {
      contentEl.createDiv({ cls: "focus-mode-stats-empty", text: "No active project." });
      return;
    }
    const cfg = await this.plugin.configService.loadProjectConfig(this.project) || {};
    const meta = await this.plugin.configService.loadProjectMeta(this.project) || {};
    if (token !== this._renderToken)
      return;
    contentEl.empty();
    const author = Array.isArray(meta.author) ? meta.author.join(", ") : meta.author;
    const createdAt = this.formatDate(meta.created_at);
    const lastModified = this.formatDate(((_a = cfg.stats) == null ? void 0 : _a.last_modified) || meta.last_modified);
    const infoSection = contentEl.createDiv({ cls: "focus-mode-stats-section" });
    infoSection.createDiv({ cls: "focus-mode-stats-section-title", text: "Project info" });
    const infoGrid = infoSection.createDiv({ cls: "focus-mode-info-grid" });
    const addInfoRow = (label, value) => {
      const row = infoGrid.createDiv({ cls: "focus-mode-info-row" });
      row.createDiv({ cls: "focus-mode-info-label", text: label });
      row.createDiv({ cls: "focus-mode-info-value", text: this.formatValue(value) });
    };
    addInfoRow("Title", meta.title || this.project.name || "\u2014");
    addInfoRow("Author", author || "\u2014");
    addInfoRow("Date of creation", createdAt);
    addInfoRow("Date of last modification", lastModified);
    const focusMode = cfg.focusMode || {};
    const history = Array.isArray(focusMode.history) ? focusMode.history : [];
    const currentWords = Number(focusMode.currentWords || 0);
    const currentTarget = Number(focusMode.wordGoal || 0);
    const statsSection = contentEl.createDiv({ cls: "focus-mode-stats-section" });
    statsSection.createDiv({ cls: "focus-mode-stats-section-title", text: "Focus sessions" });
    const statsGrid = statsSection.createDiv({ cls: "focus-mode-info-grid" });
    const addStatRow = (label, value) => {
      const row = statsGrid.createDiv({ cls: "focus-mode-info-row" });
      row.createDiv({ cls: "focus-mode-info-label", text: label });
      row.createDiv({ cls: "focus-mode-info-value", text: value.toString() });
    };
    addStatRow("Total Completed sessions", Number(focusMode.sessions || 0));
    addStatRow("Total Interrupted sessions", Number(focusMode.interruptions || 0));
    addStatRow("Total Words in session", currentWords);
    addStatRow("Total Session word target", currentTarget);
    const chartsSection = contentEl.createDiv({ cls: "focus-mode-stats-section focus-mode-charts" });
    chartsSection.createDiv({ cls: "focus-mode-stats-section-title", text: "Charts" });
    const chartsGrid = chartsSection.createDiv({ cls: "focus-mode-charts-grid" });
    const completedCount = Number(focusMode.sessions || 0);
    const interruptedCount = Number(focusMode.interruptions || 0);
    this.buildPieChart(chartsGrid, "Completed vs Interrupted", [
      { label: "Completed", value: completedCount, color: "var(--text-accent)" },
      { label: "Interrupted", value: interruptedCount, color: "var(--text-muted)" }
    ]);
    const remaining = Math.max(0, currentTarget - currentWords);
    this.buildPieChart(chartsGrid, "Words vs Target", [
      { label: "Words", value: currentWords, color: "var(--text-accent)" },
      { label: "Remaining", value: remaining, color: "var(--text-normal)" }
    ]);
  }
};

// src/views/writerToolsView.js
var WRITER_TOOLS_VIEW_TYPE2 = "folio-writer-tools";
var WriterToolsView = class extends import_obsidian6.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.focusModeActive = false;
    this.timerSeconds = 25 * 60;
    this.timerRunning = false;
    this.timerInterval = null;
    this.sessionStartWords = 0;
    this.focusStats = {
      sessions: 0,
      interruptions: 0,
      currentWords: 0,
      wordGoal: 500,
      totalTimeSpent: 0,
      // in seconds
      history: []
    };
    this.focusStatsModal = null;
  }
  getViewType() {
    return WRITER_TOOLS_VIEW_TYPE2;
  }
  getDisplayText() {
    return "Writer Tools";
  }
  getIcon() {
    return "drafting-compass";
  }
  async onOpen() {
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-writer-tools");
    const header = container.createDiv({ cls: "writer-tools-header" });
    const headerTitle = header.createDiv({ cls: "writer-tools-title" });
    headerTitle.createSpan({ text: "Writer tools" });
    container.createDiv({ cls: "writer-tools-divider" });
    this.toolsContainer = container.createDiv({ cls: "writer-tools-container" });
    this.renderFocusModeSection();
    this.renderExportSection();
    this.renderResourcesSection();
    this.renderAboutSection();
  }
  renderFocusModeSection() {
    const section = this.toolsContainer.createDiv({ cls: "writer-tools-section" });
    section.createDiv({ cls: "writer-tools-section-title", text: "FOCUS MODE" });
    const focusItem = section.createDiv({ cls: "writer-tools-item" });
    const iconSpan = focusItem.createSpan({ cls: "writer-tools-item-icon" });
    (0, import_obsidian6.setIcon)(iconSpan, "circle-dot");
    focusItem.createSpan({ cls: "writer-tools-item-text", text: "Enter focus mode" });
    focusItem.addEventListener("click", () => {
      this.showFocusMode();
    });
  }
  showFocusMode() {
    this.focusModeActive = true;
    const container = this.containerEl.children[1];
    container.empty();
    container.addClass("folio-focus-mode");
    const project = this.plugin.activeProject || this.plugin.activeBook;
    if (!project) {
      container.createDiv({ cls: "focus-mode-no-project", text: "No project selected. Please select a project first." });
      const backBtn = container.createEl("button", { cls: "focus-mode-btn-secondary", text: "Back" });
      backBtn.addEventListener("click", () => this.exitFocusMode());
      return;
    }
    this.loadFocusStats(project).then(() => {
      this.renderFocusModeUI(container, project);
    });
  }
  async loadFocusStats(project) {
    try {
      const cfg = await this.plugin.configService.loadProjectConfig(project);
      if (cfg && cfg.focusMode) {
        this.focusStats = {
          sessions: cfg.focusMode.sessions || 0,
          interruptions: cfg.focusMode.interruptions || 0,
          currentWords: Number(cfg.focusMode.currentWords || 0),
          wordGoal: cfg.focusMode.wordGoal || 500,
          totalTimeSpent: cfg.focusMode.totalTimeSpent || 0,
          history: Array.isArray(cfg.focusMode.history) ? cfg.focusMode.history : []
        };
      }
    } catch (e) {
      console.warn("Failed to load focus stats", e);
    }
  }
  async saveFocusStats(project) {
    try {
      const cfg = await this.plugin.configService.loadProjectConfig(project) || {};
      cfg.focusMode = {
        sessions: this.focusStats.sessions,
        interruptions: this.focusStats.interruptions,
        currentWords: this.focusStats.currentWords || 0,
        wordGoal: this.focusStats.wordGoal,
        totalTimeSpent: this.focusStats.totalTimeSpent,
        history: this.focusStats.history,
        lastSession: new Date().toISOString()
      };
      await this.plugin.configService.saveProjectConfig(project, cfg);
      if (this.focusStatsModal) {
        this.focusStatsModal.setProject(project);
        this.focusStatsModal.refresh();
      }
    } catch (e) {
      console.warn("Failed to save focus stats", e);
    }
  }
  renderFocusModeUI(container, project) {
    this.focusModeProject = project;
    const header = container.createDiv({ cls: "focus-mode-header" });
    const headerIcon = header.createSpan({ cls: "focus-mode-header-icon" });
    (0, import_obsidian6.setIcon)(headerIcon, "circle-dot");
    header.createSpan({ cls: "focus-mode-header-title", text: "Focus mode" });
    const projectLabel = container.createDiv({ cls: "focus-mode-project-name" });
    projectLabel.createSpan({ text: "Project: ", cls: "focus-mode-project-label" });
    projectLabel.createSpan({ text: project.name, cls: "focus-mode-project-value" });
    const timerContainer = container.createDiv({ cls: "focus-mode-timer-container" });
    const timerCircle = timerContainer.createDiv({ cls: "focus-mode-timer-circle" });
    this.timerDisplay = timerCircle.createDiv({ cls: "focus-mode-timer-display" });
    this.updateTimerDisplay();
    this.statusText = container.createDiv({ cls: "focus-mode-status", text: "Ready to start" });
    const buttonsContainer = container.createDiv({ cls: "focus-mode-buttons" });
    this.startButton = buttonsContainer.createEl("button", { cls: "focus-mode-btn-primary", text: "Start focus" });
    this.startButton.addEventListener("click", () => this.toggleTimer());
    const exitButton = buttonsContainer.createEl("button", { cls: "focus-mode-btn-secondary", text: "Exit" });
    exitButton.addEventListener("click", () => this.exitFocusMode());
    const statsBar = container.createDiv({ cls: "focus-mode-stats-bar" });
    this.renderFocusStats(statsBar);
  }
  updateTimerDisplay() {
    const minutes = Math.floor(this.timerSeconds / 60);
    const seconds = this.timerSeconds % 60;
    this.timerDisplay.textContent = `${minutes.toString().padStart(2, "0")}:${seconds.toString().padStart(2, "0")}`;
  }
  toggleTimer() {
    if (this.timerRunning) {
      this.pauseTimer();
    } else {
      this.startTimer();
    }
  }
  startTimer() {
    this.timerRunning = true;
    this.startButton.textContent = "Pause";
    this.statusText.textContent = "Focus in progress...";
    if (this.timerSeconds === 25 * 60) {
      this.sessionStartWords = this.getActiveEditorWordCount();
      this.focusStats.currentWords = 0;
      this.refreshFocusStats();
    }
    this.timerInterval = setInterval(() => {
      if (this.timerSeconds > 0) {
        this.timerSeconds--;
        this.updateTimerDisplay();
      } else {
        this.completeSession();
      }
    }, 1e3);
  }
  pauseTimer() {
    this.timerRunning = false;
    this.startButton.textContent = "Resume";
    this.statusText.textContent = "Paused";
    this.focusStats.interruptions++;
    this.focusStats.history.push({
      type: "interrupted",
      timestamp: new Date().toISOString(),
      words: this.focusStats.currentWords || 0,
      target: this.focusStats.wordGoal || 0
    });
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    const project = this.plugin.activeProject || this.plugin.activeBook;
    if (project)
      this.saveFocusStats(project);
    this.refreshFocusStats();
    this.sessionStartWords = 0;
    this.focusStats.currentWords = 0;
  }
  completeSession() {
    this.timerRunning = false;
    this.focusStats.sessions++;
    this.focusStats.totalTimeSpent += 25 * 60;
    this.focusStats.history.push({
      type: "completed",
      timestamp: new Date().toISOString(),
      words: this.focusStats.currentWords || 0,
      target: this.focusStats.wordGoal || 0
    });
    this.startButton.textContent = "Start focus";
    this.statusText.textContent = "Session complete!";
    this.timerSeconds = 25 * 60;
    this.updateTimerDisplay();
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    const project = this.plugin.activeProject || this.plugin.activeBook;
    if (project)
      this.saveFocusStats(project);
    this.refreshFocusStats();
  }
  refreshFocusStats() {
    const statsBar = this.containerEl.querySelector(".focus-mode-stats-bar");
    if (statsBar) {
      statsBar.empty();
      this.renderFocusStats(statsBar);
    }
  }
  renderFocusStats(container) {
    const formatTime = (seconds) => {
      const hrs = Math.floor(seconds / 3600);
      const mins = Math.floor(seconds % 3600 / 60);
      if (hrs > 0)
        return `${hrs}h ${mins}m`;
      return `${mins}m`;
    };
    const project = this.focusModeProject || this.plugin.activeProject || this.plugin.activeBook;
    const statsHeader = container.createDiv({ cls: "focus-mode-stats-header" });
    const statsButton = statsHeader.createEl("button", { cls: "focus-mode-stats-button", text: "Focus mode stats" });
    statsButton.addEventListener("click", async (evt) => {
      evt.stopPropagation();
      if (!project)
        return;
      await this.saveFocusStats(project);
      if (!this.focusStatsModal) {
        this.focusStatsModal = new FocusModeStatsModal(this.plugin, project);
      }
      this.focusStatsModal.setProject(project);
      this.focusStatsModal.open();
    });
    const tooltipZone = container.createDiv({ cls: "focus-mode-tooltip-zone" });
    const stats = [
      { label: "Completed sessions", value: this.focusStats.sessions, tooltip: "Number of 25-minute focus sessions completed without exiting", priority: "secondary" },
      { label: "Interrupted sessions", value: this.focusStats.interruptions, tooltip: "Number of times you paused during an active focus session", priority: "secondary" },
      { label: "Words in session", value: this.focusStats.currentWords, tooltip: "Words written during the current focus session", priority: "primary" },
      { label: "Session word target", value: this.focusStats.wordGoal, tooltip: "Target number of words to write per session", priority: "primary" }
    ];
    const statsRow = container.createDiv({ cls: "focus-mode-stats-row" });
    stats.forEach((stat) => {
      const statItem = statsRow.createDiv({ cls: `focus-mode-stat-item ${stat.priority === "primary" ? "is-primary" : "is-secondary"}` });
      statItem.createDiv({ cls: "focus-mode-stat-label", text: stat.label });
      statItem.createDiv({ cls: "focus-mode-stat-value", text: stat.value.toString() });
      statItem.addEventListener("click", (e) => {
        e.stopPropagation();
        tooltipZone.textContent = stat.tooltip;
        tooltipZone.classList.add("visible");
        setTimeout(() => {
          tooltipZone.classList.remove("visible");
        }, 3e3);
      });
    });
    container.addEventListener("click", () => {
      tooltipZone.classList.remove("visible");
    });
  }
  getActiveEditorWordCount() {
    var _a;
    try {
      const leaf = this.plugin.app.workspace.getMostRecentLeaf();
      const editor = (_a = leaf == null ? void 0 : leaf.view) == null ? void 0 : _a.editor;
      if (!editor || typeof editor.getValue !== "function")
        return 0;
      return this.plugin.statsService.countWords(editor.getValue());
    } catch (e) {
      return 0;
    }
  }
  updateFocusSessionWordsFromEditor(text, file) {
    if (!this.focusModeActive)
      return;
    const project = this.focusModeProject || this.plugin.activeProject || this.plugin.activeBook;
    if (!project || !(file == null ? void 0 : file.path) || !file.path.startsWith(project.path + "/"))
      return;
    const total = this.plugin.statsService.countWords(text);
    if (this.sessionStartWords === void 0 || this.sessionStartWords === null) {
      this.sessionStartWords = total;
    }
    const current = Math.max(0, total - this.sessionStartWords);
    if (current !== this.focusStats.currentWords) {
      this.focusStats.currentWords = current;
      this.refreshFocusStats();
    }
  }
  exitFocusMode() {
    if (this.timerInterval) {
      clearInterval(this.timerInterval);
      this.timerInterval = null;
    }
    this.timerRunning = false;
    this.timerSeconds = 25 * 60;
    this.focusModeActive = false;
    const container = this.containerEl.children[1];
    container.removeClass("folio-focus-mode");
    this.onOpen();
  }
  renderExportSection() {
    const section = this.toolsContainer.createDiv({ cls: "writer-tools-section" });
    section.createDiv({ cls: "writer-tools-section-title", text: "EXPORT ASSISTANT" });
    const exportItem = section.createDiv({ cls: "writer-tools-item" });
    const iconSpan = exportItem.createSpan({ cls: "writer-tools-item-icon" });
    (0, import_obsidian6.setIcon)(iconSpan, "file-stack");
    exportItem.createSpan({ cls: "writer-tools-item-text", text: "Consolidate document" });
    exportItem.addEventListener("click", () => {
      console.log("Consolidate document clicked");
    });
  }
  renderResourcesSection() {
    const section = this.toolsContainer.createDiv({ cls: "writer-tools-section" });
    section.createDiv({ cls: "writer-tools-section-title", text: "RESOURCES" });
    const resourcesGrid = section.createDiv({ cls: "writer-tools-resources-grid" });
    const resources = [
      { icon: "user", label: "Character", tooltip: "Character development resources" },
      { icon: "bookmark", label: "Narrative", tooltip: "Narrative techniques" },
      { icon: "layout-grid", label: "Structure", tooltip: "Story structure guides" },
      { icon: "lightbulb", label: "Tips", tooltip: "Writing tips" }
    ];
    resources.forEach((resource) => {
      const resourceItem = resourcesGrid.createDiv({ cls: "writer-tools-resource-item" });
      resourceItem.setAttribute("aria-label", resource.tooltip);
      const iconWrapper = resourceItem.createDiv({ cls: "writer-tools-resource-icon" });
      (0, import_obsidian6.setIcon)(iconWrapper, resource.icon);
      resourceItem.createDiv({ cls: "writer-tools-resource-label", text: resource.label });
      resourceItem.addEventListener("click", () => {
        console.log(`${resource.label} clicked`);
      });
    });
  }
  renderAboutSection() {
    const section = this.toolsContainer.createDiv({ cls: "writer-tools-section" });
    section.createDiv({ cls: "writer-tools-section-title", text: "ABOUT" });
    const aboutItems = [
      { icon: "heart", label: "Donate", action: () => window.open("https://github.com/sponsors", "_blank") },
      { icon: "mail", label: "Contact", action: () => window.open("mailto:contact@example.com", "_blank") }
    ];
    aboutItems.forEach((item) => {
      const aboutItem = section.createDiv({ cls: "writer-tools-item" });
      const iconSpan = aboutItem.createSpan({ cls: "writer-tools-item-icon" });
      (0, import_obsidian6.setIcon)(iconSpan, item.icon);
      aboutItem.createSpan({ cls: "writer-tools-item-text", text: item.label });
      aboutItem.addEventListener("click", item.action);
    });
  }
  async onClose() {
  }
};

// src/views/folioSettingTab.js
var import_obsidian8 = require("obsidian");

// src/modals/iconPickerModal.js
var import_obsidian7 = require("obsidian");
var COMMON_ICONS = [
  // Books & Documents
  "book",
  "book-open",
  "book-text",
  "book-copy",
  "book-marked",
  "book-open-check",
  "book-open-text",
  "library",
  "library-big",
  "notebook",
  "notebook-pen",
  "notebook-tabs",
  "newspaper",
  "file-text",
  "file",
  "files",
  "file-check",
  "file-edit",
  "file-plus",
  "file-minus",
  "scroll",
  "scroll-text",
  "sticky-note",
  "clipboard",
  "clipboard-list",
  "clipboard-check",
  "bookmark",
  "bookmark-plus",
  "bookmarks",
  "bookmark-check",
  // Writing & Creativity
  "pen",
  "pen-tool",
  "pen-line",
  "pencil",
  "pencil-line",
  "pencil-ruler",
  "feather",
  "highlighter",
  "eraser",
  "type",
  "text",
  "text-cursor",
  "text-cursor-input",
  "signature",
  "quote",
  "pilcrow",
  "baseline",
  "subscript",
  "superscript",
  "spell-check",
  "spell-check-2",
  "whole-word",
  "case-sensitive",
  // Media & Entertainment
  "tv",
  "tv-minimal",
  "tv-minimal-play",
  "monitor-play",
  "clapperboard",
  "film",
  "video",
  "videotape",
  "camera",
  "camera-off",
  "projector",
  "theater",
  "popcorn",
  "ticket",
  "drama",
  "music",
  "music-2",
  "music-3",
  "music-4",
  "mic",
  "mic-2",
  "mic-off",
  "headphones",
  "headset",
  "radio",
  "podcast",
  "audio-lines",
  "audio-waveform",
  "play",
  "play-circle",
  "pause",
  "pause-circle",
  "stop-circle",
  "skip-forward",
  "skip-back",
  "rewind",
  "fast-forward",
  "repeat",
  "repeat-1",
  "shuffle",
  "list-music",
  // Visual & Art
  "image",
  "image-plus",
  "images",
  "gallery-horizontal",
  "gallery-vertical",
  "palette",
  "paintbrush",
  "paintbrush-2",
  "brush",
  "paint-bucket",
  "paint-roller",
  "pipette",
  "droplet",
  "droplets",
  "blend",
  "contrast",
  "sun-dim",
  "aperture",
  "focus",
  "scan",
  "crop",
  "flip-horizontal",
  "flip-vertical",
  "rotate-ccw",
  "rotate-cw",
  "move",
  "maximize",
  "minimize",
  "frame",
  "picture-in-picture",
  "picture-in-picture-2",
  // Folders & Organization
  "folder",
  "folder-open",
  "folder-closed",
  "folder-plus",
  "folder-minus",
  "folder-check",
  "folder-x",
  "folder-search",
  "folder-heart",
  "folder-input",
  "folder-output",
  "folder-archive",
  "folder-cog",
  "folder-dot",
  "folder-git",
  "folder-git-2",
  "folder-kanban",
  "folder-key",
  "folder-lock",
  "folder-symlink",
  "folder-sync",
  "folder-tree",
  "folders",
  "package",
  "package-open",
  "box",
  "boxes",
  "archive",
  "archive-restore",
  // Education & Learning
  "graduation-cap",
  "school",
  "school-2",
  "backpack",
  "brain",
  "brain-circuit",
  "brain-cog",
  "lightbulb",
  "lightbulb-off",
  "lamp",
  "lamp-desk",
  "lamp-floor",
  "lamp-ceiling",
  "lamp-wall-down",
  "lamp-wall-up",
  "presentation",
  "flip-chart",
  "clipboard-pen",
  "clipboard-type",
  "calculator",
  "ruler",
  "triangle-ruler",
  "drafting-compass",
  "beaker",
  "flask-conical",
  "flask-round",
  "microscope",
  "telescope",
  "atom",
  // Technology
  "code",
  "code-2",
  "terminal",
  "terminal-square",
  "braces",
  "brackets",
  "database",
  "server",
  "hard-drive",
  "cpu",
  "memory-stick",
  "usb",
  "monitor",
  "laptop",
  "laptop-2",
  "tablet",
  "smartphone",
  "phone",
  "keyboard",
  "mouse",
  "mouse-pointer",
  "mouse-pointer-2",
  "touchpad",
  "wifi",
  "wifi-off",
  "bluetooth",
  "nfc",
  "signal",
  "antenna",
  "battery",
  "battery-charging",
  "battery-full",
  "battery-low",
  "battery-medium",
  "battery-warning",
  "plug",
  "plug-2",
  "plug-zap",
  "power",
  "power-off",
  "git-branch",
  "git-commit",
  "git-merge",
  "git-pull-request",
  "git-fork",
  "git-compare",
  "github",
  "gitlab",
  "chrome",
  "firefox",
  // Navigation & Location
  "globe",
  "globe-2",
  "earth",
  "map",
  "map-pin",
  "map-pinned",
  "compass",
  "navigation",
  "navigation-2",
  "locate",
  "locate-fixed",
  "locate-off",
  "route",
  "signpost",
  "signpost-big",
  "milestone",
  "flag",
  "flag-triangle-right",
  "home",
  "house",
  "house-plus",
  "building",
  "building-2",
  "factory",
  "warehouse",
  "store",
  "castle",
  "church",
  "landmark",
  "tent",
  "tent-tree",
  "mountain",
  "mountain-snow",
  "trees",
  // People & Social
  "user",
  "user-2",
  "user-circle",
  "user-circle-2",
  "user-check",
  "user-plus",
  "user-minus",
  "user-x",
  "users",
  "users-2",
  "users-round",
  "contact",
  "contact-2",
  "contacts",
  "person-standing",
  "accessibility",
  "baby",
  "hand",
  "hand-metal",
  "handshake",
  "heart",
  "heart-handshake",
  "heart-pulse",
  "activity",
  "heart-crack",
  "heart-off",
  "thumbs-up",
  "thumbs-down",
  "smile",
  "smile-plus",
  "frown",
  "meh",
  "laugh",
  "angry",
  // Communication
  "mail",
  "mail-open",
  "mail-plus",
  "mail-check",
  "mail-x",
  "mail-warning",
  "mail-search",
  "inbox",
  "send",
  "send-horizontal",
  "forward",
  "reply",
  "reply-all",
  "message-circle",
  "message-square",
  "message-square-plus",
  "messages-square",
  "at-sign",
  "hash",
  "phone",
  "phone-call",
  "phone-incoming",
  "phone-outgoing",
  "voicemail",
  "megaphone",
  "volume",
  "volume-1",
  "volume-2",
  "volume-x",
  "bell",
  "bell-ring",
  "bell-plus",
  "bell-minus",
  "bell-off",
  // Weather & Nature
  "sun",
  "sun-dim",
  "sun-medium",
  "sun-moon",
  "sunrise",
  "sunset",
  "moon",
  "moon-star",
  "cloud",
  "cloud-sun",
  "cloud-rain",
  "cloud-snow",
  "cloud-lightning",
  "snowflake",
  "wind",
  "tornado",
  "rainbow",
  "thermometer",
  "thermometer-sun",
  "thermometer-snowflake",
  "umbrella",
  "umbrella-off",
  "droplet",
  "droplets",
  "waves",
  "tree",
  "tree-deciduous",
  "tree-pine",
  "trees",
  "palm-tree",
  "sprout",
  "leaf",
  "clover",
  "flower",
  "flower-2",
  "cherry",
  "apple",
  "banana",
  "grape",
  "citrus",
  "bird",
  "bug",
  "cat",
  "dog",
  "fish",
  "rabbit",
  "snail",
  "squirrel",
  "turtle",
  // Objects & Tools
  "wrench",
  "hammer",
  "axe",
  "pickaxe",
  "shovel",
  "scissors",
  "knife",
  "screwdriver",
  "nut",
  "cog",
  "settings",
  "settings-2",
  "sliders",
  "sliders-horizontal",
  "key",
  "key-round",
  "key-square",
  "lock",
  "lock-keyhole",
  "unlock",
  "unlock-keyhole",
  "shield",
  "shield-check",
  "shield-alert",
  "shield-off",
  "shield-question",
  "glasses",
  "binoculars",
  "eye",
  "eye-off",
  "scan-eye",
  "scan-face",
  "magnet",
  "flashlight",
  "flashlight-off",
  "lighter",
  "flame",
  "fire-extinguisher",
  "trash",
  "trash-2",
  "recycle",
  "archive",
  "archive-restore",
  "archive-x",
  // Shapes & Symbols
  "circle",
  "square",
  "triangle",
  "diamond",
  "pentagon",
  "hexagon",
  "octagon",
  "star",
  "stars",
  "sparkle",
  "sparkles",
  "zap",
  "zap-off",
  "bolt",
  "crown",
  "gem",
  "award",
  "badge",
  "badge-check",
  "medal",
  "trophy",
  "ribbon",
  "gift",
  "party-popper",
  "cake",
  "cake-slice",
  "candy",
  "candy-cane",
  "cookie",
  "ice-cream",
  "check",
  "check-circle",
  "check-square",
  "x",
  "x-circle",
  "x-square",
  "plus",
  "plus-circle",
  "plus-square",
  "minus",
  "minus-circle",
  "minus-square",
  "equal",
  "divide",
  "percent",
  "infinity",
  "sigma",
  "pi",
  "omega",
  // Arrows & Direction
  "arrow-up",
  "arrow-down",
  "arrow-left",
  "arrow-right",
  "arrow-up-right",
  "arrow-up-left",
  "arrow-down-right",
  "arrow-down-left",
  "chevron-up",
  "chevron-down",
  "chevron-left",
  "chevron-right",
  "chevrons-up",
  "chevrons-down",
  "chevrons-left",
  "chevrons-right",
  "move-up",
  "move-down",
  "move-left",
  "move-right",
  "corner-up-left",
  "corner-up-right",
  "corner-down-left",
  "corner-down-right",
  "undo",
  "undo-2",
  "redo",
  "redo-2",
  "refresh-cw",
  "refresh-ccw",
  // Time & Calendar
  "clock",
  "clock-1",
  "clock-2",
  "clock-3",
  "clock-4",
  "clock-5",
  "clock-6",
  "alarm-clock",
  "alarm-clock-check",
  "alarm-clock-minus",
  "alarm-clock-off",
  "alarm-clock-plus",
  "timer",
  "timer-off",
  "timer-reset",
  "stopwatch",
  "hourglass",
  "history",
  "calendar",
  "calendar-days",
  "calendar-check",
  "calendar-plus",
  "calendar-minus",
  "calendar-x",
  "calendar-heart",
  "calendar-clock",
  "calendar-range",
  "calendar-search",
  // Layout & UI
  "layout-dashboard",
  "layout-grid",
  "layout-list",
  "layout-template",
  "layout-panel-left",
  "layout-panel-top",
  "kanban",
  "kanban-square",
  "trello",
  "columns",
  "rows",
  "table",
  "table-2",
  "grid-2x2",
  "grid-3x3",
  "align-left",
  "align-center",
  "align-right",
  "align-justify",
  "list",
  "list-checks",
  "list-ordered",
  "list-todo",
  "list-tree",
  "list-filter",
  "sidebar",
  "panel-left",
  "panel-right",
  "panel-top",
  "panel-bottom",
  "split",
  "split-square-horizontal",
  "split-square-vertical",
  "maximize-2",
  "minimize-2",
  "expand",
  "shrink",
  "fullscreen",
  // Actions & Status
  "search",
  "zoom-in",
  "zoom-out",
  "filter",
  "filter-x",
  "sort-asc",
  "sort-desc",
  "save",
  "save-all",
  "download",
  "upload",
  "import",
  "share",
  "share-2",
  "link",
  "link-2",
  "unlink",
  "external-link",
  "qr-code",
  "scan-barcode",
  "copy",
  "clipboard-copy",
  "clipboard-paste",
  "cut",
  "edit",
  "edit-2",
  "edit-3",
  "info",
  "circle-help",
  "help-circle",
  "alert-circle",
  "alert-triangle",
  "alert-octagon",
  "ban",
  "slash",
  "loader",
  "loader-2",
  "refresh-cw",
  "rotate-ccw",
  "grip-horizontal",
  "grip-vertical",
  "more-horizontal",
  "more-vertical",
  "menu",
  // Commerce & Finance
  "dollar-sign",
  "euro",
  "pound-sterling",
  "bitcoin",
  "coins",
  "piggy-bank",
  "wallet",
  "wallet-2",
  "credit-card",
  "banknote",
  "receipt",
  "ticket",
  "tags",
  "tag",
  "percent",
  "shopping-cart",
  "shopping-bag",
  "shopping-basket",
  "store",
  "storefront",
  "scale",
  "scale-3d",
  "weight",
  "barcode",
  "scan-line",
  // Travel & Transport
  "plane",
  "plane-takeoff",
  "plane-landing",
  "rocket",
  "satellite",
  "satellite-dish",
  "car",
  "car-front",
  "bus",
  "train",
  "train-front",
  "tram-front",
  "bike",
  "ship",
  "sailboat",
  "anchor",
  "fuel",
  "parking-meter",
  "traffic-cone",
  "luggage",
  "briefcase",
  "suitcase",
  "suitcase-rolling",
  // Sports & Games
  "dumbbell",
  "trophy",
  "medal",
  "target",
  "crosshair",
  "goal",
  "gamepad",
  "gamepad-2",
  "joystick",
  "dice-1",
  "dice-2",
  "dice-3",
  "dice-4",
  "dice-5",
  "dice-6",
  "puzzle",
  "swords",
  "sword",
  "wand",
  "wand-2",
  "crown"
];
var IconPickerModal = class extends import_obsidian7.Modal {
  constructor(app, { title, currentIcon, onSelect }) {
    super(app);
    this.title = title || "Select Icon";
    this.currentIcon = currentIcon;
    this.onSelect = onSelect;
    this.searchQuery = "";
    this.filteredIcons = [...COMMON_ICONS];
  }
  onOpen() {
    const { contentEl, modalEl, containerEl } = this;
    contentEl.empty();
    contentEl.addClass("folio-icon-picker-modal");
    if (containerEl) {
      containerEl.style.zIndex = "9999";
    }
    if (modalEl) {
      modalEl.style.zIndex = "10000";
    }
    contentEl.createEl("h2", { text: this.title });
    const searchContainer = contentEl.createDiv({ cls: "folio-icon-picker-search" });
    const searchInput = searchContainer.createEl("input", {
      type: "text",
      placeholder: "Search icons...",
      cls: "folio-icon-picker-search-input"
    });
    searchInput.oninput = (e) => {
      this.searchQuery = e.target.value.toLowerCase();
      this.filterAndRenderIcons(iconGrid);
    };
    const iconGrid = contentEl.createDiv({ cls: "folio-icon-picker-grid" });
    this.renderIcons(iconGrid, COMMON_ICONS);
    searchInput.focus();
  }
  filterAndRenderIcons(container) {
    const filtered = this.searchQuery ? COMMON_ICONS.filter((icon) => icon.toLowerCase().includes(this.searchQuery)) : COMMON_ICONS;
    this.renderIcons(container, filtered);
  }
  renderIcons(container, icons) {
    container.empty();
    if (icons.length === 0) {
      container.createDiv({
        cls: "folio-icon-picker-empty",
        text: "No icons found"
      });
      return;
    }
    icons.forEach((iconName) => {
      const iconOption = container.createDiv({
        cls: "folio-icon-picker-option" + (iconName === this.currentIcon ? " is-selected" : "")
      });
      iconOption.title = iconName;
      (0, import_obsidian7.setIcon)(iconOption, iconName);
      const label = iconOption.createSpan({ cls: "folio-icon-picker-label" });
      label.textContent = iconName;
      iconOption.onclick = () => {
        this.onSelect(iconName);
        this.close();
      };
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/views/folioSettingTab.js
init_constants();
var FolioSettingTab = class extends import_obsidian8.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const el = this.containerEl;
    el.empty();
    el.createEl("h2", { text: "Folio" });
    const basicSection = el.createDiv({ cls: "folio-settings-section" });
    const basicHeader = basicSection.createDiv({ cls: "folio-settings-section-header" });
    const basicToggle = basicHeader.createSpan({ cls: "folio-settings-toggle" });
    (0, import_obsidian8.setIcon)(basicToggle, "chevron-right");
    basicHeader.createSpan({ text: "Basic options", cls: "folio-settings-section-title" });
    const basicContent = basicSection.createDiv({ cls: "folio-settings-section-content collapsed" });
    basicHeader.onclick = () => {
      basicContent.classList.toggle("collapsed");
      (0, import_obsidian8.setIcon)(basicToggle, basicContent.classList.contains("collapsed") ? "chevron-right" : "chevron-down");
    };
    new import_obsidian8.Setting(basicContent).setName("Default author").setDesc("Default author name for new projects").addText(
      (text) => text.setPlaceholder("Author name").setValue(this.plugin.settings.defaultAuthor || "").onChange(async (value) => {
        this.plugin.settings.defaultAuthor = value.trim();
        await this.plugin.saveSettings();
      })
    );
    new import_obsidian8.Setting(basicContent).setName("Project storage path").setDesc("Default storage path for new projects (relative to vault root)").addText((text) => {
      text.setPlaceholder("projects").setValue(this.plugin.settings.basePath || "projects").onChange(async (value) => {
        let normalizedPath = value.trim().replace(/^\/+|\/+$/g, "") || "projects";
        this.plugin.settings.basePath = normalizedPath;
        await this.plugin.saveSettings();
      });
      text.inputEl.addEventListener("blur", async () => {
        await this.plugin.ensureBasePath();
        await this.plugin.refresh();
      });
    });
    const templateSection = el.createDiv({ cls: "folio-settings-section" });
    const templateHeader = templateSection.createDiv({ cls: "folio-settings-section-header" });
    const templateToggle = templateHeader.createSpan({ cls: "folio-settings-toggle" });
    (0, import_obsidian8.setIcon)(templateToggle, "chevron-right");
    templateHeader.createSpan({ text: "Template options", cls: "folio-settings-section-title" });
    const templateContent = templateSection.createDiv({ cls: "folio-settings-section-content collapsed" });
    templateHeader.onclick = () => {
      templateContent.classList.toggle("collapsed");
      (0, import_obsidian8.setIcon)(templateToggle, templateContent.classList.contains("collapsed") ? "chevron-right" : "chevron-down");
    };
    if (!this.plugin.settings.projectTemplates) {
      this.plugin.settings.projectTemplates = [
        { id: "book", name: "Book", icon: "book", order: 1, description: "Novel or written work" },
        { id: "script", name: "TV Show", icon: "tv", order: 2, description: "Series with episodes and sequences" },
        { id: "film", name: "Film", icon: "clapperboard", order: 3, description: "Feature film or short" },
        { id: "essay", name: "Essay", icon: "newspaper", order: 4, description: "Essay or short nonfiction piece" }
      ];
    }
    const templates = this.plugin.settings.projectTemplates || [];
    const defaultOptions = {};
    templates.sort((a, b) => a.order - b.order).forEach((t) => {
      defaultOptions[t.id] = t.name;
    });
    new import_obsidian8.Setting(templateContent).setName("Default template").setDesc("Default template used when creating new projects").addDropdown(
      (dropdown) => dropdown.addOptions(defaultOptions).setValue(this.plugin.settings.defaultProjectType || "book").onChange(async (value) => {
        this.plugin.settings.defaultProjectType = value;
        await this.plugin.saveSettings();
      })
    );
    templateContent.createEl("h4", { text: "Project templates", cls: "folio-settings-subheader" });
    const templatesHeaderRow = templateContent.createDiv({ cls: "folio-templates-header-row" });
    const resetBtn = templatesHeaderRow.createEl("button", { cls: "folio-reset-templates-btn" });
    (0, import_obsidian8.setIcon)(resetBtn, "rotate-ccw");
    resetBtn.title = "Reset all templates to defaults";
    resetBtn.onclick = async () => {
      const confirmed = confirm("Are you sure you want to reset all templates to their default values? This will remove any custom templates and restore the original Book, TV Show, Film, and Essay templates.");
      if (confirmed) {
        this.plugin.settings.projectTemplates = JSON.parse(JSON.stringify(DEFAULT_SETTINGS.projectTemplates));
        await this.plugin.saveSettings();
        this.renderTemplatesList(templatesListEl);
        this.plugin.rerenderViews();
        new import_obsidian8.Notice("Templates reset to defaults");
      }
    };
    const templatesListEl = templateContent.createDiv({ cls: "folio-templates-list" });
    this.renderTemplatesList(templatesListEl);
    const addBtnContainer = templateContent.createDiv({ cls: "folio-settings-add-btn-container" });
    const addBtn = addBtnContainer.createEl("button", { text: "Add new template", cls: "mod-cta folio-add-template-btn" });
    addBtn.onclick = () => {
      this.openTemplateEditor(null, templatesListEl);
    };
  }
  renderTemplatesList(container) {
    container.empty();
    const templates = (this.plugin.settings.projectTemplates || []).sort((a, b) => a.order - b.order);
    templates.forEach((template, index) => {
      const row = container.createDiv({ cls: "folio-template-row" });
      const iconEl = row.createDiv({ cls: "folio-template-icon" });
      (0, import_obsidian8.setIcon)(iconEl, template.icon || "file");
      const infoEl = row.createDiv({ cls: "folio-template-info" });
      infoEl.createDiv({ text: template.name, cls: "folio-template-name" });
      infoEl.createDiv({ text: template.description || "", cls: "folio-template-desc" });
      const actionsEl = row.createDiv({ cls: "folio-template-actions" });
      const editBtn = actionsEl.createEl("button", { cls: "folio-template-action-btn" });
      (0, import_obsidian8.setIcon)(editBtn, "pencil");
      editBtn.title = "Edit template";
      editBtn.onclick = () => {
        this.openTemplateEditor(template, container);
      };
      if (templates.length > 1) {
        const deleteBtn = actionsEl.createEl("button", { cls: "folio-template-action-btn mod-danger" });
        (0, import_obsidian8.setIcon)(deleteBtn, "trash");
        deleteBtn.title = "Delete template";
        deleteBtn.onclick = async () => {
          this.plugin.settings.projectTemplates = templates.filter((t) => t.id !== template.id);
          await this.plugin.saveSettings();
          this.renderTemplatesList(container);
          this.plugin.rerenderViews();
        };
      }
    });
  }
  openTemplateEditor(template, listContainer) {
    var _a;
    const isNew = !template;
    const editData = template ? JSON.parse(JSON.stringify(template)) : {
      id: `custom-${Date.now()}`,
      name: "",
      icon: "file",
      order: (((_a = this.plugin.settings.projectTemplates) == null ? void 0 : _a.length) || 0) + 1,
      description: "",
      structure: []
    };
    if (!editData.structure) {
      editData.structure = [];
    }
    const overlay = document.createElement("div");
    overlay.className = "folio-template-editor-overlay";
    const modal = document.createElement("div");
    modal.className = "folio-template-editor-modal folio-template-editor-modal-large";
    const title = document.createElement("h3");
    title.textContent = isNew ? "Add new template" : "Edit template";
    modal.appendChild(title);
    const nameRow = document.createElement("div");
    nameRow.className = "folio-template-editor-row";
    const nameLabel = document.createElement("label");
    nameLabel.textContent = "Name";
    const nameInput = document.createElement("input");
    nameInput.type = "text";
    nameInput.className = "folio-template-editor-input";
    nameInput.value = editData.name;
    nameInput.placeholder = "Template name";
    nameInput.onkeydown = (e) => e.stopPropagation();
    nameRow.appendChild(nameLabel);
    nameRow.appendChild(nameInput);
    modal.appendChild(nameRow);
    const iconRow = document.createElement("div");
    iconRow.className = "folio-template-editor-row";
    const iconLabel = document.createElement("label");
    iconLabel.textContent = "Icon";
    iconRow.appendChild(iconLabel);
    const iconInputRow = document.createElement("div");
    iconInputRow.className = "folio-template-icon-input-row";
    const iconPreview = document.createElement("span");
    iconPreview.className = "folio-template-icon-preview folio-icon-clickable";
    iconPreview.title = "Click to browse icons";
    const iconInput = document.createElement("input");
    iconInput.type = "text";
    iconInput.className = "folio-template-editor-input";
    iconInput.value = editData.icon;
    iconInput.placeholder = "e.g., book, newspaper, file";
    iconInput.onkeydown = (e) => e.stopPropagation();
    iconInputRow.appendChild(iconPreview);
    iconInputRow.appendChild(iconInput);
    iconRow.appendChild(iconInputRow);
    modal.appendChild(iconRow);
    const updateIconPreview = () => {
      iconPreview.innerHTML = "";
      try {
        (0, import_obsidian8.setIcon)(iconPreview, iconInput.value || "file");
      } catch (e) {
        (0, import_obsidian8.setIcon)(iconPreview, "file");
      }
    };
    updateIconPreview();
    iconInput.addEventListener("input", updateIconPreview);
    iconPreview.onclick = () => {
      new IconPickerModal(this.app, {
        title: "Select Template Icon",
        currentIcon: iconInput.value,
        onSelect: (iconName) => {
          iconInput.value = iconName;
          updateIconPreview();
        }
      }).open();
    };
    const descRow = document.createElement("div");
    descRow.className = "folio-template-editor-row";
    const descLabel = document.createElement("label");
    descLabel.textContent = "Description";
    const descInput = document.createElement("input");
    descInput.type = "text";
    descInput.className = "folio-template-editor-input";
    descInput.value = editData.description || "";
    descInput.placeholder = "Short description";
    descInput.onkeydown = (e) => e.stopPropagation();
    descRow.appendChild(descLabel);
    descRow.appendChild(descInput);
    modal.appendChild(descRow);
    const structureSection = document.createElement("div");
    structureSection.className = "folio-template-structure-section";
    const structureHeader = document.createElement("div");
    structureHeader.className = "folio-template-structure-header";
    const structureLabel = document.createElement("label");
    structureLabel.textContent = "Default structure";
    structureHeader.appendChild(structureLabel);
    const structureActions = document.createElement("div");
    structureActions.className = "folio-template-structure-actions";
    const addFileBtn = document.createElement("button");
    addFileBtn.className = "folio-template-structure-add-btn";
    addFileBtn.type = "button";
    (0, import_obsidian8.setIcon)(addFileBtn, "file-plus");
    addFileBtn.appendChild(document.createTextNode(" File"));
    addFileBtn.onclick = () => {
      editData.structure.push({ title: "New File", type: "file" });
      renderStructureTree();
    };
    const addFolderBtn = document.createElement("button");
    addFolderBtn.className = "folio-template-structure-add-btn";
    addFolderBtn.type = "button";
    (0, import_obsidian8.setIcon)(addFolderBtn, "folder-plus");
    addFolderBtn.appendChild(document.createTextNode(" Folder"));
    addFolderBtn.onclick = () => {
      editData.structure.push({ title: "New Folder", type: "folder", children: [] });
      renderStructureTree();
    };
    const addCanvasBtn = document.createElement("button");
    addCanvasBtn.className = "folio-template-structure-add-btn";
    addCanvasBtn.type = "button";
    (0, import_obsidian8.setIcon)(addCanvasBtn, "layout-dashboard");
    addCanvasBtn.appendChild(document.createTextNode(" Canvas"));
    addCanvasBtn.onclick = () => {
      editData.structure.push({ title: "New Canvas", type: "canvas" });
      renderStructureTree();
    };
    structureActions.appendChild(addFileBtn);
    structureActions.appendChild(addFolderBtn);
    structureActions.appendChild(addCanvasBtn);
    structureHeader.appendChild(structureActions);
    structureSection.appendChild(structureHeader);
    const structureTree = document.createElement("div");
    structureTree.className = "folio-template-structure-tree";
    structureSection.appendChild(structureTree);
    const expandedFolders = /* @__PURE__ */ new Set();
    let draggedNode = null;
    let draggedIndex = null;
    let draggedParentArray = null;
    const renderStructureTree = () => {
      structureTree.innerHTML = "";
      const renderNode = (node, parentArray, index, depth = 0) => {
        const nodeContainer = document.createElement("div");
        nodeContainer.className = "folio-template-structure-node-container";
        const nodeRow = document.createElement("div");
        nodeRow.className = "folio-template-structure-node";
        nodeRow.style.paddingLeft = `${depth * 20}px`;
        nodeRow.draggable = true;
        const dragHandle = document.createElement("span");
        dragHandle.className = "folio-template-structure-node-drag-handle";
        dragHandle.title = "Drag to reorder";
        (0, import_obsidian8.setIcon)(dragHandle, "grip-horizontal");
        nodeRow.appendChild(dragHandle);
        nodeRow.addEventListener("dragstart", (e) => {
          draggedNode = node;
          draggedIndex = index;
          draggedParentArray = parentArray;
          nodeRow.classList.add("dragging");
          e.dataTransfer.effectAllowed = "move";
          setTimeout(() => nodeRow.style.opacity = "0.5", 0);
        });
        nodeRow.addEventListener("dragend", (e) => {
          nodeRow.style.opacity = "1";
          nodeRow.classList.remove("dragging");
          document.querySelectorAll(".folio-template-structure-node").forEach((n) => {
            n.classList.remove("drag-over");
          });
        });
        nodeRow.addEventListener("dragover", (e) => {
          e.preventDefault();
          e.dataTransfer.dropEffect = "move";
          nodeRow.classList.add("drag-over");
        });
        nodeRow.addEventListener("dragleave", (e) => {
          nodeRow.classList.remove("drag-over");
        });
        nodeRow.addEventListener("drop", (e) => {
          e.preventDefault();
          e.stopPropagation();
          nodeRow.classList.remove("drag-over");
          if (draggedNode && draggedParentArray === parentArray && draggedIndex !== index) {
            parentArray.splice(draggedIndex, 1);
            const newIndex = draggedIndex < index ? index - 1 : index;
            parentArray.splice(newIndex, 0, draggedNode);
            renderStructureTree();
          }
          draggedNode = null;
          draggedIndex = null;
          draggedParentArray = null;
        });
        if (node.type === "folder") {
          const toggleBtn = document.createElement("span");
          toggleBtn.className = "folio-template-structure-node-toggle";
          const isExpanded = expandedFolders.has(node);
          (0, import_obsidian8.setIcon)(toggleBtn, isExpanded ? "chevron-down" : "chevron-right");
          toggleBtn.onclick = () => {
            if (expandedFolders.has(node)) {
              expandedFolders.delete(node);
            } else {
              expandedFolders.add(node);
            }
            renderStructureTree();
          };
          nodeRow.appendChild(toggleBtn);
        } else {
          const spacer = document.createElement("span");
          spacer.className = "folio-template-structure-node-spacer";
          nodeRow.appendChild(spacer);
        }
        const nodeIcon = document.createElement("span");
        nodeIcon.className = "folio-template-structure-node-icon folio-icon-clickable";
        nodeIcon.title = "Click to change icon";
        const defaultIcon = node.type === "folder" ? "folder" : node.type === "canvas" ? "layout-dashboard" : "file";
        (0, import_obsidian8.setIcon)(nodeIcon, node.icon || defaultIcon);
        nodeIcon.onclick = (e) => {
          e.stopPropagation();
          new IconPickerModal(this.app, {
            title: `Select Icon for "${node.title}"`,
            currentIcon: node.icon || defaultIcon,
            onSelect: (iconName) => {
              node.icon = iconName;
              renderStructureTree();
            }
          }).open();
        };
        nodeRow.appendChild(nodeIcon);
        const titleInput = document.createElement("input");
        titleInput.type = "text";
        titleInput.className = "folio-template-structure-node-title";
        titleInput.value = node.title;
        titleInput.onclick = (e) => e.stopPropagation();
        titleInput.onkeydown = (e) => e.stopPropagation();
        titleInput.oninput = (e) => {
          node.title = e.target.value;
        };
        titleInput.onblur = (e) => {
          node.title = e.target.value.trim() || "Untitled";
          if (!e.target.value.trim()) {
            e.target.value = "Untitled";
          }
        };
        nodeRow.appendChild(titleInput);
        const typeBadge = document.createElement("span");
        typeBadge.className = "folio-template-structure-node-type";
        typeBadge.textContent = node.type;
        nodeRow.appendChild(typeBadge);
        const nodeActions = document.createElement("div");
        nodeActions.className = "folio-template-structure-node-actions";
        if (node.type === "folder") {
          const addFileBtn2 = document.createElement("button");
          addFileBtn2.className = "folio-template-structure-node-btn";
          addFileBtn2.type = "button";
          addFileBtn2.title = "Add file";
          (0, import_obsidian8.setIcon)(addFileBtn2, "file-plus");
          addFileBtn2.onclick = () => {
            if (!node.children)
              node.children = [];
            node.children.push({ title: "New File", type: "file" });
            expandedFolders.add(node);
            renderStructureTree();
          };
          nodeActions.appendChild(addFileBtn2);
          const addFolderBtn2 = document.createElement("button");
          addFolderBtn2.className = "folio-template-structure-node-btn";
          addFolderBtn2.type = "button";
          addFolderBtn2.title = "Add folder";
          (0, import_obsidian8.setIcon)(addFolderBtn2, "folder-plus");
          addFolderBtn2.onclick = () => {
            if (!node.children)
              node.children = [];
            node.children.push({ title: "New Folder", type: "folder", children: [] });
            expandedFolders.add(node);
            renderStructureTree();
          };
          nodeActions.appendChild(addFolderBtn2);
          const addCanvasBtn2 = document.createElement("button");
          addCanvasBtn2.className = "folio-template-structure-node-btn";
          addCanvasBtn2.type = "button";
          addCanvasBtn2.title = "Add canvas";
          (0, import_obsidian8.setIcon)(addCanvasBtn2, "layout-dashboard");
          addCanvasBtn2.onclick = () => {
            if (!node.children)
              node.children = [];
            node.children.push({ title: "New Canvas", type: "canvas" });
            expandedFolders.add(node);
            renderStructureTree();
          };
          nodeActions.appendChild(addCanvasBtn2);
        }
        const deleteBtn = document.createElement("button");
        deleteBtn.className = "folio-template-structure-node-btn mod-danger";
        deleteBtn.type = "button";
        deleteBtn.title = "Delete";
        (0, import_obsidian8.setIcon)(deleteBtn, "trash");
        deleteBtn.onclick = () => {
          parentArray.splice(index, 1);
          renderStructureTree();
        };
        nodeActions.appendChild(deleteBtn);
        nodeRow.appendChild(nodeActions);
        nodeContainer.appendChild(nodeRow);
        structureTree.appendChild(nodeContainer);
        if (node.type === "folder" && node.children && node.children.length > 0 && expandedFolders.has(node)) {
          node.children.forEach((child, childIndex) => {
            renderNode(child, node.children, childIndex, depth + 1);
          });
        }
      };
      if (editData.structure.length === 0) {
        const emptyMsg = document.createElement("div");
        emptyMsg.className = "folio-template-structure-empty";
        emptyMsg.textContent = "No items. Add files or folders above.";
        structureTree.appendChild(emptyMsg);
      } else {
        editData.structure.forEach((node, index) => {
          renderNode(node, editData.structure, index, 0);
        });
      }
    };
    renderStructureTree();
    modal.appendChild(structureSection);
    const actions = document.createElement("div");
    actions.className = "folio-template-editor-actions";
    const cancelBtn = document.createElement("button");
    cancelBtn.className = "folio-template-editor-cancel";
    cancelBtn.textContent = "Cancel";
    cancelBtn.type = "button";
    cancelBtn.onclick = () => overlay.remove();
    const saveBtn = document.createElement("button");
    saveBtn.className = "folio-template-editor-save mod-cta";
    saveBtn.textContent = isNew ? "Add" : "Save";
    saveBtn.type = "button";
    saveBtn.onclick = async () => {
      const name = nameInput.value.trim();
      const icon = iconInput.value.trim() || "file";
      const desc = descInput.value.trim();
      if (!name) {
        nameInput.style.borderColor = "red";
        return;
      }
      editData.name = name;
      editData.icon = icon;
      editData.description = desc;
      if (isNew) {
        this.plugin.settings.projectTemplates = this.plugin.settings.projectTemplates || [];
        this.plugin.settings.projectTemplates.push(editData);
      } else {
        const idx = this.plugin.settings.projectTemplates.findIndex((t) => t.id === editData.id);
        if (idx !== -1) {
          this.plugin.settings.projectTemplates[idx] = editData;
        }
      }
      await this.plugin.saveSettings();
      overlay.remove();
      this.renderTemplatesList(listContainer);
      this.plugin.rerenderViews();
    };
    actions.appendChild(cancelBtn);
    actions.appendChild(saveBtn);
    modal.appendChild(actions);
    overlay.appendChild(modal);
    document.body.appendChild(overlay);
    overlay.onclick = (e) => {
      if (e.target === overlay)
        overlay.remove();
    };
    modal.onkeydown = (e) => e.stopPropagation();
    modal.onkeyup = (e) => e.stopPropagation();
    modal.onkeypress = (e) => e.stopPropagation();
    nameInput.focus();
  }
};

// src/main.js
init_newBookModal();
init_switchBookModal();
init_manageBooksModal();
init_editBookModal();
init_helpModal();
init_textInputModal();
init_confirmModal();
var {
  Plugin,
  PluginSettingTab: PluginSettingTab2,
  Setting: Setting2,
  ItemView: ItemView3,
  TFile: TFile6,
  TFolder: TFolder4,
  Modal: Modal11,
  Menu: Menu2,
  setIcon: setIcon8
} = require("obsidian");
module.exports = class FolioPlugin extends Plugin {
  async onload() {
    var _a;
    await this.loadSettings();
    console.log("[Folio] onload - basePath after loadSettings:", this.settings.basePath);
    console.log("[Folio] onload - lastActiveBookPath:", this.settings.lastActiveBookPath);
    this.configService = new ConfigService(this.app);
    this.treeService = new TreeService(this.app, this.configService);
    this.statsService = new StatsService(this.app, this.configService);
    this.bookService = new BookService(this.app, this.configService);
    this.booksIndex = [];
    this.activeBook = null;
    this.folioLeaf = null;
    this.activeFile = null;
    console.log("[Folio] onload - about to ensureBasePath, getBasePath():", this.getBasePath());
    await this.ensureBasePath();
    await this.scanBooks();
    console.log("[Folio] onload - after scanBooks, booksIndex:", this.booksIndex.map((b) => b.path));
    try {
      if (this.settings && this.settings.lastActiveBookPath) {
        const byPath = this.booksIndex.find((b) => b.path === this.settings.lastActiveBookPath);
        console.log("[Folio] onload - looking for lastActiveBookPath:", this.settings.lastActiveBookPath, "found:", !!byPath);
        if (byPath)
          this.activeBook = byPath;
      }
    } catch (e) {
    }
    console.log("[Folio] onload - activeBook:", ((_a = this.activeBook) == null ? void 0 : _a.path) || "none");
    this.expandedFolders = /* @__PURE__ */ new Set();
    this.activeFilePath = null;
    this.registerView(
      VIEW_TYPE,
      (leaf) => new FolioView(leaf, this)
    );
    this.registerView(
      WRITER_TOOLS_VIEW_TYPE,
      (leaf) => new WriterToolsView(leaf, this)
    );
    this.addRibbonIcon("book", "Open Folio", () => {
      this.activateFolio();
    });
    this.addSettingTab(new FolioSettingTab(this.app, this));
    this.registerEvent(
      this.app.vault.on("create", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("delete", () => this.refresh())
    );
    this.registerEvent(
      this.app.vault.on("rename", async () => {
        var _a2;
        const activePath = (_a2 = this.activeBook) == null ? void 0 : _a2.path;
        await this.refresh();
        if (activePath) {
          const book = this.booksIndex.find((b) => b.path === activePath);
          if (book) {
            this.activeBook = book;
            try {
              await this.syncChapterStatsBaseline(book);
            } catch (e) {
              console.warn("syncChapterStatsBaseline (rename) failed", e);
            }
          }
        }
      })
    );
    this._statsDebounceTimers = {};
    this.registerEvent(
      this.app.vault.on("modify", (file) => {
        try {
          this.onFileModified(file);
        } catch (e) {
          console.warn("onFileModified handler failed", e);
        }
      })
    );
    try {
      this.registerEvent(
        this.app.workspace.on("editor-change", (editor, view) => {
          try {
            const f = view == null ? void 0 : view.file;
            if (f)
              this.onFileModified(f);
            if (editor && typeof editor.getValue === "function") {
              const text = editor.getValue();
              const leaves = this.app.workspace.getLeavesOfType(WRITER_TOOLS_VIEW_TYPE);
              for (const leaf of leaves) {
                const wtView = leaf.view;
                if (wtView && typeof wtView.updateFocusSessionWordsFromEditor === "function") {
                  wtView.updateFocusSessionWordsFromEditor(text, f);
                }
              }
            }
          } catch (e) {
            console.warn("editor-change handler failed", e);
          }
        })
      );
    } catch (e) {
    }
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        const af = this.app.workspace.getActiveFile();
        this.activeFilePath = af ? af.path : null;
        try {
          this.updateActiveFileInViews();
        } catch (e) {
          this.rerenderViews();
        }
      })
    );
  }
  // Minimal chapter context menu (Open in new tab/pane, Exclude toggle, Create copy, Rename, Delete)
  async openChapterContextMenu(evt, file, node = null) {
    var _a, _b, _c;
    try {
      (_a = evt.preventDefault) == null ? void 0 : _a.call(evt);
      const menu = new Menu2(this.app);
      let shouldCount = !(node == null ? void 0 : node.exclude);
      try {
        const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
        if (book) {
          const cfg = await this.loadBookConfig(book) || {};
          const projectType = ((_b = cfg.basic) == null ? void 0 : _b.projectType) || PROJECT_TYPES.BOOK;
          const overrides = this.statsService.buildStatsOverrideSets(((_c = cfg.structure) == null ? void 0 : _c.tree) || []);
          const rules = this.statsService.getStatsRulesForProjectType(projectType);
          shouldCount = this.statsService.shouldCountFileForStats(
            file,
            book.path,
            projectType,
            rules,
            overrides
          );
        }
      } catch (e) {
        console.warn("Failed to load stats inclusion state", e);
      }
      menu.addItem(
        (it) => it.setTitle("Open in new tab").setIcon("file").onClick(() => {
          (async () => {
            try {
              const leaf = this.app.workspace.getLeaf("tab");
              if (leaf && typeof leaf.openFile === "function") {
                await leaf.openFile(file);
              }
            } catch (e) {
              try {
                const leaf = this.app.workspace.getLeaf(true);
                if (leaf && typeof leaf.openFile === "function")
                  await leaf.openFile(file);
              } catch (e2) {
                console.warn(e2);
              }
            }
          })();
        })
      );
      menu.addItem(
        (it) => it.setTitle("Open in new pane").setIcon("split").onClick(() => {
          (async () => {
            try {
              const leaf = this.app.workspace.getLeaf("split");
              if (leaf && typeof leaf.openFile === "function") {
                await leaf.openFile(file);
              }
            } catch (e) {
              try {
                const leaf = this.app.workspace.getLeaf(true);
                if (leaf && typeof leaf.openFile === "function")
                  await leaf.openFile(file);
              } catch (e2) {
                console.warn(e2);
              }
            }
          })();
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle(shouldCount ? "Exclude from stats" : "Include in stats").setIcon(shouldCount ? "eye-off" : "eye").onClick(() => {
          this.setStatsOverride(file, shouldCount ? "exclude" : "include");
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle("Create copy").setIcon("copy").onClick(() => {
          try {
            this.app.fileManager.duplicateFile(file);
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Rename").setIcon("pencil").onClick(() => {
          try {
            this.app.fileManager.promptForFileRename(file);
          } catch (e) {
            console.warn(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Delete").setIcon("trash").onClick(async () => {
          try {
            await this.app.vault.delete(file, file instanceof TFolder4);
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.showAtMouseEvent(evt);
    } catch (e) {
      console.error(e);
    }
  }
  openVolumeMenu(evt, folder, isRoot = false, node = null) {
    var _a;
    try {
      (_a = evt.preventDefault) == null ? void 0 : _a.call(evt);
      const menu = new Menu2(this.app);
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New root canvas" : "New canvas").setIcon("layout-dashboard").onClick(async () => {
          try {
            const folderObj = folder instanceof TFolder4 ? folder : this.app.vault.getAbstractFileByPath((folder == null ? void 0 : folder.path) || folder);
            if (!(folderObj instanceof TFolder4))
              return;
            let base = "Canvas";
            let name = `${base}.canvas`;
            let i = 1;
            while (this.app.vault.getAbstractFileByPath(`${folderObj.path}/${name}`)) {
              i += 1;
              name = `${base} ${i}.canvas`;
            }
            await this.app.vault.create(`${folderObj.path}/${name}`, "");
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New root file" : "New file").setIcon("file-plus").onClick(() => {
          const modal = new TextInputModal(this.app, {
            title: "New file",
            placeholder: "File name",
            cta: "Create",
            onSubmit: async (value) => {
              const name = (value || "").trim();
              if (!name)
                return;
              try {
                const fileName = name.endsWith(".md") ? name : `${name}.md`;
                const dest = `${folder.path}/${fileName}`;
                if (!this.app.vault.getAbstractFileByPath(dest)) {
                  await this.app.vault.create(dest, "");
                  const book = this.booksIndex.find((b) => dest.startsWith(b.path));
                  if (book)
                    await this.syncChapterStatsBaseline(book);
                }
                await this.refresh();
                this.rerenderViews();
              } catch (e) {
                console.error(e);
              }
            }
          });
          modal.open();
        })
      );
      menu.addItem(
        (it) => it.setTitle(isRoot ? "New volume" : "New folder").setIcon("folder-plus").onClick(() => {
          const modal = new TextInputModal(this.app, {
            title: "New folder",
            placeholder: "Folder name",
            cta: "Create",
            onSubmit: async (value) => {
              const name = (value || "").trim();
              if (!name)
                return;
              try {
                const dest = `${folder.path}/${name}`;
                if (!this.app.vault.getAbstractFileByPath(dest)) {
                  await this.app.vault.createFolder(dest);
                }
                await this.refresh();
                this.rerenderViews();
              } catch (e) {
                console.error(e);
              }
            }
          });
          modal.open();
        })
      );
      menu.addSeparator();
      if (!isRoot && node) {
        const isExcluded = node.exclude || false;
        menu.addItem(
          (it) => it.setTitle(isExcluded ? "Include in stats" : "Exclude from stats").setIcon(isExcluded ? "eye" : "eye-off").onClick(() => {
            this.toggleExcludeFromStats(folder, !isExcluded);
          })
        );
      }
      menu.addItem(
        (it) => it.setTitle("Create copy").setIcon("copy").onClick(() => {
          try {
            this.createCopy(folder.path);
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.addSeparator();
      menu.addItem(
        (it) => it.setTitle("Rename").setIcon("pencil").onClick(() => {
          try {
            this.app.fileManager.promptForFileRename(folder);
          } catch (e) {
            console.warn(e);
          }
        })
      );
      menu.addItem(
        (it) => it.setTitle("Delete").setIcon("trash").onClick(async () => {
          try {
            await this.app.vault.delete(folder, folder instanceof TFolder4);
            await this.refresh();
            this.rerenderViews();
          } catch (e) {
            console.error(e);
          }
        })
      );
      menu.showAtMouseEvent(evt);
    } catch (e) {
      console.error(e);
    }
  }
  // Helper: open a file in the current leaf
  openFile(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      this.app.workspace.openLinkText(file.path, "", false);
    }
  }
  // Helper: open file in a new tab (open in new leaf)
  openFileInNewTab(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      try {
        this.app.workspace.openLinkText(file.path, "", true);
      } catch (e) {
        const leaf = this.app.workspace.getLeaf(true);
        leaf.openFile(file);
      }
    }
  }
  // Helper: open file in a new split/pane
  openFileInNewPane(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file && file instanceof TFile6) {
      try {
        const leaf = this.app.workspace.getLeaf(true);
        leaf.openFile(file);
      } catch (e) {
        console.warn(e);
      }
    }
  }
  renamePath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (file) {
      try {
        this.app.fileManager.promptForFileRename(file);
      } catch (e) {
        console.warn(e);
      }
    }
  }
  async deletePath(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file)
      return;
    try {
      await this.app.vault.delete(file, file instanceof TFolder4);
      await this.refresh();
      this.rerenderViews();
    } catch (e) {
      console.error(e);
    }
  }
  createCopy(path) {
    const file = this.app.vault.getAbstractFileByPath(path);
    if (!file)
      return;
    try {
      if (file instanceof TFile6) {
        this.app.fileManager.duplicateFile(file);
      } else if (file instanceof TFolder4) {
        const parentPath = file.path.split("/").slice(0, -1).join("/") || "";
        const baseName = `${file.name} Copy`;
        let destPath = `${parentPath}/${baseName}`.replace(/\/+/g, "/");
        let i = 1;
        while (this.app.vault.getAbstractFileByPath(destPath)) {
          destPath = `${parentPath}/${baseName} ${i}`;
          i++;
        }
        const createFolderAndCopy = async (src, dest) => {
          await this.app.vault.createFolder(dest);
          const folder = this.app.vault.getAbstractFileByPath(src);
          if (!(folder instanceof TFolder4))
            return;
          for (const child of folder.children) {
            const childDest = `${dest}/${child.name}`;
            if (child instanceof TFile6) {
              const content = await this.app.vault.read(child);
              await this.app.vault.create(childDest, content);
            } else if (child instanceof TFolder4) {
              await createFolderAndCopy(child.path, childDest);
            }
          }
        };
        createFolderAndCopy(file.path, destPath).then(async () => {
          await this.refresh();
          this.rerenderViews();
        });
      }
    } catch (e) {
      console.error(e);
    }
  }
  async createNextChapterFile(folder) {
    var _a;
    try {
      const folderObj = folder instanceof TFolder4 ? folder : this.app.vault.getAbstractFileByPath((folder == null ? void 0 : folder.path) || folder);
      if (!(folderObj instanceof TFolder4))
        return;
      const existing = ((_a = folderObj.children) != null ? _a : []).filter((c) => c instanceof TFile6 && c.extension === "md").map((f) => f.basename);
      let max = 0;
      for (const name of existing) {
        const match = name.match(/^Chapter (\d+)$/i);
        if (match) {
          const n = parseInt(match[1], 10);
          if (!isNaN(n))
            max = Math.max(max, n);
        }
      }
      const next = max + 1;
      const fileName = `Chapter ${next}.md`;
      const path = `${folderObj.path}/${fileName}`;
      if (this.app.vault.getAbstractFileByPath(path))
        return;
      await this.app.vault.create(path, "");
      try {
        const book = this.booksIndex.find((b) => path.startsWith(b.path));
        if (book)
          await this.syncChapterStatsBaseline(book);
      } catch (e) {
        console.warn("syncChapterStatsBaseline (createNextChapterFile) failed", e);
      }
    } catch (e) {
      console.error(e);
    }
  }
  // Helper: create sub-volume (folder) under a given folder path via modal
  createSubVolume(parentFolderPath) {
    const modal = new TextInputModal(this.app, {
      title: "New folder",
      placeholder: "Folder name",
      cta: "Create",
      onSubmit: async (value) => {
        if (!value)
          return;
        const folderObj = { path: parentFolderPath };
        await this.createVolume(folderObj, value);
        await this.refresh();
        this.rerenderViews();
      }
    });
    modal.open();
  }
  /* Activate both views: Folio (left) + Writer Tools (right) */
  async activateFolio() {
    await this.activateView();
    await this.openWriterTools();
  }
  /* Reusable activator: always reuse the same leaf (singleton view) */
  async activateView() {
    const { workspace } = this.app;
    const existing = workspace.getLeavesOfType(VIEW_TYPE);
    if (existing.length > 0) {
      workspace.revealLeaf(existing[0]);
      this.folioLeaf = existing[0];
      return;
    }
    const leftLeaf = workspace.getLeftLeaf(false);
    await leftLeaf.setViewState({
      type: VIEW_TYPE,
      active: true
    });
    this.folioLeaf = leftLeaf;
    workspace.revealLeaf(leftLeaf);
  }
  /* Open Writer Tools in right sidebar */
  async openWriterTools() {
    const { workspace } = this.app;
    const existing = workspace.getLeavesOfType(WRITER_TOOLS_VIEW_TYPE);
    if (existing.length > 0) {
      workspace.revealLeaf(existing[0]);
      return;
    }
    const rightLeaf = workspace.getRightLeaf(false);
    await rightLeaf.setViewState({
      type: WRITER_TOOLS_VIEW_TYPE,
      active: true
    });
    workspace.revealLeaf(rightLeaf);
  }
  async refresh() {
    await this.scanBooks();
    this.rerenderViews();
  }
  // Normalize basePath - remove leading/trailing slashes and multiple slashes
  getBasePath() {
    let base = this.settings.basePath || "projects";
    base = base.replace(/^\/+|\/+$/g, "").replace(/\/+/g, "/");
    return base || "projects";
  }
  async ensureBasePath() {
    const base = this.getBasePath();
    if (!await this.app.vault.adapter.exists(base)) {
      await this.app.vault.createFolder(base);
    }
  }
  /* ===============================================================
   * SCAN BOOKS (filesystem source of truth)
   * =============================================================== */
  async scanBooks() {
    var _a, _b;
    const basePath = this.getBasePath();
    this.booksIndex = await this.bookService.scanBooks(basePath);
    if (!this.activeBook && this.booksIndex.length > 0) {
      this.activeBook = this.booksIndex[0];
    }
    this.activeBook = (_b = (_a = this.booksIndex.find(
      (b) => {
        var _a2;
        return b.path === ((_a2 = this.activeBook) == null ? void 0 : _a2.path);
      }
    )) != null ? _a : this.booksIndex[0]) != null ? _b : null;
  }
  /* ===============================================================
   * CREATE METHODS
   * =============================================================== */
  async createBook(name, projectType = "book", templateStructure = null) {
    const basePath = this.getBasePath();
    return this.bookService.createBook(basePath, name, projectType, templateStructure);
  }
  async ensureBookBaseStructure(bookFolder) {
    return this.bookService.ensureBookBaseStructure(bookFolder);
  }
  async createVolume(book, name) {
    return this.bookService.createVolume(book, name);
  }
  async createChapter(volume, name, projectType = "book") {
    const result = await this.bookService.createChapter(volume, name, projectType);
    try {
      const book = this.booksIndex.find((b) => `${volume.path}/${name}.md`.startsWith(b.path));
      if (book)
        await this.syncChapterStatsBaseline(book);
    } catch (e) {
      console.warn("syncChapterStatsBaseline (createChapter) failed", e);
    }
    return result;
  }
  /* Helpers for native file-menu integration */
  isVolumeFolder(file) {
    try {
      return this.booksIndex.some(
        (b) => b.volumes.some((v) => v.path === file.path)
      );
    } catch (e) {
      return false;
    }
  }
  isChapterFile(file) {
    try {
      return this.booksIndex.some(
        (b) => b.volumes.some(
          (v) => v.chapters.some((c) => c.path === file.path)
        )
      );
    } catch (e) {
      return false;
    }
  }
  async deleteVolume(folder) {
    const af = this.app.vault.getAbstractFileByPath(folder.path) || folder;
    await this.app.vault.delete(af, true);
    await this.refresh();
  }
  async deleteChapter(file) {
    const af = this.app.vault.getAbstractFileByPath(file.path) || file;
    await this.app.vault.delete(af);
    await this.refresh();
    try {
      const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
      if (book)
        await this.syncChapterStatsBaseline(book);
    } catch (e) {
      console.warn("syncChapterStatsBaseline (deleteChapter) failed", e);
    }
  }
  // Move a folder and all its children to trash
  async deleteFolderRecursive(path) {
    try {
      const af = this.app.vault.getAbstractFileByPath(path);
      if (!af)
        return;
      await this.app.vault.trash(af, true);
    } catch (e) {
      console.warn("deleteFolderRecursive (trash) failed", path, e);
    }
  }
  async toggleExcludeFromStats(file, exclude) {
    const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
    if (!book) {
      console.warn("Could not find book for file:", file.path);
      return;
    }
    await this.treeService.toggleExcludeFromStats(book, file, exclude);
    await this.computeAndSaveStatsForBook(book);
    await this.refresh();
    this.rerenderViews();
  }
  async setStatsOverride(file, action) {
    const book = this.booksIndex.find((b) => file.path.startsWith(b.path));
    if (!book) {
      console.warn("Could not find book for file:", file.path);
      return;
    }
    if (action === "include") {
      await this.treeService.setStatsOverride(book, file, { include: true, exclude: false });
    } else if (action === "exclude") {
      await this.treeService.setStatsOverride(book, file, { include: false, exclude: true });
    }
    await this.computeAndSaveStatsForBook(book);
    await this.refresh();
    this.rerenderViews();
  }
  async loadSettings() {
    const savedData = await this.loadData() || {};
    console.log("[Folio] loadSettings - savedData:", JSON.stringify(savedData, null, 2));
    console.log("[Folio] loadSettings - savedData.basePath:", savedData.basePath);
    this.settings = { ...DEFAULT_SETTINGS };
    Object.keys(savedData).forEach((key) => {
      if (key !== "projectTemplates") {
        this.settings[key] = savedData[key];
      }
    });
    console.log("[Folio] loadSettings - after merge, this.settings.basePath:", this.settings.basePath);
    if (savedData.projectTemplates && Array.isArray(savedData.projectTemplates)) {
      const defaultTemplatesMap = new Map(
        DEFAULT_SETTINGS.projectTemplates.map((t) => [t.id, t])
      );
      const mergedTemplates = savedData.projectTemplates.map((savedTemplate) => {
        const defaultTemplate = defaultTemplatesMap.get(savedTemplate.id);
        if (defaultTemplate) {
          return {
            id: savedTemplate.id,
            name: savedTemplate.name !== void 0 ? savedTemplate.name : defaultTemplate.name,
            icon: savedTemplate.icon !== void 0 ? savedTemplate.icon : defaultTemplate.icon,
            order: savedTemplate.order !== void 0 ? savedTemplate.order : defaultTemplate.order,
            description: savedTemplate.description !== void 0 ? savedTemplate.description : defaultTemplate.description,
            structure: savedTemplate.structure !== void 0 ? savedTemplate.structure : defaultTemplate.structure
          };
        }
        return savedTemplate;
      });
      DEFAULT_SETTINGS.projectTemplates.forEach((defaultTemplate) => {
        if (!mergedTemplates.find((t) => t.id === defaultTemplate.id)) {
          mergedTemplates.push({ ...defaultTemplate });
        }
      });
      this.settings.projectTemplates = mergedTemplates;
    }
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  // Delegate to ConfigService
  async loadBookConfig(book) {
    return this.configService.loadBookConfig(book);
  }
  // Delegate to ConfigService
  async saveBookConfig(book, config) {
    return this.configService.saveBookConfig(book, config);
  }
  // Delegate to ConfigService
  async loadBookMeta(book) {
    return this.configService.loadProjectMeta(book);
  }
  async waitForFolderSync(path, retries = 20) {
    const delay = (ms) => new Promise((r) => setTimeout(r, ms));
    while (retries-- > 0) {
      const folder = this.app.vault.getAbstractFileByPath(path);
      if (folder && folder.children && folder.children.length > 0)
        return;
      await delay(50);
    }
  }
  rerenderViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      try {
        if (view && typeof view.render === "function") {
          view.render();
        }
      } catch (e) {
        console.warn("render failed", e);
      }
    }
  }
  updateActiveFileInViews() {
    const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
    for (const leaf of leaves) {
      const view = leaf.view;
      try {
        if (!view || !view.contentEl)
          continue;
        const root = view.contentEl;
        const items = root.querySelectorAll(".tree-item");
        items.forEach((el) => {
          try {
            const p = el.getAttribute("data-path");
            if (p && p === this.activeFilePath)
              el.classList.add("is-active");
            else
              el.classList.remove("is-active");
          } catch (e) {
          }
        });
      } catch (e) {
        console.warn("updateActiveFileInViews failed", e);
      }
    }
  }
  // Update only the stats block in existing Folio views to avoid full re-renders
  async updateStatsInViews(book) {
    try {
      const leaves = this.app.workspace.getLeavesOfType(VIEW_TYPE);
      for (const leaf of leaves) {
        const view = leaf.view;
        try {
          if (!view || !view.statsEl)
            continue;
          if (!book || !view.plugin || !view.plugin.activeBook)
            continue;
          if (view.plugin.activeBook.path !== book.path)
            continue;
          if (typeof view.renderStats === "function") {
            await view.renderStats(view.statsEl, book);
          }
        } catch (e) {
        }
      }
    } catch (e) {
      console.warn("updateStatsInViews failed", e);
    }
  }
  // Handle modified files  debounce per-book to avoid excessive work
  async onFileModified(file) {
    try {
      if (!file || !file.path)
        return;
      if (file.extension !== "md" && !file.path.endsWith(".md"))
        return;
      const book = this.booksIndex.find((b) => file.path === b.path || file.path.startsWith(b.path + "/"));
      if (!book)
        return;
      const key = book.path;
      if (this._statsDebounceTimers[key])
        clearTimeout(this._statsDebounceTimers[key]);
      this._statsDebounceTimers[key] = setTimeout(() => {
        this.computeAndSaveStatsForBook(book).catch((e) => console.warn("computeAndSaveStatsForBook failed", e));
        delete this._statsDebounceTimers[key];
      }, 400);
    } catch (e) {
      console.warn("onFileModified error", e);
    }
  }
  // Walk folder recursively to collect markdown TFile objects
  _collectMarkdownFiles(folder) {
    const out = [];
    if (!folder || !folder.children)
      return out;
    for (const c of folder.children) {
      if (c instanceof TFile6 && c.name && c.name.toLowerCase().endsWith(".md"))
        out.push(c);
      else if (c.children) {
        out.push(...this._collectMarkdownFiles(c));
      }
    }
    return out;
  }
  // Count words in text
  _countWords(text) {
    if (!text)
      return 0;
    let content = text;
    const frontmatterRegex = /^---\s*\n[\s\S]*?\n---\s*\n/;
    content = content.replace(frontmatterRegex, "");
    content = content.replace(/^#{1,6}\s+/gm, "").replace(/\*\*([^*]+)\*\*/g, "$1").replace(/\*([^*]+)\*/g, "$1").replace(/\_\_([^_]+)\_\_/g, "$1").replace(/\_([^_]+)\_/g, "$1").replace(/\[([^\]]+)\]\([^\)]+\)/g, "$1").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1").replace(/^\s*[-*+]\s+/gm, "").replace(/^\s*\d+\.\s+/gm, "").replace(/^>\s+/gm, "");
    const parts = content.replace(/\n/g, " ").split(/\s+/).filter(Boolean);
    return parts.length;
  }
  _getTodayKey() {
    return new Date().toISOString().slice(0, 10);
  }
  // Delegate to StatsService
  async computeAndSaveStatsForBook(book) {
    const stats = await this.statsService.computeAndSaveStatsForBook(book);
    if (stats) {
      await this.updateStatsInViews(book);
    }
    return stats;
  }
  // Delegate to StatsService
  async syncChapterStatsBaseline(book) {
    return this.statsService.syncChapterStatsBaseline(book);
  }
  /* ===============================================================
   * TREE MANAGEMENT HELPERS (Book-Smith pattern)
   * =============================================================== */
  // Generate unique node ID
  generateNodeId() {
    return `node_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }
  async buildTreeFromFilesystem(bookFolder) {
    return this.treeService.buildTreeFromFilesystem(bookFolder);
  }
  async reorderTreeNodes(book, draggedNodeId, targetNodeId, position) {
    return this.treeService.reorderTreeNodes(book, draggedNodeId, targetNodeId, position);
  }
};
